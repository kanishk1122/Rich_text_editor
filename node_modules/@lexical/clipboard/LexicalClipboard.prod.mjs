/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{$generateHtmlFromNodes as t,$generateNodesFromDOM as e}from"@lexical/html";import{$addNodeStyle as n,$sliceSelectedTextNodeContent as o}from"@lexical/selection";import{objectKlassEquals as r}from"@lexical/utils";import{$isRangeSelection as l,$getSelection as i,$createTabNode as c,SELECTION_INSERT_CLIPBOARD_NODES_COMMAND as s,$getRoot as a,$parseSerializedNode as u,$isTextNode as d,COPY_COMMAND as f,COMMAND_PRIORITY_CRITICAL as p,isSelectionWithinEditor as m,$getEditor as h,$isElementNode as g,$cloneWithProperties as x}from"lexical";function w(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var y=w((function(t){const e=new URLSearchParams;e.append("code",t);for(let t=1;t<arguments.length;t++)e.append("v",arguments[t]);throw Error(`Minified Lexical error #${t}; visit https://lexical.dev/docs/error?${e} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const v="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,C=t=>v?(t||window).getSelection():null;function D(e,n=i()){return null==n&&y(166),l(n)&&n.isCollapsed()||0===n.getNodes().length?"":t(e,n)}function N(t,e=i()){return null==e&&y(166),l(e)&&e.isCollapsed()||0===e.getNodes().length?null:JSON.stringify(R(t,e))}function _(t,e){const n=t.getData("text/plain")||t.getData("text/uri-list");null!=n&&e.insertRawText(n)}function T(t,n,o){const r=t.getData("application/x-lexical-editor");if(r)try{const t=JSON.parse(r);if(t.namespace===o._config.namespace&&Array.isArray(t.nodes)){return S(o,E(t.nodes),n)}}catch(t){}const s=t.getData("text/html");if(s)try{const t=(new DOMParser).parseFromString(s,"text/html");return S(o,e(o,t),n)}catch(t){}const a=t.getData("text/plain")||t.getData("text/uri-list");if(null!=a)if(l(n)){const t=a.split(/(\r?\n|\t)/);""===t[t.length-1]&&t.pop();for(let e=0;e<t.length;e++){const n=i();if(l(n)){const o=t[e];"\n"===o||"\r\n"===o?n.insertParagraph():"\t"===o?n.insertNodes([c()]):n.insertText(o)}}}else n.insertRawText(a)}function S(t,e,n){t.dispatchCommand(s,{nodes:e,selection:n})||n.insertNodes(e)}function A(t,e,n,r=[]){let l=null===e||n.isSelected(e);const i=g(n)&&n.excludeFromCopy("html");let c=n;if(null!==e){let t=x(n);t=d(t)&&null!==e?o(e,t):t,c=t}const s=g(c)?c.getChildren():[],a=function(t){const e=t.exportJSON(),n=t.constructor;if(e.type!==n.getType()&&y(58,n.name),g(t)){const t=e.children;Array.isArray(t)||y(59,n.name)}return e}(c);if(d(c)){const t=c.__text;t.length>0?a.text=t:l=!1}for(let o=0;o<s.length;o++){const r=s[o],i=A(t,e,r,a.children);!l&&g(n)&&i&&n.extractWithChild(r,e,"clone")&&(l=!0)}if(l&&!i)r.push(a);else if(Array.isArray(a.children))for(let t=0;t<a.children.length;t++){const e=a.children[t];r.push(e)}return l}function R(t,e){const n=[],o=a().getChildren();for(let r=0;r<o.length;r++){A(t,e,o[r],n)}return{namespace:t._config.namespace,nodes:n}}function E(t){const e=[];for(let o=0;o<t.length;o++){const r=t[o],l=u(r);d(l)&&n(l),e.push(l)}return e}let O=null;async function P(t,e,n){if(null!==O)return!1;if(null!==e)return new Promise(((o,r)=>{t.update((()=>{o(b(t,e,n))}))}));const o=t.getRootElement(),l=null==t._window?window.document:t._window.document,i=C(t._window);if(null===o||null===i)return!1;const c=l.createElement("span");c.style.cssText="position: fixed; top: -1000px;",c.append(l.createTextNode("#")),o.append(c);const s=new Range;return s.setStart(c,0),s.setEnd(c,1),i.removeAllRanges(),i.addRange(s),new Promise(((e,o)=>{const i=t.registerCommand(f,(o=>(r(o,ClipboardEvent)&&(i(),null!==O&&(window.clearTimeout(O),O=null),e(b(t,o,n))),!0)),p);O=window.setTimeout((()=>{i(),O=null,e(!1)}),50),l.execCommand("copy"),c.remove()}))}function b(t,e,n){if(void 0===n){const e=C(t._window);if(!e)return!1;const o=e.anchorNode,r=e.focusNode;if(null!==o&&null!==r&&!m(t,o,r))return!1;const l=i();if(null===l)return!1;n=M(l)}e.preventDefault();const o=e.clipboardData;return null!==o&&(F(o,n),!0)}const J=[["text/html",D],["application/x-lexical-editor",N]];function M(t=i()){const e={"text/plain":t?t.getTextContent():""};if(t){const n=h();for(const[o,r]of J){const l=r(n,t);null!==l&&(e[o]=l)}}return e}function F(t,e){for(const n in e){const o=e[n];void 0!==o&&t.setData(n,o)}}export{R as $generateJSONFromSelectedNodes,E as $generateNodesFromSerializedNodes,M as $getClipboardDataFromSelection,D as $getHtmlContent,N as $getLexicalContent,_ as $insertDataTransferForPlainText,T as $insertDataTransferForRichText,S as $insertGeneratedNodes,P as copyToClipboard,F as setLexicalClipboardDataTransfer};
