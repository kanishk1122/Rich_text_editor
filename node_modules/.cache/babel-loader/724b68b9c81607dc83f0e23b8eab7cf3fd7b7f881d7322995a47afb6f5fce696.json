{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\nfunction addClassNamesToElement(element) {\n  for (var _len = arguments.length, classNames = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    classNames[_key - 1] = arguments[_key];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.add(...className.split(' '));\n    }\n  });\n}\nfunction removeClassNamesFromElement(element) {\n  for (var _len2 = arguments.length, classNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    classNames[_key2 - 1] = arguments[_key2];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\nfunction mergeRegister() {\n  for (var _len3 = arguments.length, func = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    func[_key3] = arguments[_key3];\n  }\n  return () => {\n    func.forEach(f => f());\n  };\n}\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction unstable_internalCreateNodeFromParse(parsedNode, parsedNodeMap, editor, parentKey, activeEditorState) {\n  const nodeType = parsedNode.__type;\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`createNodeFromParse: type \"${nodeType}\" + not found`);\n    }\n  } // Check for properties that are editors\n\n  for (const property in parsedNode) {\n    const value = parsedNode[property];\n    if (value != null && typeof value === 'object') {\n      const parsedEditorState = value.editorState;\n      if (parsedEditorState != null) {\n        const nestedEditor = lexical.createEditor({\n          namespace: parsedEditorState.namespace\n        });\n        nestedEditor._nodes = editor._nodes;\n        nestedEditor._parentEditor = editor._parentEditor;\n        nestedEditor._pendingEditorState = unstable_convertLegacyJSONEditorState(nestedEditor, parsedEditorState);\n        parsedNode[property] = nestedEditor;\n      }\n    }\n  }\n  const NodeKlass = registeredNode.klass;\n  const parsedKey = parsedNode.__key; // We set the parsedKey to undefined before calling clone() so that\n  // we get a new random key assigned.\n\n  parsedNode.__key = undefined;\n  const node = NodeKlass.clone(parsedNode);\n  parsedNode.__key = parsedKey;\n  const key = node.__key;\n  activeEditorState._nodeMap.set(key, node);\n  node.__parent = parentKey; // We will need to recursively handle the children in the case\n  // of a ElementNode.\n\n  if (lexical.$isElementNode(node)) {\n    const children = parsedNode.__children;\n    for (let i = 0; i < children.length; i++) {\n      const childKey = children[i];\n      const parsedChild = parsedNodeMap.get(childKey);\n      if (parsedChild !== undefined) {\n        const child = unstable_internalCreateNodeFromParse(parsedChild, parsedNodeMap, editor, key, activeEditorState);\n        const newChildKey = child.__key;\n        node.__children.push(newChildKey);\n      }\n    }\n    node.__indent = parsedNode.__indent;\n    node.__format = parsedNode.__format;\n    node.__dir = parsedNode.__dir;\n  } else if (lexical.$isTextNode(node)) {\n    node.__format = parsedNode.__format;\n    node.__style = parsedNode.__style;\n    node.__mode = parsedNode.__mode;\n    node.__detail = parsedNode.__detail;\n  }\n  return node;\n}\nfunction unstable_parseEditorState(parsedEditorState, editor) {\n  // This is hacky, do not do this!\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const EditorStateClass = editor._editorState.constructor;\n  const nodeMap = new Map();\n  const editorState = new EditorStateClass(nodeMap);\n  const parsedNodeMap = new Map(parsedEditorState._nodeMap); // root always exists in Map\n\n  const parsedRoot = parsedNodeMap.get('root');\n  const isUpdating = editor._updating;\n  try {\n    editor._updating = false;\n    editor.update(() => {\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      const dirtyType = editor._dirtyType;\n      editor._dirtyElements = new Map();\n      editor._dirtyLeaves = new Set();\n      editor._dirtyType = 0;\n      try {\n        unstable_internalCreateNodeFromParse(parsedRoot, parsedNodeMap, editor, null, editorState);\n      } finally {\n        editor._dirtyElements = dirtyElements;\n        editor._dirtyLeaves = dirtyLeaves;\n        editor._dirtyType = dirtyType;\n      }\n    });\n  } finally {\n    editor._updating = isUpdating;\n  }\n  editorState._readOnly = true;\n  return editorState;\n} // TODO: remove this function in version 0.4\n\nfunction unstable_convertLegacyJSONEditorState(editor, maybeStringifiedEditorState) {\n  const parsedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n  return unstable_parseEditorState(parsedEditorState, editor);\n}\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map(editorState._nodeMap);\n  const activeEditorState = editor._pendingEditorState;\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  lexical.$setSelection(selection === null ? null : selection.clone());\n}\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    const focusNode = selection.focus.getNode();\n    focusNode.getTopLevelElementOrThrow().insertAfter(node);\n  } else if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n    const nodes = selection.getNodes();\n    nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n  } else {\n    const root = lexical.$getRoot();\n    root.append(node);\n  }\n  const paragraphNode = lexical.$createParagraphNode();\n  node.insertAfter(paragraphNode);\n  paragraphNode.select();\n  return node.getLatest();\n}\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\nexports.unstable_convertLegacyJSONEditorState = unstable_convertLegacyJSONEditorState;","map":{"version":3,"names":["lexical","require","addClassNamesToElement","element","_len","arguments","length","classNames","Array","_key","forEach","className","classList","add","split","removeClassNamesFromElement","_len2","_key2","remove","$dfs","startingNode","endingNode","nodes","start","$getRoot","getLatest","end","$isElementNode","getLastDescendant","node","depth","$getDepth","is","push","getChildrenSize","getFirstChild","sibling","getNextSibling","getParent","innerNode","$getNearestNodeOfType","klass","parent","$getNearestBlockElementAncestorOrThrow","startNode","blockNode","$findMatchingParent","isInline","Error","__key","findFn","curr","mergeRegister","_len3","func","_key3","f","registerNestedElementResolver","editor","targetNode","cloneNode","handleOverlap","$isTargetNode","$findMatch","children","getChildren","i","child","parentNode","childNode","elementNodeTransform","match","nextSiblings","getNextSiblings","nextSiblingsLength","insertAfter","newParent","append","canBeEmpty","registerNodeTransform","unstable_internalCreateNodeFromParse","parsedNode","parsedNodeMap","parentKey","activeEditorState","nodeType","__type","registeredNode","_nodes","get","undefined","property","value","parsedEditorState","editorState","nestedEditor","createEditor","namespace","_parentEditor","_pendingEditorState","unstable_convertLegacyJSONEditorState","NodeKlass","parsedKey","clone","key","_nodeMap","set","__parent","__children","childKey","parsedChild","newChildKey","__indent","__format","__dir","$isTextNode","__style","__mode","__detail","unstable_parseEditorState","EditorStateClass","_editorState","constructor","nodeMap","Map","parsedRoot","isUpdating","_updating","update","dirtyElements","_dirtyElements","dirtyLeaves","_dirtyLeaves","dirtyType","_dirtyType","Set","_readOnly","maybeStringifiedEditorState","JSON","parse","$restoreEditorState","FULL_RECONCILE","selection","_selection","$setSelection","$insertNodeToNearestRoot","$getSelection","$isRangeSelection","focusNode","focus","getNode","getTopLevelElementOrThrow","$isNodeSelection","DEPRECATED_$isGridSelection","getNodes","root","paragraphNode","$createParagraphNode","select","$wrapNodeInElement","createElementNode","elementNode","replace","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/react/node_modules/@lexical/utils/LexicalUtils.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.add(...className.split(' '));\n    }\n  });\n}\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n\n    return null;\n  };\n\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction unstable_internalCreateNodeFromParse(parsedNode, parsedNodeMap, editor, parentKey, activeEditorState) {\n  const nodeType = parsedNode.__type;\n\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`createNodeFromParse: type \"${nodeType}\" + not found`);\n    }\n  } // Check for properties that are editors\n\n\n  for (const property in parsedNode) {\n    const value = parsedNode[property];\n\n    if (value != null && typeof value === 'object') {\n      const parsedEditorState = value.editorState;\n\n      if (parsedEditorState != null) {\n        const nestedEditor = lexical.createEditor({\n          namespace: parsedEditorState.namespace\n        });\n        nestedEditor._nodes = editor._nodes;\n        nestedEditor._parentEditor = editor._parentEditor;\n        nestedEditor._pendingEditorState = unstable_convertLegacyJSONEditorState(nestedEditor, parsedEditorState);\n        parsedNode[property] = nestedEditor;\n      }\n    }\n  }\n\n  const NodeKlass = registeredNode.klass;\n  const parsedKey = parsedNode.__key; // We set the parsedKey to undefined before calling clone() so that\n  // we get a new random key assigned.\n\n  parsedNode.__key = undefined;\n  const node = NodeKlass.clone(parsedNode);\n  parsedNode.__key = parsedKey;\n  const key = node.__key;\n\n  activeEditorState._nodeMap.set(key, node);\n\n  node.__parent = parentKey; // We will need to recursively handle the children in the case\n  // of a ElementNode.\n\n  if (lexical.$isElementNode(node)) {\n    const children = parsedNode.__children;\n\n    for (let i = 0; i < children.length; i++) {\n      const childKey = children[i];\n      const parsedChild = parsedNodeMap.get(childKey);\n\n      if (parsedChild !== undefined) {\n        const child = unstable_internalCreateNodeFromParse(parsedChild, parsedNodeMap, editor, key, activeEditorState);\n        const newChildKey = child.__key;\n\n        node.__children.push(newChildKey);\n      }\n    }\n\n    node.__indent = parsedNode.__indent;\n    node.__format = parsedNode.__format;\n    node.__dir = parsedNode.__dir;\n  } else if (lexical.$isTextNode(node)) {\n    node.__format = parsedNode.__format;\n    node.__style = parsedNode.__style;\n    node.__mode = parsedNode.__mode;\n    node.__detail = parsedNode.__detail;\n  }\n\n  return node;\n}\n\nfunction unstable_parseEditorState(parsedEditorState, editor) {\n  // This is hacky, do not do this!\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const EditorStateClass = editor._editorState.constructor;\n  const nodeMap = new Map();\n  const editorState = new EditorStateClass(nodeMap);\n  const parsedNodeMap = new Map(parsedEditorState._nodeMap); // root always exists in Map\n\n  const parsedRoot = parsedNodeMap.get('root');\n  const isUpdating = editor._updating;\n\n  try {\n    editor._updating = false;\n    editor.update(() => {\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      const dirtyType = editor._dirtyType;\n      editor._dirtyElements = new Map();\n      editor._dirtyLeaves = new Set();\n      editor._dirtyType = 0;\n\n      try {\n        unstable_internalCreateNodeFromParse(parsedRoot, parsedNodeMap, editor, null, editorState);\n      } finally {\n        editor._dirtyElements = dirtyElements;\n        editor._dirtyLeaves = dirtyLeaves;\n        editor._dirtyType = dirtyType;\n      }\n    });\n  } finally {\n    editor._updating = isUpdating;\n  }\n\n  editorState._readOnly = true;\n  return editorState;\n} // TODO: remove this function in version 0.4\n\n\nfunction unstable_convertLegacyJSONEditorState(editor, maybeStringifiedEditorState) {\n  const parsedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n  return unstable_parseEditorState(parsedEditorState, editor);\n}\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map(editorState._nodeMap);\n  const activeEditorState = editor._pendingEditorState;\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  lexical.$setSelection(selection === null ? null : selection.clone());\n}\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const focusNode = selection.focus.getNode();\n    focusNode.getTopLevelElementOrThrow().insertAfter(node);\n  } else if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n    const nodes = selection.getNodes();\n    nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n  } else {\n    const root = lexical.$getRoot();\n    root.append(node);\n  }\n\n  const paragraphNode = lexical.$createParagraphNode();\n  node.insertAfter(paragraphNode);\n  paragraphNode.select();\n  return node.getLatest();\n}\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\nexports.$dfs = $dfs;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.mergeRegister = mergeRegister;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\nexports.unstable_convertLegacyJSONEditorState = unstable_convertLegacyJSONEditorState;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}