{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport 'prismjs';\nimport 'prismjs/components/prism-clike.js';\nimport 'prismjs/components/prism-javascript.js';\nimport 'prismjs/components/prism-markup.js';\nimport 'prismjs/components/prism-markdown.js';\nimport 'prismjs/components/prism-c.js';\nimport 'prismjs/components/prism-css.js';\nimport 'prismjs/components/prism-objectivec.js';\nimport 'prismjs/components/prism-sql.js';\nimport 'prismjs/components/prism-powershell.js';\nimport 'prismjs/components/prism-python.js';\nimport 'prismjs/components/prism-rust.js';\nimport 'prismjs/components/prism-swift.js';\nimport 'prismjs/components/prism-typescript.js';\nimport 'prismjs/components/prism-java.js';\nimport 'prismjs/components/prism-cpp.js';\nimport { isHTMLElement, addClassNamesToElement, removeClassNamesFromElement, mergeRegister } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isTextNode, $isTabNode, $createTabNode, $createLineBreakNode, $applyNodeReplacement, TextNode, $isLineBreakNode, $createTextNode, $getNodeByKey, $getSelection, $isRangeSelection, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, INSERT_TAB_COMMAND, KEY_ARROW_UP_COMMAND, MOVE_TO_START, KEY_TAB_COMMAND, COMMAND_PRIORITY_LOW, $insertNodes, KEY_ARROW_DOWN_COMMAND, MOVE_TO_END } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst isLanguageSupportedByPrism = language => {\n  try {\n    // eslint-disable-next-line no-prototype-builtins\n    return language ? window.Prism.languages.hasOwnProperty(language) : false;\n  } catch (_unused) {\n    return false;\n  }\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-language';\nconst HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n\n/** @noInheritDoc */\nclass CodeNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = language;\n    this.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n        if (this.__isSyntaxHighlightSupported) {\n          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n      if (prevNode.__isSyntaxHighlightSupported) {\n        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);\n      }\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    addClassNamesToElement(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = $createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ($isTextNode(firstSelectionNode)) {\n      let node = getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ($isTabNode(node)) {\n          insertNodes.push($createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [$createLineBreakNode(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [$createLineBreakNode()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language;\n    writable.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n  getIsSyntaxHighlightSupported() {\n    return this.getLatest().__isSyntaxHighlightSupported;\n  }\n}\nfunction $createCodeNode(language) {\n  return $applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(window.Prism.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof window.Prism.languages[language] !== 'function').sort();\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends TextNode {\n  /** @internal */\n\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text, highlightType) {\n  return $applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeNodeOfLine(anchor) {\n  let previousNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || $isTabNode(node)) {\n    previousNode = node;\n    node = node.getPreviousSibling();\n  }\n  return previousNode;\n}\nfunction getLastCodeNodeOfLine(anchor) {\n  let nextNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || $isTabNode(node)) {\n    nextNode = node;\n    node = node.getNextSibling();\n  }\n  return nextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return window.Prism.tokenize(code, window.Prism.languages[language || ''] || window.Prism.languages[this.defaultLanguage]);\n  }\n};\nfunction getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n        throw Error(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ($isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || $isLineBreakNode(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction getEndOfCodeInLine(anchor) {\n  const lastNode = getLastCodeNodeOfLine(anchor);\n  if (!!$isLineBreakNode(lastNode)) {\n    throw Error(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace($createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ($isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = $getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = $getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction $getHighlightNodes(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push($createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push($createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$getHighlightNodes([content], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$getHighlightNodes(content, token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = $getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = $getSelection();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && $isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = $isTextNode(_node);\n    if (isText || $isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || $isTabNode(nodeA) && $isTabNode(nodeB) || $isLineBreakNode(nodeA) && $isLineBreakNode(nodeB);\n}\nfunction $isSelectionInCode(selection) {\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const focusNode = selection.focus.getNode();\n  if (anchorNode.is(focusNode) && $isCodeNode(anchorNode)) {\n    return true;\n  }\n  const anchorParent = anchorNode.getParent();\n  return $isCodeNode(anchorParent) && anchorParent.is(focusNode.getParent());\n}\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [[]];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = lines[0];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n      throw Error(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ($isLineBreakNode(node)) {\n      if (i !== 0 && lastLine.length > 0) {\n        lastLine = [];\n        lines.push(lastLine);\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? INDENT_CONTENT_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? INSERT_TAB_COMMAND : OUTDENT_CONTENT_COMMAND;\n  // 1. If multiple lines selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length > 1) {\n    return indentOrOutdent;\n  }\n  // 2. If entire line selected: indent/outdent\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || $isTabNode(firstNode) || $isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or TabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    return indentOrOutdent;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  const lastOfLine = getLastCodeNodeOfLine(firstNode);\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let selectionFirst;\n  let selectionLast;\n  if (focus.isBefore(anchor)) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n  if (firstOfLine !== null && lastOfLine !== null && selectionFirst.key === firstOfLine.getKey() && selectionFirst.offset === 0 && selectionLast.key === lastOfLine.getKey() && selectionLast.offset === lastOfLine.getTextContentSize()) {\n    return indentOrOutdent;\n  }\n  // 3. Else: tab/outdent\n  return tabOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n  // Multiple lines selection\n  if (codeLines.length > 1) {\n    for (let i = 0; i < codeLinesLength; i++) {\n      const line = codeLines[i];\n      if (line.length > 0) {\n        let firstOfLine = line[0];\n        // First and last lines might not be complete\n        if (i === 0) {\n          firstOfLine = getFirstCodeNodeOfLine(firstOfLine);\n        }\n        if (firstOfLine !== null) {\n          if (type === INDENT_CONTENT_COMMAND) {\n            firstOfLine.insertBefore($createTabNode());\n          } else if ($isTabNode(firstOfLine)) {\n            firstOfLine.remove();\n          }\n        }\n      }\n    }\n    return true;\n  }\n  // Just one line\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || $isTabNode(firstNode) || $isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or CodeTabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    // CodeNode is empty\n    if (type === INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([$createTabNode()]);\n    }\n    return true;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  if (!(firstOfLine !== null)) {\n    throw Error(`Expected getFirstCodeNodeOfLine to return a valid Code Node`);\n  }\n  if (type === INDENT_CONTENT_COMMAND) {\n    if ($isLineBreakNode(firstOfLine)) {\n      firstOfLine.insertAfter($createTabNode());\n    } else {\n      firstOfLine.insertBefore($createTabNode());\n    }\n  } else if ($isTabNode(firstOfLine)) {\n    firstOfLine.remove();\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = getFirstCodeNodeOfLine(anchorNode);\n    end = getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = getFirstCodeNodeOfLine(focusNode);\n    end = getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !$isTabNode(node) && !$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || $isTabNode(sibling) || $isLineBreakNode(sibling) ? arrowIsUp ? getFirstCodeNodeOfLine(sibling) : getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === MOVE_TO_START;\n  if (!($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (isMoveToStart) {\n    const start = getStartOfCodeInLine(focusNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ($isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  return mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = $getNodeByKey(key);\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }, {\n    skipInitialization: false\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(INDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(OUTDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, payload => $handleShiftLines(KEY_ARROW_UP_COMMAND, payload), COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, payload => $handleShiftLines(KEY_ARROW_DOWN_COMMAND, payload), COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_END, payload => $handleMoveTo(MOVE_TO_END, payload), COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_START, payload => $handleMoveTo(MOVE_TO_START, payload), COMMAND_PRIORITY_LOW));\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport { $createCodeHighlightNode, $createCodeNode, $isCodeHighlightNode, $isCodeNode, CODE_LANGUAGE_FRIENDLY_NAME_MAP, CODE_LANGUAGE_MAP, CodeHighlightNode, CodeNode, DEFAULT_CODE_LANGUAGE, PrismTokenizer, getCodeLanguages, getDefaultCodeLanguage, getEndOfCodeInLine, getFirstCodeNodeOfLine, getLanguageFriendlyName, getLastCodeNodeOfLine, getStartOfCodeInLine, normalizeCodeLang, registerCodeHighlighting };","map":{"version":3,"names":["isHTMLElement","addClassNamesToElement","removeClassNamesFromElement","mergeRegister","ElementNode","$createParagraphNode","$isTextNode","$isTabNode","$createTabNode","$createLineBreakNode","$applyNodeReplacement","TextNode","$isLineBreakNode","$createTextNode","$getNodeByKey","$getSelection","$isRangeSelection","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","INSERT_TAB_COMMAND","KEY_ARROW_UP_COMMAND","MOVE_TO_START","KEY_TAB_COMMAND","COMMAND_PRIORITY_LOW","$insertNodes","KEY_ARROW_DOWN_COMMAND","MOVE_TO_END","invariant","cond","message","Error","isLanguageSupportedByPrism","language","window","Prism","languages","hasOwnProperty","_unused","hasChildDOMNodeTag","node","tagName","child","childNodes","LANGUAGE_DATA_ATTRIBUTE","HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE","CodeNode","getType","clone","__language","__key","constructor","key","__isSyntaxHighlightSupported","createDOM","config","element","document","createElement","theme","code","setAttribute","getLanguage","getIsSyntaxHighlightSupported","updateDOM","prevNode","dom","prevLanguage","removeAttribute","exportDOM","editor","_config","importDOM","isMultiLine","textContent","test","conversion","$convertPreElement","priority","div","$convertDivElement","pre","table","isGitHubCodeTable","$convertTableElement","td","closest","isGitHubCodeCell","convertCodeNoop","tr","importJSON","serializedNode","$createCodeNode","setFormat","format","setIndent","indent","setDirection","direction","exportJSON","type","version","insertNewAfter","selection","restoreSelection","arguments","length","undefined","children","getChildren","childrenLength","getTextContent","isCollapsed","anchor","offset","remove","newElement","insertAfter","focus","firstPoint","isBefore","firstSelectionNode","getNode","getFirstCodeNodeOfLine","insertNodes","push","getNextSibling","$isCodeHighlightNode","spaces","text","textSize","getTextContentSize","$createCodeHighlightNode","repeat","split","splitText","x","index","getIndexWithinParent","codeNode","getParentOrThrow","nodesToInsert","splice","last","select","selectPrevious","selectNext","$isCodeNode","canIndent","collapseAtStart","paragraph","forEach","append","replace","setLanguage","writable","getWritable","getLatest","domNode","getAttribute","isCode","isCodeElement","isCodeChildElement","style","fontFamily","match","parent","parentElement","cell","classList","contains","DEFAULT_CODE_LANGUAGE","CODE_LANGUAGE_FRIENDLY_NAME_MAP","c","clike","cpp","css","html","java","js","markdown","objc","plain","powershell","py","rust","sql","swift","typescript","xml","CODE_LANGUAGE_MAP","javascript","md","plaintext","python","ts","normalizeCodeLang","lang","getLanguageFriendlyName","_lang","getDefaultCodeLanguage","getCodeLanguages","Object","keys","filter","sort","CodeHighlightNode","highlightType","__highlightType","__text","getHighlightType","self","canHaveFormat","className","getHighlightThemeClass","update","prevClassName","nextClassName","setDetail","detail","setMode","mode","setStyle","isParentRequired","createParentElementNode","codeHighlight","previousNode","getPreviousSibling","getLastCodeNodeOfLine","nextNode","PrismTokenizer","defaultLanguage","tokenize","getStartOfCodeInLine","lastNonBlank","nodeOffset","nodeTextContent","Math","max","character","codeCharacterAtAnchorOffset","nextSibling","nextNonBlank","findNextNonBlankInLine","nodeTextContentSize","getEndOfCodeInLine","lastNode","$textNodeTransform","tokenizer","parentNode","getParent","codeNodeTransform","updateCodeGutter","codeElement","getElementByKey","getKey","__cachedChildrenLength","gutter","count","i","nodesCurrentlyHighlighting","Set","nodeKey","has","add","$updateAndRetainSelection","currentNode","isAttached","tokens","highlightNodes","$getHighlightNodes","diffRange","getDiffRange","from","to","nodesForReplacement","onUpdate","delete","skipTransforms","nodes","token","partials","partialsLength","part","content","Array","isArray","updateFn","anchorOffset","isNewLineAnchor","getChildAtIndex","textOffset","anchorNode","getPreviousSiblings","reduce","_node","hasChanges","some","isText","textContentSize","prevNodes","nextNodes","leadingMatch","isEqual","prevNodesLength","nextNodesLength","maxTrailingMatch","min","trailingMatch","slice","nodeA","nodeB","$isSelectionInCode","focusNode","is","anchorParent","$getCodeLines","getNodes","lines","lastLine","$handleTab","shiftKey","indentOrOutdent","tabOrOutdent","codeLines","selectionNodes","firstNode","firstOfLine","lastOfLine","selectionFirst","selectionLast","$handleMultilineIndent","codeLinesLength","line","insertBefore","$handleShiftLines","event","focusOffset","arrowIsUp","altKey","codeNodeSibling","preventDefault","start","end","range","getNodesBetween","stopPropagation","linebreak","sibling","maybeInsertionPoint","insertionPoint","setTextNodeRange","$handleMoveTo","isMoveToStart","selectStart","registerCodeHighlighting","hasNodes","registerMutationListener","mutations","skipInitialization","registerNodeTransform","registerCommand","command","dispatchCommand","payload"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/code/LexicalCode.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport 'prismjs';\nimport 'prismjs/components/prism-clike.js';\nimport 'prismjs/components/prism-javascript.js';\nimport 'prismjs/components/prism-markup.js';\nimport 'prismjs/components/prism-markdown.js';\nimport 'prismjs/components/prism-c.js';\nimport 'prismjs/components/prism-css.js';\nimport 'prismjs/components/prism-objectivec.js';\nimport 'prismjs/components/prism-sql.js';\nimport 'prismjs/components/prism-powershell.js';\nimport 'prismjs/components/prism-python.js';\nimport 'prismjs/components/prism-rust.js';\nimport 'prismjs/components/prism-swift.js';\nimport 'prismjs/components/prism-typescript.js';\nimport 'prismjs/components/prism-java.js';\nimport 'prismjs/components/prism-cpp.js';\nimport { isHTMLElement, addClassNamesToElement, removeClassNamesFromElement, mergeRegister } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isTextNode, $isTabNode, $createTabNode, $createLineBreakNode, $applyNodeReplacement, TextNode, $isLineBreakNode, $createTextNode, $getNodeByKey, $getSelection, $isRangeSelection, INDENT_CONTENT_COMMAND, OUTDENT_CONTENT_COMMAND, INSERT_TAB_COMMAND, KEY_ARROW_UP_COMMAND, MOVE_TO_START, KEY_TAB_COMMAND, COMMAND_PRIORITY_LOW, $insertNodes, KEY_ARROW_DOWN_COMMAND, MOVE_TO_END } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// invariant(condition, message) will refine types based on \"condition\", and\n// if \"condition\" is false will throw an error. This function is special-cased\n// in flow itself, so we can't name it anything else.\nfunction invariant(cond, message, ...args) {\n  if (cond) {\n    return;\n  }\n  throw new Error('Internal Lexical error: invariant() is meant to be replaced at compile ' + 'time. There is no runtime version. Error: ' + message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst isLanguageSupportedByPrism = language => {\n  try {\n    // eslint-disable-next-line no-prototype-builtins\n    return language ? window.Prism.languages.hasOwnProperty(language) : false;\n  } catch (_unused) {\n    return false;\n  }\n};\nfunction hasChildDOMNodeTag(node, tagName) {\n  for (const child of node.childNodes) {\n    if (isHTMLElement(child) && child.tagName === tagName) {\n      return true;\n    }\n    hasChildDOMNodeTag(child, tagName);\n  }\n  return false;\n}\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-language';\nconst HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n\n/** @noInheritDoc */\nclass CodeNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = language;\n    this.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n\n  // View\n  createDOM(config) {\n    const element = document.createElement('code');\n    addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n        if (this.__isSyntaxHighlightSupported) {\n          dom.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n        }\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n      if (prevNode.__isSyntaxHighlightSupported) {\n        dom.removeAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE);\n      }\n    }\n    return false;\n  }\n  exportDOM(editor) {\n    const element = document.createElement('pre');\n    addClassNamesToElement(element, editor._config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      if (this.getIsSyntaxHighlightSupported()) {\n        element.setAttribute(HIGHLIGHT_LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise.\n      code: node => {\n        const isMultiLine = node.textContent != null && (/\\r?\\n/.test(node.textContent) || hasChildDOMNodeTag(node, 'BR'));\n        return isMultiLine ? {\n          conversion: $convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: () => ({\n        conversion: $convertDivElement,\n        priority: 1\n      }),\n      pre: () => ({\n        conversion: $convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node;\n        // domNode is a <table> since we matched it by nodeName\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: $convertTableElement,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td) || table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = $createParagraphNode();\n      this.insertAfter(newElement, restoreSelection);\n      return newElement;\n    }\n\n    // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n    const {\n      anchor,\n      focus\n    } = selection;\n    const firstPoint = anchor.isBefore(focus) ? anchor : focus;\n    const firstSelectionNode = firstPoint.getNode();\n    if ($isTextNode(firstSelectionNode)) {\n      let node = getFirstCodeNodeOfLine(firstSelectionNode);\n      const insertNodes = [];\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        if ($isTabNode(node)) {\n          insertNodes.push($createTabNode());\n          node = node.getNextSibling();\n        } else if ($isCodeHighlightNode(node)) {\n          let spaces = 0;\n          const text = node.getTextContent();\n          const textSize = node.getTextContentSize();\n          while (spaces < textSize && text[spaces] === ' ') {\n            spaces++;\n          }\n          if (spaces !== 0) {\n            insertNodes.push($createCodeHighlightNode(' '.repeat(spaces)));\n          }\n          if (spaces !== textSize) {\n            break;\n          }\n          node = node.getNextSibling();\n        } else {\n          break;\n        }\n      }\n      const split = firstSelectionNode.splitText(anchor.offset)[0];\n      const x = anchor.offset === 0 ? 0 : 1;\n      const index = split.getIndexWithinParent() + x;\n      const codeNode = firstSelectionNode.getParentOrThrow();\n      const nodesToInsert = [$createLineBreakNode(), ...insertNodes];\n      codeNode.splice(index, 0, nodesToInsert);\n      const last = insertNodes[insertNodes.length - 1];\n      if (last) {\n        last.select();\n      } else if (anchor.offset === 0) {\n        split.selectPrevious();\n      } else {\n        split.getNextSibling().selectNext(0, 0);\n      }\n    }\n    if ($isCodeNode(firstSelectionNode)) {\n      const {\n        offset\n      } = selection.anchor;\n      firstSelectionNode.splice(offset, 0, [$createLineBreakNode()]);\n      firstSelectionNode.select(offset + 1, offset + 1);\n    }\n    return null;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = language;\n    writable.__isSyntaxHighlightSupported = isLanguageSupportedByPrism(language);\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n  getIsSyntaxHighlightSupported() {\n    return this.getLatest().__isSyntaxHighlightSupported;\n  }\n}\nfunction $createCodeNode(language) {\n  return $applyNodeReplacement(new CodeNode(language));\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction $convertPreElement(domNode) {\n  const language = domNode.getAttribute(LANGUAGE_DATA_ATTRIBUTE);\n  return {\n    node: $createCodeNode(language)\n  };\n}\nfunction $convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  if (!isCode && !isCodeChildElement(div)) {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: isCode ? $createCodeNode() : null\n  };\n}\nfunction $convertTableElement() {\n  return {\n    node: $createCodeNode()\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isCodeChildElement(node) {\n  let parent = node.parentElement;\n  while (parent !== null) {\n    if (isCodeElement(parent)) {\n      return true;\n    }\n    parent = parent.parentElement;\n  }\n  return false;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  cpp: 'C++',\n  css: 'CSS',\n  html: 'HTML',\n  java: 'Java',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  powershell: 'PowerShell',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  typescript: 'TypeScript',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  cpp: 'cpp',\n  java: 'java',\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain',\n  ts: 'typescript'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(window.Prism.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof window.Prism.languages[language] !== 'function').sort();\n\n/** @noInheritDoc */\nclass CodeHighlightNode extends TextNode {\n  /** @internal */\n\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  canHaveFormat() {\n    return false;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  }\n\n  // Prevent formatting (bold, underline, etc)\n  setFormat(format) {\n    return this;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createCodeNode();\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text, highlightType) {\n  return $applyNodeReplacement(new CodeHighlightNode(text, highlightType));\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeNodeOfLine(anchor) {\n  let previousNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || $isTabNode(node)) {\n    previousNode = node;\n    node = node.getPreviousSibling();\n  }\n  return previousNode;\n}\nfunction getLastCodeNodeOfLine(anchor) {\n  let nextNode = anchor;\n  let node = anchor;\n  while ($isCodeHighlightNode(node) || $isTabNode(node)) {\n    nextNode = node;\n    node = node.getNextSibling();\n  }\n  return nextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PrismTokenizer = {\n  defaultLanguage: DEFAULT_CODE_LANGUAGE,\n  tokenize(code, language) {\n    return window.Prism.tokenize(code, window.Prism.languages[language || ''] || window.Prism.languages[this.defaultLanguage]);\n  }\n};\nfunction getStartOfCodeInLine(anchor, offset) {\n  let last = null;\n  let lastNonBlank = null;\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (nodeOffset === 0) {\n      node = node.getPreviousSibling();\n      if (node === null) {\n        break;\n      }\n      if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n        throw Error(`Expected a valid Code Node: CodeHighlightNode, TabNode, LineBreakNode`);\n      }\n      if ($isLineBreakNode(node)) {\n        last = {\n          node,\n          offset: 1\n        };\n        break;\n      }\n      nodeOffset = Math.max(0, node.getTextContentSize() - 1);\n      nodeTextContent = node.getTextContent();\n    } else {\n      nodeOffset--;\n    }\n    const character = nodeTextContent[nodeOffset];\n    if ($isCodeHighlightNode(node) && character !== ' ') {\n      lastNonBlank = {\n        node,\n        offset: nodeOffset\n      };\n    }\n  }\n  // lastNonBlank !== null: anchor in the middle of code; move to line beginning\n  if (lastNonBlank !== null) {\n    return lastNonBlank;\n  }\n  // Spaces, tabs or nothing ahead of anchor\n  let codeCharacterAtAnchorOffset = null;\n  if (offset < anchor.getTextContentSize()) {\n    if ($isCodeHighlightNode(anchor)) {\n      codeCharacterAtAnchorOffset = anchor.getTextContent()[offset];\n    }\n  } else {\n    const nextSibling = anchor.getNextSibling();\n    if ($isCodeHighlightNode(nextSibling)) {\n      codeCharacterAtAnchorOffset = nextSibling.getTextContent()[0];\n    }\n  }\n  if (codeCharacterAtAnchorOffset !== null && codeCharacterAtAnchorOffset !== ' ') {\n    // Borderline whitespace and code, move to line beginning\n    return last;\n  } else {\n    const nextNonBlank = findNextNonBlankInLine(anchor, offset);\n    if (nextNonBlank !== null) {\n      return nextNonBlank;\n    } else {\n      return last;\n    }\n  }\n}\nfunction findNextNonBlankInLine(anchor, offset) {\n  let node = anchor;\n  let nodeOffset = offset;\n  let nodeTextContent = anchor.getTextContent();\n  let nodeTextContentSize = anchor.getTextContentSize();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (!$isCodeHighlightNode(node) || nodeOffset === nodeTextContentSize) {\n      node = node.getNextSibling();\n      if (node === null || $isLineBreakNode(node)) {\n        return null;\n      }\n      if ($isCodeHighlightNode(node)) {\n        nodeOffset = 0;\n        nodeTextContent = node.getTextContent();\n        nodeTextContentSize = node.getTextContentSize();\n      }\n    }\n    if ($isCodeHighlightNode(node)) {\n      if (nodeTextContent[nodeOffset] !== ' ') {\n        return {\n          node,\n          offset: nodeOffset\n        };\n      }\n      nodeOffset++;\n    }\n  }\n}\nfunction getEndOfCodeInLine(anchor) {\n  const lastNode = getLastCodeNodeOfLine(anchor);\n  if (!!$isLineBreakNode(lastNode)) {\n    throw Error(`Unexpected lineBreakNode in getEndOfCodeInLine`);\n  }\n  return lastNode;\n}\nfunction $textNodeTransform(node, editor, tokenizer) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor, tokenizer);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace($createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  // @ts-ignore: internal field\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  }\n  // @ts-ignore:: internal field\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if ($isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n}\n\n// Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra cache (`nodesCurrentlyHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nconst nodesCurrentlyHighlighting = new Set();\nfunction codeNodeTransform(node, editor, tokenizer) {\n  const nodeKey = node.getKey();\n  if (nodesCurrentlyHighlighting.has(nodeKey)) {\n    return;\n  }\n  nodesCurrentlyHighlighting.add(nodeKey);\n\n  // When new code block inserted it might not have language selected\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(tokenizer.defaultLanguage);\n  }\n\n  // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n  editor.update(() => {\n    $updateAndRetainSelection(nodeKey, () => {\n      const currentNode = $getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const code = currentNode.getTextContent();\n      const tokens = tokenizer.tokenize(code, currentNode.getLanguage() || tokenizer.defaultLanguage);\n      const highlightNodes = $getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      nodesCurrentlyHighlighting.delete(nodeKey);\n    },\n    skipTransforms: true\n  });\n}\nfunction $getHighlightNodes(tokens, type) {\n  const nodes = [];\n  for (const token of tokens) {\n    if (typeof token === 'string') {\n      const partials = token.split(/(\\n|\\t)/);\n      const partialsLength = partials.length;\n      for (let i = 0; i < partialsLength; i++) {\n        const part = partials[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          nodes.push($createLineBreakNode());\n        } else if (part === '\\t') {\n          nodes.push($createTabNode());\n        } else if (part.length > 0) {\n          nodes.push($createCodeHighlightNode(part, type));\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push(...$getHighlightNodes([content], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...$getHighlightNodes(content, token.type));\n      }\n    }\n  }\n  return nodes;\n}\n\n// Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\nfunction $updateAndRetainSelection(nodeKey, updateFn) {\n  const node = $getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = $getSelection();\n  // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n  if (!$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && $isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0;\n\n  // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + _node.getTextContentSize();\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  }\n\n  // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  }\n\n  // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n  node.getChildren().some(_node => {\n    const isText = $isTextNode(_node);\n    if (isText || $isLineBreakNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (isText && textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n}\n\n// Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes, tabs and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  return $isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB) && nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType || $isTabNode(nodeA) && $isTabNode(nodeB) || $isLineBreakNode(nodeA) && $isLineBreakNode(nodeB);\n}\nfunction $isSelectionInCode(selection) {\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const anchorNode = selection.anchor.getNode();\n  const focusNode = selection.focus.getNode();\n  if (anchorNode.is(focusNode) && $isCodeNode(anchorNode)) {\n    return true;\n  }\n  const anchorParent = anchorNode.getParent();\n  return $isCodeNode(anchorParent) && anchorParent.is(focusNode.getParent());\n}\nfunction $getCodeLines(selection) {\n  const nodes = selection.getNodes();\n  const lines = [[]];\n  if (nodes.length === 1 && $isCodeNode(nodes[0])) {\n    return lines;\n  }\n  let lastLine = lines[0];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!($isCodeHighlightNode(node) || $isTabNode(node) || $isLineBreakNode(node))) {\n      throw Error(`Expected selection to be inside CodeBlock and consisting of CodeHighlightNode, TabNode and LineBreakNode`);\n    }\n    if ($isLineBreakNode(node)) {\n      if (i !== 0 && lastLine.length > 0) {\n        lastLine = [];\n        lines.push(lastLine);\n      }\n    } else {\n      lastLine.push(node);\n    }\n  }\n  return lines;\n}\nfunction $handleTab(shiftKey) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return null;\n  }\n  const indentOrOutdent = !shiftKey ? INDENT_CONTENT_COMMAND : OUTDENT_CONTENT_COMMAND;\n  const tabOrOutdent = !shiftKey ? INSERT_TAB_COMMAND : OUTDENT_CONTENT_COMMAND;\n  // 1. If multiple lines selected: indent/outdent\n  const codeLines = $getCodeLines(selection);\n  if (codeLines.length > 1) {\n    return indentOrOutdent;\n  }\n  // 2. If entire line selected: indent/outdent\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || $isTabNode(firstNode) || $isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or TabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    return indentOrOutdent;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  const lastOfLine = getLastCodeNodeOfLine(firstNode);\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  let selectionFirst;\n  let selectionLast;\n  if (focus.isBefore(anchor)) {\n    selectionFirst = focus;\n    selectionLast = anchor;\n  } else {\n    selectionFirst = anchor;\n    selectionLast = focus;\n  }\n  if (firstOfLine !== null && lastOfLine !== null && selectionFirst.key === firstOfLine.getKey() && selectionFirst.offset === 0 && selectionLast.key === lastOfLine.getKey() && selectionLast.offset === lastOfLine.getTextContentSize()) {\n    return indentOrOutdent;\n  }\n  // 3. Else: tab/outdent\n  return tabOrOutdent;\n}\nfunction $handleMultilineIndent(type) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isSelectionInCode(selection)) {\n    return false;\n  }\n  const codeLines = $getCodeLines(selection);\n  const codeLinesLength = codeLines.length;\n  // Multiple lines selection\n  if (codeLines.length > 1) {\n    for (let i = 0; i < codeLinesLength; i++) {\n      const line = codeLines[i];\n      if (line.length > 0) {\n        let firstOfLine = line[0];\n        // First and last lines might not be complete\n        if (i === 0) {\n          firstOfLine = getFirstCodeNodeOfLine(firstOfLine);\n        }\n        if (firstOfLine !== null) {\n          if (type === INDENT_CONTENT_COMMAND) {\n            firstOfLine.insertBefore($createTabNode());\n          } else if ($isTabNode(firstOfLine)) {\n            firstOfLine.remove();\n          }\n        }\n      }\n    }\n    return true;\n  }\n  // Just one line\n  const selectionNodes = selection.getNodes();\n  const firstNode = selectionNodes[0];\n  if (!($isCodeNode(firstNode) || $isCodeHighlightNode(firstNode) || $isTabNode(firstNode) || $isLineBreakNode(firstNode))) {\n    throw Error(`Expected selection firstNode to be CodeHighlightNode or CodeTabNode`);\n  }\n  if ($isCodeNode(firstNode)) {\n    // CodeNode is empty\n    if (type === INDENT_CONTENT_COMMAND) {\n      selection.insertNodes([$createTabNode()]);\n    }\n    return true;\n  }\n  const firstOfLine = getFirstCodeNodeOfLine(firstNode);\n  if (!(firstOfLine !== null)) {\n    throw Error(`Expected getFirstCodeNodeOfLine to return a valid Code Node`);\n  }\n  if (type === INDENT_CONTENT_COMMAND) {\n    if ($isLineBreakNode(firstOfLine)) {\n      firstOfLine.insertAfter($createTabNode());\n    } else {\n      firstOfLine.insertBefore($createTabNode());\n    }\n  } else if ($isTabNode(firstOfLine)) {\n    firstOfLine.remove();\n  }\n  return true;\n}\nfunction $handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n\n  // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === KEY_ARROW_UP_COMMAND;\n\n  // Ensure the selection is within the codeblock\n  if (!$isSelectionInCode(selection) || !($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  let start;\n  let end;\n  if (anchorNode.isBefore(focusNode)) {\n    start = getFirstCodeNodeOfLine(anchorNode);\n    end = getLastCodeNodeOfLine(focusNode);\n  } else {\n    start = getFirstCodeNodeOfLine(focusNode);\n    end = getLastCodeNodeOfLine(anchorNode);\n  }\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !$isTabNode(node) && !$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = $isCodeHighlightNode(sibling) || $isTabNode(sibling) || $isLineBreakNode(sibling) ? arrowIsUp ? getFirstCodeNodeOfLine(sibling) : getLastCodeNodeOfLine(sibling) : null;\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction $handleMoveTo(type, event) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === MOVE_TO_START;\n  if (!($isCodeHighlightNode(anchorNode) || $isTabNode(anchorNode)) || !($isCodeHighlightNode(focusNode) || $isTabNode(focusNode))) {\n    return false;\n  }\n  if (isMoveToStart) {\n    const start = getStartOfCodeInLine(focusNode, focus.offset);\n    if (start !== null) {\n      const {\n        node,\n        offset\n      } = start;\n      if ($isLineBreakNode(node)) {\n        node.selectNext(0, 0);\n      } else {\n        selection.setTextNodeRange(node, offset, node, offset);\n      }\n    } else {\n      focusNode.getParentOrThrow().selectStart();\n    }\n  } else {\n    const node = getEndOfCodeInLine(focusNode);\n    node.select();\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor, tokenizer) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  if (tokenizer == null) {\n    tokenizer = PrismTokenizer;\n  }\n  return mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = $getNodeByKey(key);\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }, {\n    skipInitialization: false\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(TextNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerNodeTransform(CodeHighlightNode, node => $textNodeTransform(node, editor, tokenizer)), editor.registerCommand(KEY_TAB_COMMAND, event => {\n    const command = $handleTab(event.shiftKey);\n    if (command === null) {\n      return false;\n    }\n    event.preventDefault();\n    editor.dispatchCommand(command, undefined);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_TAB_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isSelectionInCode(selection)) {\n      return false;\n    }\n    $insertNodes([$createTabNode()]);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(INDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(OUTDENT_CONTENT_COMMAND, payload => $handleMultilineIndent(OUTDENT_CONTENT_COMMAND), COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_UP_COMMAND, payload => $handleShiftLines(KEY_ARROW_UP_COMMAND, payload), COMMAND_PRIORITY_LOW), editor.registerCommand(KEY_ARROW_DOWN_COMMAND, payload => $handleShiftLines(KEY_ARROW_DOWN_COMMAND, payload), COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_END, payload => $handleMoveTo(MOVE_TO_END, payload), COMMAND_PRIORITY_LOW), editor.registerCommand(MOVE_TO_START, payload => $handleMoveTo(MOVE_TO_START, payload), COMMAND_PRIORITY_LOW));\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport { $createCodeHighlightNode, $createCodeNode, $isCodeHighlightNode, $isCodeNode, CODE_LANGUAGE_FRIENDLY_NAME_MAP, CODE_LANGUAGE_MAP, CodeHighlightNode, CodeNode, DEFAULT_CODE_LANGUAGE, PrismTokenizer, getCodeLanguages, getDefaultCodeLanguage, getEndOfCodeInLine, getFirstCodeNodeOfLine, getLanguageFriendlyName, getLastCodeNodeOfLine, getStartOfCodeInLine, normalizeCodeLang, registerCodeHighlighting };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}