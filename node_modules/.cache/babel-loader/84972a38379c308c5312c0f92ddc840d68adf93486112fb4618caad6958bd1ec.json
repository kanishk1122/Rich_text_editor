{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $isElementNode, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor) {\n  let selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor) {\n  let selection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode) {\n  let targetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection() {\n  let selection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $getSelection();\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };","map":{"version":3,"names":["$generateHtmlFromNodes","$generateNodesFromDOM","$addNodeStyle","$sliceSelectedTextNodeContent","objectKlassEquals","$isRangeSelection","$getSelection","$createTabNode","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","$getRoot","$parseSerializedNode","$isTextNode","COPY_COMMAND","COMMAND_PRIORITY_CRITICAL","isSelectionWithinEditor","$getEditor","$isElementNode","$cloneWithProperties","CAN_USE_DOM","window","document","createElement","getDOMSelection","targetWindow","getSelection","$getHtmlContent","editor","selection","arguments","length","undefined","Error","isCollapsed","getNodes","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","_unused","htmlString","parser","DOMParser","dom","parseFromString","_unused2","parts","split","pop","i","currentSelection","part","insertParagraph","insertNodes","insertText","dispatchCommand","exportNodeToJSON","node","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","currentNode","targetArray","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","getChildren","__text","childNode","shouldIncludeChild","extractWithChild","push","serializedChildNode","root","topLevelChildren","topLevelNode","serializedNodes","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard","event","data","Promise","resolve","reject","update","$copyToClipboardEvent","rootElement","getRootElement","windowDocument","_window","domSelection","element","style","cssText","append","createTextNode","range","Range","setStart","setEnd","removeAllRanges","addRange","removeListener","registerCommand","secondEvent","ClipboardEvent","clearTimeout","setTimeout","execCommand","remove","anchorDOM","anchorNode","focusDOM","focusNode","$getClipboardDataFromSelection","preventDefault","clipboardData","setLexicalClipboardDataTransfer","clipboardDataFunctions","getTextContent","mimeType","$editorFn","v","k","setData"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $isElementNode, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}