{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isParagraphNode, $isTextNode, TextNode, $createTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing) {\n  let trim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        throw Error(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };","map":{"version":3,"names":["$getRoot","$isDecoratorNode","$isElementNode","$isParagraphNode","$isTextNode","TextNode","$createTextNode","$rootTextContent","root","getTextContent","$isRootTextContentEmpty","isEditorComposing","trim","arguments","length","undefined","text","$isRootTextContentEmptyCurry","$canShowPlaceholder","isComposing","children","getChildren","childrenLength","i","topBlock","__indent","topBlockChildren","topBlockChildrenLength","s","child","$canShowPlaceholderCurry","$findTextIntersectionFromCharacters","targetCharacters","node","getFirstChild","currentCharacters","mainLoop","characters","getTextContentSize","offset","sibling","getNextSibling","parent","getParent","parentSibling","registerLexicalTextEntity","editor","getMatch","targetNode","createNode","isTargetNode","$replaceWithSimpleText","textNode","setFormat","getFormat","replace","getMode","getLatest","__mode","$textNodeTransform","isSimpleText","prevSibling","getPreviousSibling","currentNode","match","previousText","combinedText","prevMatch","diff","end","concatText","slice","newTextContent","select","setTextContent","remove","remainingText","start","prevMatchLengthToSkip","nextText","nextSibling","nextMatch","markDirty","isTextEntity","nodeToReplace","splitText","Error","replacementNode","$reverseNodeTransform","removePlainTextTransform","registerNodeTransform","removeReverseNodeTransform"],"sources":["/media/ks/My thing/test/textditor_Using_lixical/node_modules/@lexical/text/LexicalText.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getRoot, $isDecoratorNode, $isElementNode, $isParagraphNode, $isTextNode, TextNode, $createTextNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        throw Error(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}