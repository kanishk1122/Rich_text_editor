{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar clipboard = require('@lexical/clipboard');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n// export const IS_CHROME: boolean = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\n/** @module @lexical/rich-text */\n\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  } // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'quote'\n    };\n  } // Mutation\n\n  insertNewAfter() {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return new QuoteNode();\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  } // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  } // Mutation\n\n  insertNewAfter() {\n    const newElement = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement);\n    return newElement;\n  }\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction convertHeadingElement(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n  }\n  return {\n    node\n  };\n}\nfunction convertBlockquoteElement() {\n  const node = $createQuoteNode();\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag) {\n  return new HeadingNode(headingTag);\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nfunction onCopyForRichText(event, editor) {\n  const selection = lexical.$getSelection();\n  if (selection !== null) {\n    event.preventDefault();\n    const clipboardData = event instanceof KeyboardEvent ? null : event.clipboardData;\n    const htmlString = clipboard.$getHtmlContent(editor);\n    const lexicalString = clipboard.$getLexicalContent(editor);\n    if (clipboardData != null) {\n      if (htmlString !== null) {\n        clipboardData.setData('text/html', htmlString);\n      }\n      if (lexicalString !== null) {\n        clipboardData.setData('application/x-lexical-editor', lexicalString);\n      }\n      const plainString = selection.getTextContent();\n      clipboardData.setData('text/plain', plainString);\n    } else {\n      const clipboard = navigator.clipboard;\n      if (clipboard != null) {\n        // Most browsers only support a single item in the clipboard at one time.\n        // So we optimize by only putting in HTML.\n        const data = [new ClipboardItem({\n          'text/html': new Blob([htmlString], {\n            type: 'text/html'\n          })\n        })];\n        clipboard.write(data);\n      }\n    }\n  }\n}\nfunction onCutForRichText(event, editor) {\n  onCopyForRichText(event, editor);\n  const selection = lexical.$getSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    selection.removeText();\n  } else if (lexical.$isNodeSelection(selection)) {\n    selection.getNodes().forEach(node => node.remove());\n  }\n}\nfunction handleIndentAndOutdent(insertTab, indentOrOutdent) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    alreadyHandled.add(key);\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n    if (parentBlock.canInsertTab()) {\n      insertTab(node);\n    } else if (parentBlock.canIndent()) {\n      indentOrOutdent(parentBlock);\n    }\n  }\n}\nfunction isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(node);\n      element.setFormat(format);\n    }\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    handleIndentAndOutdent(() => {\n      editor.dispatchCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, '\\t');\n    }, block => {\n      const indent = block.getIndent();\n      if (indent !== 10) {\n        block.setIndent(indent + 1);\n      }\n    });\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    handleIndentAndOutdent(node => {\n      if (lexical.$isTextNode(node)) {\n        const textContent = node.getTextContent();\n        const character = textContent[textContent.length - 1];\n        if (character === '\\t') {\n          editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n        }\n      }\n    }, block => {\n      const indent = block.getIndent();\n      if (indent !== 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection) && !isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n    if (lexical.$isNodeSelection(selection$1) && !isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if (isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if (isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(event.shiftKey ? lexical.OUTDENT_CONTENT_COMMAND : lexical.INDENT_CONTENT_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    onCopyForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.registerRichText = registerRichText;","map":{"version":3,"names":["clipboard","require","selection","utils","lexical","CAN_USE_DOM","window","document","createElement","documentMode","test","navigator","platform","userAgent","CAN_USE_BEFORE_INPUT","InputEvent","IS_SAFARI","IS_IOS","MSStream","QuoteNode","ElementNode","getType","clone","node","__key","constructor","key","createDOM","config","element","addClassNamesToElement","theme","quote","updateDOM","prevNode","dom","importDOM","blockquote","conversion","convertBlockquoteElement","priority","importJSON","serializedNode","$createQuoteNode","setFormat","format","setIndent","indent","setDirection","direction","exportJSON","type","insertNewAfter","newBlock","$createParagraphNode","getDirection","insertAfter","collapseAtStart","paragraph","children","getChildren","forEach","child","append","replace","$isQuoteNode","HeadingNode","__tag","tag","getTag","classNames","heading","undefined","className","h1","convertHeadingElement","h2","h3","h4","h5","h6","p","firstChild","isGoogleDocsTitle","span","domNode","$createHeadingNode","version","newElement","extractWithChild","nodeName","toLowerCase","style","fontSize","headingTag","$isHeadingNode","onPasteForRichText","event","editor","preventDefault","update","$getSelection","clipboardData","KeyboardEvent","$isRangeSelection","DEPRECATED_$isGridSelection","$insertDataTransferForRichText","onCopyForRichText","htmlString","$getHtmlContent","lexicalString","$getLexicalContent","setData","plainString","getTextContent","data","ClipboardItem","Blob","write","onCutForRichText","removeText","$isNodeSelection","getNodes","remove","handleIndentAndOutdent","insertTab","indentOrOutdent","alreadyHandled","Set","nodes","i","length","getKey","has","add","parentBlock","$getNearestBlockElementAncestorOrThrow","canInsertTab","canIndent","isTargetWithinDecorator","target","$getNearestNodeFromDOMNode","$isDecoratorNode","registerRichText","removeListener","mergeRegister","registerCommand","CLICK_COMMAND","payload","clear","DELETE_CHARACTER_COMMAND","isBackward","deleteCharacter","COMMAND_PRIORITY_EDITOR","DELETE_WORD_COMMAND","deleteWord","DELETE_LINE_COMMAND","deleteLine","CONTROLLED_TEXT_INSERTION_COMMAND","eventOrText","insertText","dataTransfer","REMOVE_TEXT_COMMAND","FORMAT_TEXT_COMMAND","formatText","FORMAT_ELEMENT_COMMAND","INSERT_LINE_BREAK_COMMAND","selectStart","insertLineBreak","INSERT_PARAGRAPH_COMMAND","insertParagraph","INDENT_CONTENT_COMMAND","dispatchCommand","block","getIndent","OUTDENT_CONTENT_COMMAND","$isTextNode","textContent","character","KEY_ARROW_UP_COMMAND","selectPrevious","KEY_ARROW_DOWN_COMMAND","selectNext","KEY_ARROW_LEFT_COMMAND","selection$1","$shouldOverrideDefaultCharacterSelection","isHoldingShift","shiftKey","$moveCharacter","KEY_ARROW_RIGHT_COMMAND","KEY_BACKSPACE_COMMAND","anchor","anchorNode","getNode","isCollapsed","offset","$isRootNode","KEY_DELETE_COMMAND","KEY_ENTER_COMMAND","KEY_TAB_COMMAND","KEY_ESCAPE_COMMAND","blur","DROP_COMMAND","DRAGSTART_COMMAND","COPY_COMMAND","CUT_COMMAND","PASTE_COMMAND","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/rich-text/LexicalRichText.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar clipboard = require('@lexical/clipboard');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n// export const IS_CHROME: boolean = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\n/** @module @lexical/rich-text */\n\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'quote'\n    };\n  } // Mutation\n\n\n  insertNewAfter() {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock);\n    return newBlock;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n}\nfunction $createQuoteNode() {\n  return new QuoteNode();\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'heading';\n  }\n\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n\n  getTag() {\n    return this.__tag;\n  } // View\n\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter() {\n    const newElement = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n  extractWithChild() {\n    return true;\n  }\n\n}\n\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n\n  return false;\n}\n\nfunction convertHeadingElement(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction convertBlockquoteElement() {\n  const node = $createQuoteNode();\n  return {\n    node\n  };\n}\n\nfunction $createHeadingNode(headingTag) {\n  return new HeadingNode(headingTag);\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\n\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\n\nfunction onCopyForRichText(event, editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection !== null) {\n    event.preventDefault();\n    const clipboardData = event instanceof KeyboardEvent ? null : event.clipboardData;\n    const htmlString = clipboard.$getHtmlContent(editor);\n    const lexicalString = clipboard.$getLexicalContent(editor);\n\n    if (clipboardData != null) {\n      if (htmlString !== null) {\n        clipboardData.setData('text/html', htmlString);\n      }\n\n      if (lexicalString !== null) {\n        clipboardData.setData('application/x-lexical-editor', lexicalString);\n      }\n\n      const plainString = selection.getTextContent();\n      clipboardData.setData('text/plain', plainString);\n    } else {\n      const clipboard = navigator.clipboard;\n\n      if (clipboard != null) {\n        // Most browsers only support a single item in the clipboard at one time.\n        // So we optimize by only putting in HTML.\n        const data = [new ClipboardItem({\n          'text/html': new Blob([htmlString], {\n            type: 'text/html'\n          })\n        })];\n        clipboard.write(data);\n      }\n    }\n  }\n}\n\nfunction onCutForRichText(event, editor) {\n  onCopyForRichText(event, editor);\n  const selection = lexical.$getSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.removeText();\n  } else if (lexical.$isNodeSelection(selection)) {\n    selection.getNodes().forEach(node => node.remove());\n  }\n}\n\nfunction handleIndentAndOutdent(insertTab, indentOrOutdent) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n\n    alreadyHandled.add(key);\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n\n    if (parentBlock.canInsertTab()) {\n      insertTab(node);\n    } else if (parentBlock.canIndent()) {\n      indentOrOutdent(parentBlock);\n    }\n  }\n}\n\nfunction isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\n\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const nodes = selection.getNodes();\n\n    for (const node of nodes) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(node);\n      element.setFormat(format);\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    handleIndentAndOutdent(() => {\n      editor.dispatchCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, '\\t');\n    }, block => {\n      const indent = block.getIndent();\n\n      if (indent !== 10) {\n        block.setIndent(indent + 1);\n      }\n    });\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    handleIndentAndOutdent(node => {\n      if (lexical.$isTextNode(node)) {\n        const textContent = node.getTextContent();\n        const character = textContent[textContent.length - 1];\n\n        if (character === '\\t') {\n          editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n        }\n      }\n    }, block => {\n      const indent = block.getIndent();\n\n      if (indent !== 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection) && !isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1) && !isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if (isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if (isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n\n      event.preventDefault();\n\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(event.shiftKey ? lexical.OUTDENT_CONTENT_COMMAND : lexical.INDENT_CONTENT_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    onCopyForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.registerRichText = registerRichText;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}