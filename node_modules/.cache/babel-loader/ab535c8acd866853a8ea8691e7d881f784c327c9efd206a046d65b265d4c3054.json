{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isElementNode, $isLineBreakNode, $isTextNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $createPoint, $normalizeSelection__EXPERIMENTAL, $getNodeByKey, isCurrentlyReadOnlyMode, $setSelection, SELECTION_CHANGE_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $getRoot, KEY_ARROW_DOWN_COMMAND, COMMAND_PRIORITY_HIGH, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ESCAPE_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, COMMAND_PRIORITY_CRITICAL, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $createRangeSelectionFromDom, INSERT_PARAGRAPH_COMMAND, $isRootOrShadowRoot, $isDecoratorNode } from 'lexical';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n  constructor() {\n    let headerState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TableCellHeaderStates.NO_STATUS;\n    let colSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let width = arguments.length > 2 ? arguments[2] : undefined;\n    let key = arguments.length > 3 ? arguments[3] : undefined;\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.__colSpan;\n  }\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = style.textDecoration.split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState) {\n  let colSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let width = arguments.length > 2 ? arguments[2] : undefined;\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {\n        height: this.getHeight()\n      }),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount) {\n  let includeHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex) {\n  let shouldInsertAfter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let rowCount = arguments.length > 3 ? arguments[3] : undefined;\n  let table = arguments.length > 4 ? arguments[4] : undefined;\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\nfunction $insertTableRow__EXPERIMENTAL() {\n  let insertAfter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!$isTableRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!$isTableRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex) {\n  let shouldInsertAfter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let columnCount = arguments.length > 3 ? arguments[3] : undefined;\n  let table = arguments.length > 4 ? arguments[4] : undefined;\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(_ref => {\n    let {\n      newTableCell,\n      targetCell\n    } = _ref;\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL() {\n  let insertAfter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn() {\n    let headerState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TableCellHeaderStates.NO_STATUS;\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    const [map, cellMap] = $computeTableMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(grid, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(grid, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n    if (cellA !== null && cellA.is(cell)) {\n      cellAValue = value;\n    }\n    if (cellB !== null && cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n  const gridChildren = grid.getChildren();\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected GridNode children to be TableRowNode`);\n    }\n    const rowChildren = row.getChildren();\n    let j = 0;\n    for (const cell of rowChildren) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      }\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent GridNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!$isTableCellNode(anchorCellNode)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!$isTableCellNode(focusCellNode)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = $findMatchingParent(focusNode, $isTableCellNode);\n    if (!$isTableCellNode(anchorCell)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    if (!$isTableCellNode(focusCell)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!$isTableRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\n    }\n    const tableNode = anchorRow.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected tableNode to have a parent TableNode`);\n    }\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n    const nodes = [tableNode];\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableTableSelection(selection) {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n  setFocusCellForSelection(cell) {\n    let ignoreStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode) && tableNode.is($findTableNode(focusTableCellNode))) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          $setSelection(this.tableSelection);\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = $createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      $setSelection(selection);\n      this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = $getRoot();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if ($isElementNode(cellNode)) {\n          const paragraphNode = $createParagraphNode();\n          const textNode = $createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.table, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      // delaying mousemove handler to allow selectionchange handler from LexicalEvents.ts to be executed first\n      setTimeout(() => {\n        if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n          tableObserver.isSelecting = false;\n          editorWindow.removeEventListener('mouseup', onMouseUp);\n          editorWindow.removeEventListener('mousemove', onMouseMove);\n          return;\n        }\n        const focusCell = getDOMCellFromTarget(moveEvent.target);\n        if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableObserver.setFocusCellForSelection(focusCell);\n        }\n      }, 0);\n    };\n    return {\n      onMouseMove: onMouseMove,\n      onMouseUp: onMouseUp\n    };\n  };\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getDOMCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n      const {\n        onMouseUp,\n        onMouseMove\n      } = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      const target = event.target;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableObserver.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  });\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      const nodes = selection ? selection.getNodes() : null;\n      if (nodes) {\n        const table = nodes.find(node => $isTableNode(node) && node.getKey() === tableObserver.tableNodeKey);\n        if ($isTableNode(table)) {\n          const parentNode = table.getParent();\n          if (!parentNode) {\n            return false;\n          }\n          table.remove();\n        }\n      }\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  };\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_BACKSPACE_COMMAND, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_DELETE_COMMAND, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n    const maxColumn = Math.max(anchorCell.startColumn, focusCell.startColumn);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  function getObserverCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = $findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && $findMatchingParent(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && $findMatchingParent(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\n          if (!tableObserver.isSelecting) {\n            setTimeout(() => {\n              const {\n                onMouseUp,\n                onMouseMove\n              } = createMouseHandlers();\n              tableObserver.isSelecting = true;\n              editorWindow.addEventListener('mouseup', onMouseUp);\n              editorWindow.addEventListener('mousemove', onMouseMove);\n            }, 0);\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.is($findTableNode(focusNode));\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.is($findTableNode(anchorNode));\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableElement) {\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (selection.isCollapsed() && direction === 'backward') {\n        const anchorType = selection.anchor.type;\n        const anchorOffset = selection.anchor.offset;\n        if (anchorType !== 'element' && !(anchorType === 'text' && anchorOffset === 0)) {\n          return false;\n        }\n        const anchorNode = selection.anchor.getNode();\n        if (!anchorNode) {\n          return false;\n        }\n        const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!siblingNode || !$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        siblingNode.selectEnd();\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findMatchingParent(selectedNode, $isTableCellNode);\n            if (tableCellNode && tableNode.isParentOf(tableCellNode)) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.setAnchorCellForSelection(firstCellDOM);\n              tableObserver.setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          const focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && $isDecoratorNode(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, tableNode, direction) {\n  const anchorCellNode = $findMatchingParent(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  if (!tableNodeParentDOM) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== tableNodeParentDOM) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  static getType() {\n    return 'table';\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n  constructor(key) {\n    super(key);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n  updateDOM() {\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if (isHTMLElement(tableElement)) {\n            tBody.append(...tableElement.children);\n          }\n          const firstRow = this.getFirstChildOrThrow();\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n          const colCount = firstRow.getChildrenSize();\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) {\n          return;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTable(tableElement);\n}\nfunction $convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $deleteTableColumn, $deleteTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRow__EXPERIMENTAL, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableObserverFromTableElement };","map":{"version":3,"names":["addClassNamesToElement","$findMatchingParent","removeClassNamesFromElement","objectKlassEquals","isHTMLElement","ElementNode","$createParagraphNode","$isElementNode","$isLineBreakNode","$isTextNode","$applyNodeReplacement","createCommand","$createTextNode","$getSelection","$isRangeSelection","$createPoint","$normalizeSelection__EXPERIMENTAL","$getNodeByKey","isCurrentlyReadOnlyMode","$setSelection","SELECTION_CHANGE_COMMAND","$getNearestNodeFromDOMNode","$createRangeSelection","$getRoot","KEY_ARROW_DOWN_COMMAND","COMMAND_PRIORITY_HIGH","KEY_ARROW_UP_COMMAND","KEY_ARROW_LEFT_COMMAND","KEY_ARROW_RIGHT_COMMAND","KEY_ESCAPE_COMMAND","DELETE_WORD_COMMAND","DELETE_LINE_COMMAND","DELETE_CHARACTER_COMMAND","COMMAND_PRIORITY_CRITICAL","KEY_BACKSPACE_COMMAND","KEY_DELETE_COMMAND","CUT_COMMAND","FORMAT_TEXT_COMMAND","FORMAT_ELEMENT_COMMAND","CONTROLLED_TEXT_INSERTION_COMMAND","KEY_TAB_COMMAND","FOCUS_COMMAND","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","$getPreviousSelection","$createRangeSelectionFromDom","INSERT_PARAGRAPH_COMMAND","$isRootOrShadowRoot","$isDecoratorNode","copyToClipboard","$getClipboardDataFromSelection","PIXEL_VALUE_REG_EXP","COLUMN_WIDTH","TableCellHeaderStates","BOTH","COLUMN","NO_STATUS","ROW","TableCellNode","getType","clone","node","cellNode","__headerState","__colSpan","__width","__key","__rowSpan","__backgroundColor","importDOM","td","conversion","$convertTableCellNodeElement","priority","th","importJSON","serializedNode","colSpan","rowSpan","$createTableCellNode","headerState","width","undefined","backgroundColor","constructor","arguments","length","key","createDOM","config","element","document","createElement","getTag","style","theme","tableCell","hasHeader","tableCellHeader","exportDOM","editor","element_","border","getWidth","verticalAlign","textAlign","getBackgroundColor","exportJSON","type","getColSpan","setColSpan","getWritable","getRowSpan","setRowSpan","setHeaderStyles","self","getHeaderStyles","getLatest","setWidth","setBackgroundColor","newBackgroundColor","toggleHeaderStyle","headerStateToToggle","hasHeaderState","updateDOM","prevNode","isShadowRoot","collapseAtStart","canBeEmpty","canIndent","domNode","domNode_","nodeName","toLowerCase","test","parseFloat","tableCellNode","textDecoration","split","hasBoldFontWeight","fontWeight","hasLinethroughTextDecoration","includes","hasItalicFontStyle","fontStyle","hasUnderlineTextDecoration","after","childLexicalNodes","push","forChild","lexicalNode","parentLexicalNode","$isTableCellNode","paragraphNode","getTextContent","toggleFormat","append","INSERT_TABLE_COMMAND","TableRowNode","__height","tr","$convertTableRowElement","$createTableRowNode","height","getHeight","version","tableRow","setHeight","$isTableRowNode","CAN_USE_DOM","window","$createTableNodeWithDimensions","rowCount","columnCount","includeHeaders","tableNode","$createTableNode","iRow","tableRowNode","iColumn","rows","columns","$getTableCellNodeFromLexicalNode","startingNode","n","$getTableRowNodeFromTableCellNodeOrThrow","Error","$getTableNodeFromLexicalNodeOrThrow","$isTableNode","$getTableRowIndexFromTableCellNode","getChildren","findIndex","is","$getTableColumnIndexFromTableCellNode","$getTableCellSiblingsFromTableCellNode","table","x","y","getCordsFromCellNode","above","getCellNodeFromCords","below","left","right","$removeTableRowAtIndex","indexToDelete","tableRows","targetRowNode","remove","$insertTableRow","targetIndex","shouldInsertAfter","r","tableRowCells","tableColumnCount","newTableRowNode","c","tableCellFromTargetRow","insertAfter","insertBefore","getHeaderState","currentState","possibleState","$insertTableRow__EXPERIMENTAL","selection","$isTableSelection","focus","getNode","focusCell","grid","$getNodeTriplet","gridMap","focusCellMap","$computeTableMap","startRow","focusStartRow","focusEndRow","focusEndRowMap","newRow","i","cell","currentCell","currentCellHeaderState","focusEndRowNode","getChildAtIndex","focusStartRowMap","focusStartRowNode","$insertTableColumn","tableCellsToBeInserted","currentTableRowNode","tableRowChildren","targetCell","newTableCell","forEach","_ref","$insertTableColumn__EXPERIMENTAL","anchor","anchorCell","anchorCellMap","startColumn","Math","max","min","insertAfterColumn","gridFirstChild","getFirstChild","firstInsertedCell","$createTableCellNodeForInsertTableColumn","loopRow","rowLoop","currentRow","getNextSibling","rowMap","$insertFirst","currentStartColumn","currentStartRow","insertAfterCell","insertAfterCellRowStart","prevCellIndex","cell_","startRow_","$moveSelectionToCell","$deleteTableColumn","$deleteTableRow__EXPERIMENTAL","anchorStartRow","nextRow","nextRowNode","row","column","cellStartRow","cellStartColumn","previousCell","rowNode","String","previousRow","$deleteTableColumn__EXPERIMENTAL","anchorStartColumn","focusStartColumn","endColumn","selectedColumnCount","selectPrevious","overflowLeft","inSelectedArea","focusRowMap","nextColumn","firstDescendant","getFirstDescendant","selectStart","getParentOrThrow","parent","firstChild","$unmergeCell","map","cellMap","currentRowNode","currentRowMap","currentCellMap","j","cellA","cellB","tableMap","cellAValue","cellBValue","$computeTableMapSkipCellCheck","write","value","isEmpty","gridChildren","rowChildren","source","getParent","$getTableCellNodeRect","gridNode","cellMatrix","Array","rowIndex","cells","columnIndex","cellIndex","TableSelection","tableKey","_selection","_cachedNodes","dirty","getStartEndPoints","isBackward","isBefore","getCachedNodes","setCachedNodes","nodes","set","anchorCellKey","focusCellKey","isCollapsed","extract","getNodes","insertRawText","text","insertText","insertNodes","focusNode","select","getChildrenSize","getShape","anchorCellNode","anchorCellNodeRect","focusCellNode","focusCellNodeRect","startX","stopX","startY","stopY","fromX","fromY","toX","toY","cachedNodes","anchorNode","anchorRow","focusCellGrid","getParents","isParentOf","gridParent","getKey","focusCellParent","cellAMap","cellBMap","minColumn","minRow","maxColumn","maxRow","exploredMinColumn","exploredMinRow","exploredMaxColumn","exploredMaxRow","expandBoundary","mapValue","rowDiff","previousColumn","columnDiff","lastRow","$getChildrenRecursively","filter","textContent","__parent","$createTableSelection","stack","currentNode","pop","unshift","TableObserver","tableNodeKey","isHighlightingCells","anchorX","anchorY","focusX","focusY","listenersToRemove","Set","domRows","tableSelection","anchorCellNodeKey","focusCellNodeKey","hasHijackedSelectionStyles","trackTable","isSelecting","getTable","removeListeners","from","removeListener","observer","MutationObserver","records","update","gridNeedsRedraw","record","target","tableElement","getElementByKey","observe","attributes","childList","subtree","clearHighlight","enableHighlightStyle","$updateDOMForSelection","dispatchCommand","_config","classList","disableHighlightStyle","updateTableTableSelection","setFocusCellForSelection","ignoreStart","cellX","cellY","domSelection","getDOMSelection","_window","setBaseAndExtent","elem","focusTableCellNode","$findTableNode","focusNodeKey","setAnchorCellForSelection","anchorTableCellNode","anchorNodeKey","formatCells","formatSelection","getTextContentSize","formatText","clearText","selectedNodes","rootNode","textNode","child","LEXICAL_ELEMENT_KEY","targetWindow","getSelection","isMouseDownOnEvent","event","buttons","applyTableHandlers","hasTabHandler","rootElement","getRootElement","tableObserver","editorWindow","attachTableObserverToTableElement","createMouseHandlers","onMouseUp","removeEventListener","onMouseMove","moveEvent","setTimeout","getDOMCellFromTarget","preventDefault","addEventListener","button","stopEvent","mouseDownCallback","contains","add","registerCommand","$handleArrowKey","selectEnd","deleteTextHandler","command","$isSelectionInTable","isAnchorInside","isFocusInside","selectionContainsPartialTable","nearestElementNode","topLevelCellElementNode","getPreviousSibling","$deleteCellHandler","find","parentNode","stopPropagation","ClipboardEvent","intercepted","removeText","payload","formatType","setFormat","cellChildren","k","isInline","edgePosition","$getTableEdgeCursorPosition","$insertParagraphAtTableEdge","$findCellNode","currentCords","selectTableNodeInDirection","shiftKey","isSelected","getObserverCellFromCellNode","getDOMCellFromCordsOrThrow","selectionPayload","anchorAndFocus","isTableSelection","isRangeSelection","isSelectionInsideOfGrid","newGrid","newGridRows","newColumnCount","getFirstChildOrThrow","newRowCount","gridCellNode","gridRowNode","getIndexWithinParent","gridRowNodes","newRowIdx","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","currentGridCellNode","newGridCellNode","originalChildren","prevSelection","isPartialyWithinTable","isWithinTable","newSelection","firstCell","lastCell","at","$addHighlightStyleToTable","isFocusOutside","rangeCount","removeAllRanges","$removeHighlightStyleToTable","getTableObserverFromTableElement","_cell","nodeMame","hasBackgroundColor","highlighted","sibling","nextSibling","parentSibling","selectedCellNodes","$forEachTableCell","has","$addHighlightToDOM","$removeHighlightFromDOM","getAttribute","removeAttribute","cb","direction","isForward","selectTableCellNode","getCellNodeFromCordsOrThrow","selectNext","adjustFocusNodeInDirection","fromStart","BROWSER_BLUE_RGB","setProperty","removeProperty","isTypeaheadMenuInView","anchorType","anchorOffset","offset","siblingNode","selectedNode","lastDescendant","getLastDescendant","firstCellNode","lastCellNode","firstCellCoords","lastCellCoords","firstCellDOM","lastCellDOM","focusParentNode","anchorCellTable","anchorCellTableElement","isExitingTableAnchor","$handleTableExit","anchorCellDom","anchorDOM","edgeSelectionRect","getBoundingClientRect","range","getRangeAt","edgeChild","getLastChild","edgeChildDOM","edgeRect","isExiting","top","bottom","cords","tableNodeFromSelection","cordsAnchor","stopImmediatePropagation","root","hasAttribute","isExitingTableElementAnchor","$isExitingTableTextAnchor","hasValidOffset","cellValue","isExitingCell","toNode","$getExitingToNode","anchorSibling","children","tableNodeParent","tableNodeParentDOM","parentTable","isAtFirstCell","isAtLastCell","TableNode","_node","$convertTableElement","_serializedNode","newElement","cloneNode","colGroup","tBody","firstRow","colCount","col","replaceChildren","getDOMCellFromCords","index","canSelectBefore","$getElementForTableNode","_domNode"],"sources":["/media/ks/My thing/test/textditor_Using_lixical/node_modules/@lexical/table/LexicalTable.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement } from '@lexical/utils';\nimport { ElementNode, $createParagraphNode, $isElementNode, $isLineBreakNode, $isTextNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $createPoint, $normalizeSelection__EXPERIMENTAL, $getNodeByKey, isCurrentlyReadOnlyMode, $setSelection, SELECTION_CHANGE_COMMAND, $getNearestNodeFromDOMNode, $createRangeSelection, $getRoot, KEY_ARROW_DOWN_COMMAND, COMMAND_PRIORITY_HIGH, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ESCAPE_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, COMMAND_PRIORITY_CRITICAL, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $createRangeSelectionFromDom, INSERT_PARAGRAPH_COMMAND, $isRootOrShadowRoot, $isDecoratorNode } from 'lexical';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    const cellNode = new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n    cellNode.__rowSpan = node.__rowSpan;\n    cellNode.__backgroundColor = node.__backgroundColor;\n    return cellNode;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const colSpan = serializedNode.colSpan || 1;\n    const rowSpan = serializedNode.rowSpan || 1;\n    const cellNode = $createTableCellNode(serializedNode.headerState, colSpan, serializedNode.width || undefined);\n    cellNode.__rowSpan = rowSpan;\n    cellNode.__backgroundColor = serializedNode.backgroundColor || null;\n    return cellNode;\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element) {\n      const element_ = element;\n      element_.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element_.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element_.rowSpan = this.__rowSpan;\n      }\n      element_.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element_.style.verticalAlign = 'top';\n      element_.style.textAlign = 'start';\n      const backgroundColor = this.getBackgroundColor();\n      if (backgroundColor !== null) {\n        element_.style.backgroundColor = backgroundColor;\n      } else if (this.hasHeader()) {\n        element_.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      type: 'tablecell',\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.__colSpan;\n  }\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState) {\n    const self = this.getWritable();\n    self.__headerState = headerState;\n    return this.__headerState;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return this.__width;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    this.getWritable().__backgroundColor = newBackgroundColor;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = style.textDecoration.split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(this.getHeight() && {\n        height: this.getHeight()\n      }),\n      type: 'tablerow',\n      version: 1\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return this.__height;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const focus = selection.focus.getNode();\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap] = $computeTableMap(grid, focusCell, focusCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n    const focusEndRowMap = gridMap[focusEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= focusEndRow) {\n        const currentCell = focusEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusEndRowNode = grid.getChildAtIndex(focusEndRow);\n    if (!$isTableRowNode(focusEndRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusEndRowNode.insertAfter(newRow);\n  } else {\n    const focusStartRowMap = gridMap[focusStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = focusStartRowMap[i];\n      if (startRow === focusStartRow) {\n        const currentCell = focusStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const focusStartRowNode = grid.getChildAtIndex(focusStartRow);\n    if (!$isTableRowNode(focusStartRowNode)) {\n      throw Error(`focusEndRow is not a TableRowNode`);\n    }\n    focusStartRowNode.insertBefore(newRow);\n  }\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        cell.setRowSpan(cell.__rowSpan - (cellStartRow - anchorStartRow));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        if (column === 0) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          const {\n            cell: previousCell\n          } = nextRow[column - 1];\n          previousCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected GridNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    const [map, cellMap] = $computeTableMap(grid, cell, cell);\n    const {\n      startColumn,\n      startRow\n    } = cellMap;\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = 0; j < colSpan; j++) {\n          $insertFirst(currentRowNode, $createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = 0; j < colSpan; j++) {\n          insertAfterCell.insertAfter($createTableCellNode(TableCellHeaderStates.NO_STATUS).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(grid, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(grid, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n    if (cellA !== null && cellA.is(cell)) {\n      cellAValue = value;\n    }\n    if (cellB !== null && cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n  const gridChildren = grid.getChildren();\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected GridNode children to be TableRowNode`);\n    }\n    const rowChildren = row.getChildren();\n    let j = 0;\n    for (const cell of rowChildren) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      }\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent GridNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isTableSelection(selection)) {\n      return false;\n    }\n    return this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, this.anchor, this.focus);\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n    if (!$isTableCellNode(anchorCellNode)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCellNode);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNode = $getNodeByKey(this.focus.key);\n    if (!$isTableCellNode(focusCellNode)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCellNode);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, $isTableCellNode);\n    // todo replace with triplet\n    const focusCell = $findMatchingParent(focusNode, $isTableCellNode);\n    if (!$isTableCellNode(anchorCell)) {\n      throw Error(`Expected TableSelection anchor to be (or a child of) TableCellNode`);\n    }\n    if (!$isTableCellNode(focusCell)) {\n      throw Error(`Expected TableSelection focus to be (or a child of) TableCellNode`);\n    }\n    const anchorRow = anchorCell.getParent();\n    if (!$isTableRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent TableRowNode`);\n    }\n    const tableNode = anchorRow.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected tableNode to have a parent TableNode`);\n    }\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n        exploredMinColumn = previousColumn;\n      }\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n        exploredMinRow = previousRow;\n      }\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n        exploredMaxColumn = nextColumn;\n      }\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n        exploredMaxRow = nextRow;\n      }\n    }\n    const nodes = [tableNode];\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.trackTable();\n    this.isSelecting = false;\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.update(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n        if (!tableElement) {\n          throw new Error('Expected to find TableElement in DOM');\n        }\n        this.table = getTable(tableElement);\n      });\n    });\n    this.editor.update(() => {\n      const tableElement = this.editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      this.table = getTable(tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    });\n  }\n  clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.enableHighlightStyle();\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const grid = getTable(tableElement);\n      $updateDOMForSelection(editor, grid, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  enableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n      tableElement.classList.remove('disable-selection');\n      this.hasHijackedSelectionStyles = false;\n    });\n  }\n  disableHighlightStyle() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      addClassNamesToElement(tableElement, editor._config.theme.tableSelection);\n      this.hasHijackedSelectionStyles = true;\n    });\n  }\n  updateTableTableSelection(selection) {\n    if (selection !== null && selection.tableKey === this.tableNodeKey) {\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.disableHighlightStyle();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else if (selection == null) {\n      this.clearHighlight();\n    } else {\n      this.tableNodeKey = selection.tableKey;\n      this.updateTableTableSelection(selection);\n    }\n  }\n  setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const tableElement = editor.getElementByKey(this.tableNodeKey);\n      if (!tableElement) {\n        throw new Error('Expected to find TableElement in DOM');\n      }\n      const cellX = cell.x;\n      const cellY = cell.y;\n      this.focusCell = cell;\n      if (this.anchorCell !== null) {\n        const domSelection = getDOMSelection(editor._window);\n        // Collapse the selection\n        if (domSelection) {\n          domSelection.setBaseAndExtent(this.anchorCell.elem, 0, this.focusCell.elem, 0);\n        }\n      }\n      if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n        this.isHighlightingCells = true;\n        this.disableHighlightStyle();\n      } else if (cellX === this.focusX && cellY === this.focusY) {\n        return;\n      }\n      this.focusX = cellX;\n      this.focusY = cellY;\n      if (this.isHighlightingCells) {\n        const focusTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n        if (this.tableSelection != null && this.anchorCellNodeKey != null && $isTableCellNode(focusTableCellNode) && tableNode.is($findTableNode(focusTableCellNode))) {\n          const focusNodeKey = focusTableCellNode.getKey();\n          this.tableSelection = this.tableSelection.clone() || $createTableSelection();\n          this.focusCellNodeKey = focusNodeKey;\n          this.tableSelection.set(this.tableNodeKey, this.anchorCellNodeKey, this.focusCellNodeKey);\n          $setSelection(this.tableSelection);\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n          $updateDOMForSelection(editor, this.table, this.tableSelection);\n        }\n      }\n    });\n  }\n  setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    this.editor.update(() => {\n      const anchorTableCellNode = $getNearestNodeFromDOMNode(cell.elem);\n      if ($isTableCellNode(anchorTableCellNode)) {\n        const anchorNodeKey = anchorTableCellNode.getKey();\n        this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n        this.anchorCellNodeKey = anchorNodeKey;\n      }\n    });\n  }\n  formatCells(type) {\n    this.editor.update(() => {\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const formatSelection = $createRangeSelection();\n      const anchor = formatSelection.anchor;\n      const focus = formatSelection.focus;\n      selection.getNodes().forEach(cellNode => {\n        if ($isTableCellNode(cellNode) && cellNode.getTextContentSize() !== 0) {\n          anchor.set(cellNode.getKey(), 0, 'element');\n          focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n          formatSelection.formatText(type);\n        }\n      });\n      $setSelection(selection);\n      this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n  clearText() {\n    const editor = this.editor;\n    editor.update(() => {\n      const tableNode = $getNodeByKey(this.tableNodeKey);\n      if (!$isTableNode(tableNode)) {\n        throw new Error('Expected TableNode.');\n      }\n      const selection = $getSelection();\n      if (!$isTableSelection(selection)) {\n        {\n          throw Error(`Expected grid selection`);\n        }\n      }\n      const selectedNodes = selection.getNodes().filter($isTableCellNode);\n      if (selectedNodes.length === this.table.columns * this.table.rows) {\n        tableNode.selectPrevious();\n        // Delete entire table\n        tableNode.remove();\n        const rootNode = $getRoot();\n        rootNode.selectStart();\n        return;\n      }\n      selectedNodes.forEach(cellNode => {\n        if ($isElementNode(cellNode)) {\n          const paragraphNode = $createParagraphNode();\n          const textNode = $createTextNode();\n          paragraphNode.append(textNode);\n          cellNode.append(paragraphNode);\n          cellNode.getChildren().forEach(child => {\n            if (child !== paragraphNode) {\n              child.remove();\n            }\n          });\n        }\n      });\n      $updateDOMForSelection(editor, this.table, null);\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    });\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction applyTableHandlers(tableNode, tableElement, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    throw new Error('No root element.');\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const editorWindow = editor._window || window;\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  const createMouseHandlers = () => {\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      // delaying mousemove handler to allow selectionchange handler from LexicalEvents.ts to be executed first\n      setTimeout(() => {\n        if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n          tableObserver.isSelecting = false;\n          editorWindow.removeEventListener('mouseup', onMouseUp);\n          editorWindow.removeEventListener('mousemove', onMouseMove);\n          return;\n        }\n        const focusCell = getDOMCellFromTarget(moveEvent.target);\n        if (focusCell !== null && (tableObserver.anchorX !== focusCell.x || tableObserver.anchorY !== focusCell.y)) {\n          moveEvent.preventDefault();\n          tableObserver.setFocusCellForSelection(focusCell);\n        }\n      }, 0);\n    };\n    return {\n      onMouseMove: onMouseMove,\n      onMouseUp: onMouseUp\n    };\n  };\n  tableElement.addEventListener('mousedown', event => {\n    setTimeout(() => {\n      if (event.button !== 0) {\n        return;\n      }\n      if (!editorWindow) {\n        return;\n      }\n      const anchorCell = getDOMCellFromTarget(event.target);\n      if (anchorCell !== null) {\n        stopEvent(event);\n        tableObserver.setAnchorCellForSelection(anchorCell);\n      }\n      const {\n        onMouseUp,\n        onMouseMove\n      } = createMouseHandlers();\n      tableObserver.isSelecting = true;\n      editorWindow.addEventListener('mouseup', onMouseUp);\n      editorWindow.addEventListener('mousemove', onMouseMove);\n    }, 0);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    if (event.button !== 0) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      const target = event.target;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback);\n  tableObserver.listenersToRemove.add(() => editorWindow.removeEventListener('mousedown', mouseDownCallback));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_DOWN_COMMAND, event => $handleArrowKey(editor, event, 'down', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_UP_COMMAND, event => $handleArrowKey(editor, event, 'up', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_LEFT_COMMAND, event => $handleArrowKey(editor, event, 'backward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, event => $handleArrowKey(editor, event, 'forward', tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findMatchingParent(selection.focus.getNode(), $isTableCellNode);\n      if ($isTableCellNode(focusCellNode)) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND].forEach(command => {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  });\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      const nodes = selection ? selection.getNodes() : null;\n      if (nodes) {\n        const table = nodes.find(node => $isTableNode(node) && node.getKey() === tableObserver.tableNodeKey);\n        if ($isTableNode(table)) {\n          const parentNode = table.getParent();\n          if (!parentNode) {\n            return false;\n          }\n          table.remove();\n        }\n      }\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  };\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_BACKSPACE_COMMAND, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_DELETE_COMMAND, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow, focusCell.startRow);\n    const maxColumn = Math.max(anchorCell.startColumn, focusCell.startColumn);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null) {\n        return false;\n      }\n      stopEvent(event);\n      const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n      selectTableNodeInDirection(tableObserver, tableNode, currentCords.x, currentCords.y, !event.shiftKey ? 'forward' : 'backward');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  function getObserverCellFromCellNode(tableCellNode) {\n    const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n    return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = $findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && $findMatchingParent(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && $findMatchingParent(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartialyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartialyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into grid selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.setAnchorCellForSelection(getObserverCellFromCellNode(anchorCellNode));\n          tableObserver.setFocusCellForSelection(getObserverCellFromCellNode(focusCellNode), true);\n          if (!tableObserver.isSelecting) {\n            setTimeout(() => {\n              const {\n                onMouseUp,\n                onMouseMove\n              } = createMouseHandlers();\n              tableObserver.isSelecting = true;\n              editorWindow.addEventListener('mouseup', onMouseUp);\n              editorWindow.addEventListener('mousemove', onMouseMove);\n            }, 0);\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.is($findTableNode(focusNode));\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.is($findTableNode(anchorNode));\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY];\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableElement) {\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.firstChild;\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nconst adjustFocusNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table));\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y - 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        tableObserver.setFocusCellForSelection(tableNode.getDOMCellFromCordsOrThrow(x, y + 1, tableObserver.table));\n        return true;\n      } else {\n        return false;\n      }\n    default:\n      return false;\n  }\n};\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nconst BROWSER_BLUE_RGB = '172,206,247';\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.setProperty('background-color', `rgb(${BROWSER_BLUE_RGB})`);\n  } else {\n    element.style.setProperty('background-image', `linear-gradient(to right, rgba(${BROWSER_BLUE_RGB},0.85), rgba(${BROWSER_BLUE_RGB},0.85))`);\n  }\n  element.style.setProperty('caret-color', 'transparent');\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const backgroundColor = node.getBackgroundColor();\n  if (backgroundColor === null) {\n    element.style.removeProperty('background-color');\n  }\n  element.style.removeProperty('background-image');\n  element.style.removeProperty('caret-color');\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (selection.isCollapsed() && direction === 'backward') {\n        const anchorType = selection.anchor.type;\n        const anchorOffset = selection.anchor.offset;\n        if (anchorType !== 'element' && !(anchorType === 'text' && anchorOffset === 0)) {\n          return false;\n        }\n        const anchorNode = selection.anchor.getNode();\n        if (!anchorNode) {\n          return false;\n        }\n        const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!siblingNode || !$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        siblingNode.selectEnd();\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findMatchingParent(selectedNode, $isTableCellNode);\n            if (tableCellNode && tableNode.isParentOf(tableCellNode)) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.setAnchorCellForSelection(firstCellDOM);\n              tableObserver.setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          const focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = editor.getElementByKey(anchorCellTable.getKey());\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && $isDecoratorNode(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = window.getSelection();\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.setAnchorCellForSelection(cell);\n        tableObserver.setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    const tableElement = editor.getElementByKey(tableNodeFromSelection.getKey());\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.updateTableTableSelection(selection);\n    const grid = getTable(tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const cords = tableNode.getCordsFromCellNode(focusCellNode, grid);\n      return adjustFocusNodeInDirection(tableObserver, tableNodeFromSelection, cords.x, cords.y, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, tableNode, direction) {\n  const anchorCellNode = $findMatchingParent(anchorNode, $isTableCellNode);\n  if (!$isTableCellNode(anchorCellNode)) {\n    return false;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  if (!tableNodeParentDOM) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = window.getSelection();\n  if (!domSelection || domSelection.anchorNode !== tableNodeParentDOM) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  static getType() {\n    return 'table';\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(_serializedNode) {\n    return $createTableNode();\n  }\n  constructor(key) {\n    super(key);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'table',\n      version: 1\n    };\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    addClassNamesToElement(tableElement, config.theme.table);\n    return tableElement;\n  }\n  updateDOM() {\n    return false;\n  }\n  exportDOM(editor) {\n    return {\n      ...super.exportDOM(editor),\n      after: tableElement => {\n        if (tableElement) {\n          const newElement = tableElement.cloneNode();\n          const colGroup = document.createElement('colgroup');\n          const tBody = document.createElement('tbody');\n          if (isHTMLElement(tableElement)) {\n            tBody.append(...tableElement.children);\n          }\n          const firstRow = this.getFirstChildOrThrow();\n          if (!$isTableRowNode(firstRow)) {\n            throw new Error('Expected to find row node.');\n          }\n          const colCount = firstRow.getChildrenSize();\n          for (let i = 0; i < colCount; i++) {\n            const col = document.createElement('col');\n            colGroup.append(col);\n          }\n          newElement.replaceChildren(colGroup, tBody);\n          return newElement;\n        }\n      }\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      const x = row.findIndex(cell => {\n        if (!cell) {\n          return;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestNodeFromDOMNode(elem);\n        return cellNode === tableCellNode;\n      });\n      if (x !== -1) {\n        return {\n          x,\n          y\n        };\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (tableElement == null) {\n    throw new Error('Table Element Not Found');\n  }\n  return getTable(tableElement);\n}\nfunction $convertTableElement(_domNode) {\n  return {\n    node: $createTableNode()\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $deleteTableColumn, $deleteTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRow__EXPERIMENTAL, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableObserverFromTableElement };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}