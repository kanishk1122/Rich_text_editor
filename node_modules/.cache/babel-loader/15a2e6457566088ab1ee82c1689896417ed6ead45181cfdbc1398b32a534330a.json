{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isParagraphNode, $isTextNode, $getRoot, $isElementNode, $isDecoratorNode, $isLineBreakNode, $getSelection, $createTextNode, $createParagraphNode, $createLineBreakNode, $isRangeSelection, $isRootOrShadowRoot, $createRangeSelection, $setSelection } from 'lexical';\nimport { $createCodeNode, $isCodeNode, CodeNode } from '@lexical/code';\nimport { $isListNode, $isListItemNode, ListNode, ListItemNode, $createListItemNode, $createListNode } from '@lexical/list';\nimport { $isQuoteNode, HeadingNode, $isHeadingNode, QuoteNode, $createQuoteNode, $createHeadingNode } from '@lexical/rich-text';\nimport { $findMatchingParent } from '@lexical/utils';\nimport { LinkNode, $isLinkNode, $createLinkNode } from '@lexical/link';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && $isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction createMarkdownExport(transformers) {\n  let shouldPreserveNewLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const byType = transformersByType(transformers);\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || $getRoot()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // seperate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are atleast \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ($isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ($isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ($isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if ($isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if ($isElementNode(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if ($isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n      // Prevent adding opening tag is already opened by the previous sibling\n      const previousNode = getTextSibling(node, true);\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      }\n\n      // Prevent adding closing tag if next sibling will do it\n      const nextNode = getTextSibling(node, false);\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  }\n\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return textContent.replace(frozenString, () => output);\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ($isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ($isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ($isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return $isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CODE_BLOCK_REG_EXP = /^[ \\t]*```(\\w{1,10})?\\s?$/;\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction createMarkdownImport(transformers) {\n  let shouldPreserveNewLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || $getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n      const [codeBlockNode, shiftedIndex] = $importCodeBlock(lines, i, root);\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ($getSelection() !== null) {\n      root.selectStart();\n    }\n  };\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const textNode = $createTextNode(lineText);\n  const elementNode = $createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if ($isParagraphNode(previousNode) || $isQuoteNode(previousNode) || $isListNode(previousNode)) {\n      let targetNode = previousNode;\n      if ($isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = $findMatchingParent(lastDescendant, $isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction $importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n      if (closeMatch) {\n        const codeBlockNode = $createCodeNode(openMatch[1]);\n        const textNode = $createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n  return [null, startLineIndex];\n}\n\n// Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n  let currentNode, remainderNode, leadingNode;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  }\n\n  // Recursively run over inner text if it's not inline code\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  // Run over leading/remaining text if any\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n      if (!match) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, newTextNode;\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [, replaceNode, newTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n      if (newTextNode) {\n        importTextMatchTransformers(newTextNode, textMatchTransformers);\n      }\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n    break;\n  }\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ($isLineBreakNode(sibling)) {\n        break;\n      }\n      if ($isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = $getSelection();\n    const nextSelection = $createRangeSelection();\n    $setSelection(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor) {\n  let transformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TRANSFORMERS;\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, _ref => {\n    let {\n      tag\n    } = _ref;\n    return tag[tag.length - 1];\n  });\n  const textMatchTransformersIndex = indexBy(byType.textMatch, _ref2 => {\n    let {\n      trigger\n    } = _ref2;\n    return trigger;\n  });\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n  return editor.registerUpdateListener(_ref3 => {\n    let {\n      tags,\n      dirtyLeaves,\n      editorState,\n      prevEditorState\n    } = _ref3;\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has('collaboration') || tags.has('historic')) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read($getSelection);\n    const prevSelection = prevEditorState.read($getSelection);\n    if (!$isRangeSelection(prevSelection) || !$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || $isCodeNode(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [HeadingNode],\n  export: (node, exportChildren) => {\n    if (!$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return $createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = $createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [CodeNode],\n  export: node => {\n    if (!$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^[ \\t]*```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return $createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!$isLinkNode(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild();\n    // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n    if (node.getChildrenSize() === 1 && $isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = $createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = $createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction $convertFromMarkdownString(markdown) {\n  let transformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TRANSFORMERS;\n  let node = arguments.length > 2 ? arguments[2] : undefined;\n  let shouldPreserveNewLines = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(markdown, node);\n}\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction $convertToMarkdownString() {\n  let transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TRANSFORMERS;\n  let node = arguments.length > 1 ? arguments[1] : undefined;\n  let shouldPreserveNewLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\nexport { $convertFromMarkdownString, $convertToMarkdownString, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, CHECK_LIST, CODE, ELEMENT_TRANSFORMERS, HEADING, HIGHLIGHT, INLINE_CODE, ITALIC_STAR, ITALIC_UNDERSCORE, LINK, ORDERED_LIST, QUOTE, STRIKETHROUGH, TEXT_FORMAT_TRANSFORMERS, TEXT_MATCH_TRANSFORMERS, TRANSFORMERS, UNORDERED_LIST, registerMarkdownShortcuts };","map":{"version":3,"names":["$isParagraphNode","$isTextNode","$getRoot","$isElementNode","$isDecoratorNode","$isLineBreakNode","$getSelection","$createTextNode","$createParagraphNode","$createLineBreakNode","$isRangeSelection","$isRootOrShadowRoot","$createRangeSelection","$setSelection","$createCodeNode","$isCodeNode","CodeNode","$isListNode","$isListItemNode","ListNode","ListItemNode","$createListItemNode","$createListNode","$isQuoteNode","HeadingNode","$isHeadingNode","QuoteNode","$createQuoteNode","$createHeadingNode","$findMatchingParent","LinkNode","$isLinkNode","$createLinkNode","indexBy","list","callback","index","item","key","push","transformersByType","transformers","byType","t","type","element","textFormat","textMatch","PUNCTUATION_OR_SPACE","MARKDOWN_EMPTY_LINE_REG_EXP","isEmptyParagraph","node","firstChild","getFirstChild","getChildrenSize","test","getTextContent","createMarkdownExport","shouldPreserveNewLines","arguments","length","undefined","isNewlineDelimited","textFormatTransformers","filter","transformer","format","output","children","getChildren","i","child","result","exportTopLevelElements","concat","join","elementTransformers","textTransformersIndex","textMatchTransformers","export","_node","exportChildren","mainLoop","parentNode","textNode","textContent","exportTextFormat","textTransformers","frozenString","trim","applied","Set","tag","hasFormat","has","add","previousNode","getTextSibling","nextNode","replace","backward","sibling","getPreviousSibling","getNextSibling","parent","getParentOrThrow","isInline","descendant","getLastDescendant","getFirstDescendant","CAN_USE_DOM","window","document","createElement","documentMode","InputEvent","IS_SAFARI","navigator","userAgent","IS_IOS","MSStream","IS_CHROME","IS_APPLE_WEBKIT","CODE_BLOCK_REG_EXP","createMarkdownImport","textFormatTransformersIndex","createTextFormatTransformersIndex","markdownString","lines","split","linesLength","root","clear","lineText","codeBlockNode","shiftedIndex","$importCodeBlock","$importBlocks","remove","selectStart","rootNode","elementNode","append","regExp","match","setTextContent","slice","importTextFormatTransformers","isAttached","targetNode","lastDescendant","getTextContentSize","splice","startLineIndex","openMatch","endLineIndex","closeMatch","findOutermostMatch","importTextMatchTransformers","currentNode","remainderNode","leadingNode","startIndex","endIndex","splitText","transformersByTag","toggleFormat","textNode_","importRegExp","replaceNode","newTextNode","openTagsMatch","openTagsRegExp","fullMatchRegExp","fullMatchRegExpByTag","fullMatch","intraword","beforeChar","afterChar","escapeRegExp","tagRegExp","RegExp","runElementTransformers","anchorNode","anchorOffset","grandParentNode","getParent","nextSiblings","getNextSiblings","siblings","runTextMatchTransformers","transformersByTrigger","lastChar","selectNext","$runTextFormatTransformers","closeTagEndIndex","closeChar","matchers","matcher","tagLength","closeTagStartIndex","isEqualSubString","afterCloseTagChar","closeNode","openNode","openTagStartIndex","getOpenTagStartIndex","siblingTextContent","prevOpenNodeText","beforeOpenTagChar","prevCloseNodeText","closeNodeText","openNodeText","selection","nextSelection","newOffset","anchor","set","__key","focus","formatText","offset","string","maxIndex","stringA","aStart","stringB","bStart","registerMarkdownShortcuts","editor","TRANSFORMERS","_ref","textMatchTransformersIndex","_ref2","trigger","dependencies","hasNode","Error","getType","$transform","registerUpdateListener","_ref3","tags","dirtyLeaves","editorState","prevEditorState","isComposing","read","prevSelection","isCollapsed","anchorKey","_nodeMap","get","update","createBlockNode","createNode","select","LIST_INDENT_SIZE","getIndent","whitespaces","tabs","spaces","indent","Math","floor","listReplace","listType","listItem","getListType","insertBefore","Number","setIndent","listExport","listNode","depth","listItemNode","repeat","prefix","getStart","getChecked","HEADING","level","getTag","QUOTE","line","_match","isImport","CODE","getLanguage","UNORDERED_LIST","CHECK_LIST","ORDERED_LIST","INLINE_CODE","HIGHLIGHT","BOLD_ITALIC_STAR","BOLD_ITALIC_UNDERSCORE","BOLD_STAR","BOLD_UNDERSCORE","STRIKETHROUGH","ITALIC_STAR","ITALIC_UNDERSCORE","LINK","exportFormat","title","getTitle","linkContent","getURL","linkText","linkUrl","linkTitle","linkNode","linkTextNode","setFormat","getFormat","ELEMENT_TRANSFORMERS","TEXT_FORMAT_TRANSFORMERS","TEXT_MATCH_TRANSFORMERS","$convertFromMarkdownString","markdown","importMarkdown","$convertToMarkdownString","exportMarkdown"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/markdown/LexicalMarkdown.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $isParagraphNode, $isTextNode, $getRoot, $isElementNode, $isDecoratorNode, $isLineBreakNode, $getSelection, $createTextNode, $createParagraphNode, $createLineBreakNode, $isRangeSelection, $isRootOrShadowRoot, $createRangeSelection, $setSelection } from 'lexical';\nimport { $createCodeNode, $isCodeNode, CodeNode } from '@lexical/code';\nimport { $isListNode, $isListItemNode, ListNode, ListItemNode, $createListItemNode, $createListNode } from '@lexical/list';\nimport { $isQuoteNode, HeadingNode, $isHeadingNode, QuoteNode, $createQuoteNode, $createHeadingNode } from '@lexical/rich-text';\nimport { $findMatchingParent } from '@lexical/utils';\nimport { LinkNode, $isLinkNode, $createLinkNode } from '@lexical/link';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nfunction isEmptyParagraph(node) {\n  if (!$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && $isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction createMarkdownExport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const isNewlineDelimited = !shouldPreserveNewLines;\n\n  // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return node => {\n    const output = [];\n    const children = (node || $getRoot()).getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(\n        // seperate consecutive group of texts with a line break: eg. [\"hello\", \"world\"] -> [\"hello\", \"/nworld\"]\n        isNewlineDelimited && i > 0 && !isEmptyParagraph(child) && !isEmptyParagraph(children[i - 1]) ? '\\n'.concat(result) : result);\n      }\n    }\n    // Ensure consecutive groups of texts are atleast \\n\\n apart while each empty paragraph render as a newline.\n    // Eg. [\"hello\", \"\", \"\", \"hi\", \"\\nworld\"] -> \"hello\\n\\n\\nhi\\n\\nworld\"\n    return output.join('\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  if ($isElementNode(node)) {\n    return exportChildren(node, textTransformersIndex, textMatchTransformers);\n  } else if ($isDecoratorNode(node)) {\n    return node.getTextContent();\n  } else {\n    return null;\n  }\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if ($isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if ($isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if ($isElementNode(child)) {\n      // empty paragraph returns \"\"\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    } else if ($isDecoratorNode(child)) {\n      output.push(child.getTextContent());\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format);\n      // Prevent adding opening tag is already opened by the previous sibling\n      const previousNode = getTextSibling(node, true);\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      }\n\n      // Prevent adding closing tag if next sibling will do it\n      const nextNode = getTextSibling(node, false);\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  }\n\n  // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n  return textContent.replace(frozenString, () => output);\n}\n\n// Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if ($isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if ($isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if ($isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return $isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CODE_BLOCK_REG_EXP = /^[ \\t]*```(\\w{1,10})?\\s?$/;\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction createMarkdownImport(transformers, shouldPreserveNewLines = false) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return (markdownString, node) => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = node || $getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i];\n      // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n      const [codeBlockNode, shiftedIndex] = $importCodeBlock(lines, i, root);\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n      $importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    }\n\n    // By default, removing empty paragraphs as md does not really\n    // allow empty lines and uses them as delimiter.\n    // If you need empty lines set shouldPreserveNewLines = true.\n    const children = root.getChildren();\n    for (const child of children) {\n      if (!shouldPreserveNewLines && isEmptyParagraph(child) && root.getChildrenSize() > 1) {\n        child.remove();\n      }\n    }\n    if ($getSelection() !== null) {\n      root.selectStart();\n    }\n  };\n}\nfunction $importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const textNode = $createTextNode(lineText);\n  const elementNode = $createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers);\n\n  // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n  if (elementNode.isAttached() && lineText.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if ($isParagraphNode(previousNode) || $isQuoteNode(previousNode) || $isListNode(previousNode)) {\n      let targetNode = previousNode;\n      if ($isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = $findMatchingParent(lastDescendant, $isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction $importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n      if (closeMatch) {\n        const codeBlockNode = $createCodeNode(openMatch[1]);\n        const textNode = $createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n  return [null, startLineIndex];\n}\n\n// Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n  let currentNode, remainderNode, leadingNode;\n\n  // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  }\n\n  // Recursively run over inner text if it's not inline code\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  // Run over leading/remaining text if any\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n      if (!match) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode, newTextNode;\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [, replaceNode, newTextNode] = textNode.splitText(startIndex, endIndex);\n      }\n      if (newTextNode) {\n        importTextMatchTransformers(newTextNode, textMatchTransformers);\n      }\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n    break;\n  }\n}\n\n// Finds first \"<tag>content<tag>\" match that is not nested into another tag\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      }\n\n      // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^|\\+)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n    if (IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent();\n\n  // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  }\n\n  // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex];\n  // Quick check if we're possibly at the end of inline markdown style\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1;\n\n    // If tag is not single char check if rest of it matches with text content\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    }\n\n    // Space before closing tag cancels inline markdown\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation after it\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag);\n\n    // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if ($isLineBreakNode(sibling)) {\n        break;\n      }\n      if ($isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    }\n\n    // Opening tag is not found\n    if (openTagStartIndex < 0) {\n      continue;\n    }\n\n    // No content between opening and closing tag\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    }\n\n    // Checking longer tags for repeating chars (e.g. *** vs **)\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    }\n\n    // Some tags can not be used within words, hence should have newline/space/punctuation before it\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    }\n\n    // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = $getSelection();\n    const nextSelection = $createRangeSelection();\n    $setSelection(nextSelection);\n    // Adjust offset based on deleted chars\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text');\n\n    // Apply formatting to selected text\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    }\n\n    // Collapse selection up to the focus point\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type);\n\n    // Remove formatting from collapsed selection\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n      for (const node of dependencies) {\n        if (!editor.hasNode(node)) {\n          {\n            throw Error(`MarkdownShortcuts: missing dependency ${node.getType()} for transformer. Ensure node dependency is included in editor initial config.`);\n          }\n        }\n      }\n    }\n  }\n  const $transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n    $runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from collaboration and undo/redo (as changes already calculated)\n    if (tags.has('collaboration') || tags.has('historic')) {\n      return;\n    }\n\n    // If editor is still composing (i.e. backticks) we must wait before the user confirms the key\n    if (editor.isComposing()) {\n      return;\n    }\n    const selection = editorState.read($getSelection);\n    const prevSelection = prevEditorState.read($getSelection);\n    if (!$isRangeSelection(prevSelection) || !$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset > prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || $isCodeNode(parentNode)) {\n        return;\n      }\n      $transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n};\n\n// Amount of spaces that define indentation level\n// TODO: should be an option\nconst LIST_INDENT_SIZE = 4;\nfunction getIndent(whitespaces) {\n  const tabs = whitespaces.match(/\\t/g);\n  const spaces = whitespaces.match(/ /g);\n  let indent = 0;\n  if (tabs) {\n    indent += tabs.length;\n  }\n  if (spaces) {\n    indent += Math.floor(spaces.length / LIST_INDENT_SIZE);\n  }\n  return indent;\n}\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const nextNode = parentNode.getNextSibling();\n    const listItem = $createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if ($isListNode(nextNode) && nextNode.getListType() === listType) {\n      const firstChild = nextNode.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItem);\n      } else {\n        // should never happen, but let's handle gracefully, just in case.\n        nextNode.append(listItem);\n      }\n      parentNode.remove();\n    } else if ($isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list = $createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list.append(listItem);\n      parentNode.replace(list);\n    }\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = getIndent(match[1]);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if ($isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if ($isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [HeadingNode],\n  export: (node, exportChildren) => {\n    if (!$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return $createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [QuoteNode],\n  export: (node, exportChildren) => {\n    if (!$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if ($isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = $createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [CodeNode],\n  export: node => {\n    if (!$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^[ \\t]*```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return $createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [ListNode, ListItemNode],\n  export: (node, exportChildren) => {\n    return $isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst HIGHLIGHT = {\n  format: ['highlight'],\n  tag: '==',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n};\n\n// Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst LINK = {\n  dependencies: [LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!$isLinkNode(node)) {\n      return null;\n    }\n    const title = node.getTitle();\n    const linkContent = title ? `[${node.getTextContent()}](${node.getURL()} \"${title}\")` : `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild();\n    // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n    if (node.getChildrenSize() === 1 && $isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\((?:([^()\\s]+)(?:\\s\"((?:[^\"]*\\\\\")*[^\"]*)\"\\s*)?)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl, linkTitle] = match;\n    const linkNode = $createLinkNode(linkUrl, {\n      title: linkTitle\n    });\n    const linkTextNode = $createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST];\n\n// Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, HIGHLIGHT, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\n/**\n * Renders markdown from a string. The selection is moved to the start after the operation.\n */\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const importMarkdown = createMarkdownImport(transformers, shouldPreserveNewLines);\n  return importMarkdown(markdown, node);\n}\n\n/**\n * Renders string from markdown. The selection is moved to the start after the operation.\n */\nfunction $convertToMarkdownString(transformers = TRANSFORMERS, node, shouldPreserveNewLines = false) {\n  const exportMarkdown = createMarkdownExport(transformers, shouldPreserveNewLines);\n  return exportMarkdown(node);\n}\n\nexport { $convertFromMarkdownString, $convertToMarkdownString, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, CHECK_LIST, CODE, ELEMENT_TRANSFORMERS, HEADING, HIGHLIGHT, INLINE_CODE, ITALIC_STAR, ITALIC_UNDERSCORE, LINK, ORDERED_LIST, QUOTE, STRIKETHROUGH, TEXT_FORMAT_TRANSFORMERS, TEXT_MATCH_TRANSFORMERS, TRANSFORMERS, UNORDERED_LIST, registerMarkdownShortcuts };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,gBAAgB,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,gBAAgB,EAAEC,gBAAgB,EAAEC,aAAa,EAAEC,eAAe,EAAEC,oBAAoB,EAAEC,oBAAoB,EAAEC,iBAAiB,EAAEC,mBAAmB,EAAEC,qBAAqB,EAAEC,aAAa,QAAQ,SAAS;AAC/Q,SAASC,eAAe,EAAEC,WAAW,EAAEC,QAAQ,QAAQ,eAAe;AACtE,SAASC,WAAW,EAAEC,eAAe,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,mBAAmB,EAAEC,eAAe,QAAQ,eAAe;AAC1H,SAASC,YAAY,EAAEC,WAAW,EAAEC,cAAc,EAAEC,SAAS,EAAEC,gBAAgB,EAAEC,kBAAkB,QAAQ,oBAAoB;AAC/H,SAASC,mBAAmB,QAAQ,gBAAgB;AACpD,SAASC,QAAQ,EAAEC,WAAW,EAAEC,eAAe,QAAQ,eAAe;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,OAAOA,CAACC,IAAI,EAAEC,QAAQ,EAAE;EAC/B,MAAMC,KAAK,GAAG,CAAC,CAAC;EAChB,KAAK,MAAMC,IAAI,IAAIH,IAAI,EAAE;IACvB,MAAMI,GAAG,GAAGH,QAAQ,CAACE,IAAI,CAAC;IAC1B,IAAID,KAAK,CAACE,GAAG,CAAC,EAAE;MACdF,KAAK,CAACE,GAAG,CAAC,CAACC,IAAI,CAACF,IAAI,CAAC;IACvB,CAAC,MAAM;MACLD,KAAK,CAACE,GAAG,CAAC,GAAG,CAACD,IAAI,CAAC;IACrB;EACF;EACA,OAAOD,KAAK;AACd;AACA,SAASI,kBAAkBA,CAACC,YAAY,EAAE;EACxC,MAAMC,MAAM,GAAGT,OAAO,CAACQ,YAAY,EAAEE,CAAC,IAAIA,CAAC,CAACC,IAAI,CAAC;EACjD,OAAO;IACLC,OAAO,EAAEH,MAAM,CAACG,OAAO,IAAI,EAAE;IAC7BC,UAAU,EAAEJ,MAAM,CAAC,aAAa,CAAC,IAAI,EAAE;IACvCK,SAAS,EAAEL,MAAM,CAAC,YAAY,CAAC,IAAI;EACrC,CAAC;AACH;AACA,MAAMM,oBAAoB,GAAG,kBAAkB;AAC/C,MAAMC,2BAA2B,GAAG,WAAW;AAC/C,SAASC,gBAAgBA,CAACC,IAAI,EAAE;EAC9B,IAAI,CAACnD,gBAAgB,CAACmD,IAAI,CAAC,EAAE;IAC3B,OAAO,KAAK;EACd;EACA,MAAMC,UAAU,GAAGD,IAAI,CAACE,aAAa,CAAC,CAAC;EACvC,OAAOD,UAAU,IAAI,IAAI,IAAID,IAAI,CAACG,eAAe,CAAC,CAAC,KAAK,CAAC,IAAIrD,WAAW,CAACmD,UAAU,CAAC,IAAIH,2BAA2B,CAACM,IAAI,CAACH,UAAU,CAACI,cAAc,CAAC,CAAC,CAAC;AACvJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA,SAASC,oBAAoBA,CAAChB,YAAY,EAAkC;EAAA,IAAhCiB,sBAAsB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACxE,MAAMjB,MAAM,GAAGF,kBAAkB,CAACC,YAAY,CAAC;EAC/C,MAAMqB,kBAAkB,GAAG,CAACJ,sBAAsB;;EAElD;EACA;EACA,MAAMK,sBAAsB,GAAGrB,MAAM,CAACI,UAAU,CAACkB,MAAM,CAACC,WAAW,IAAIA,WAAW,CAACC,MAAM,CAACN,MAAM,KAAK,CAAC,CAAC;EACvG,OAAOT,IAAI,IAAI;IACb,MAAMgB,MAAM,GAAG,EAAE;IACjB,MAAMC,QAAQ,GAAG,CAACjB,IAAI,IAAIjD,QAAQ,CAAC,CAAC,EAAEmE,WAAW,CAAC,CAAC;IACnD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,QAAQ,CAACR,MAAM,EAAEU,CAAC,EAAE,EAAE;MACxC,MAAMC,KAAK,GAAGH,QAAQ,CAACE,CAAC,CAAC;MACzB,MAAME,MAAM,GAAGC,sBAAsB,CAACF,KAAK,EAAE7B,MAAM,CAACG,OAAO,EAAEkB,sBAAsB,EAAErB,MAAM,CAACK,SAAS,CAAC;MACtG,IAAIyB,MAAM,IAAI,IAAI,EAAE;QAClBL,MAAM,CAAC5B,IAAI;QACX;QACAuB,kBAAkB,IAAIQ,CAAC,GAAG,CAAC,IAAI,CAACpB,gBAAgB,CAACqB,KAAK,CAAC,IAAI,CAACrB,gBAAgB,CAACkB,QAAQ,CAACE,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,IAAI,CAACI,MAAM,CAACF,MAAM,CAAC,GAAGA,MAAM,CAAC;MAC/H;IACF;IACA;IACA;IACA,OAAOL,MAAM,CAACQ,IAAI,CAAC,IAAI,CAAC;EAC1B,CAAC;AACH;AACA,SAASF,sBAAsBA,CAACtB,IAAI,EAAEyB,mBAAmB,EAAEC,qBAAqB,EAAEC,qBAAqB,EAAE;EACvG,KAAK,MAAMb,WAAW,IAAIW,mBAAmB,EAAE;IAC7C,MAAMJ,MAAM,GAAGP,WAAW,CAACc,MAAM,CAAC5B,IAAI,EAAE6B,KAAK,IAAIC,cAAc,CAACD,KAAK,EAAEH,qBAAqB,EAAEC,qBAAqB,CAAC,CAAC;IACrH,IAAIN,MAAM,IAAI,IAAI,EAAE;MAClB,OAAOA,MAAM;IACf;EACF;EACA,IAAIrE,cAAc,CAACgD,IAAI,CAAC,EAAE;IACxB,OAAO8B,cAAc,CAAC9B,IAAI,EAAE0B,qBAAqB,EAAEC,qBAAqB,CAAC;EAC3E,CAAC,MAAM,IAAI1E,gBAAgB,CAAC+C,IAAI,CAAC,EAAE;IACjC,OAAOA,IAAI,CAACK,cAAc,CAAC,CAAC;EAC9B,CAAC,MAAM;IACL,OAAO,IAAI;EACb;AACF;AACA,SAASyB,cAAcA,CAAC9B,IAAI,EAAE0B,qBAAqB,EAAEC,qBAAqB,EAAE;EAC1E,MAAMX,MAAM,GAAG,EAAE;EACjB,MAAMC,QAAQ,GAAGjB,IAAI,CAACkB,WAAW,CAAC,CAAC;EACnCa,QAAQ,EAAE,KAAK,MAAMX,KAAK,IAAIH,QAAQ,EAAE;IACtC,KAAK,MAAMH,WAAW,IAAIa,qBAAqB,EAAE;MAC/C,MAAMN,MAAM,GAAGP,WAAW,CAACc,MAAM,CAACR,KAAK,EAAEY,UAAU,IAAIF,cAAc,CAACE,UAAU,EAAEN,qBAAqB,EAAEC,qBAAqB,CAAC,EAAE,CAACM,QAAQ,EAAEC,WAAW,KAAKC,gBAAgB,CAACF,QAAQ,EAAEC,WAAW,EAAER,qBAAqB,CAAC,CAAC;MAC3N,IAAIL,MAAM,IAAI,IAAI,EAAE;QAClBL,MAAM,CAAC5B,IAAI,CAACiC,MAAM,CAAC;QACnB,SAASU,QAAQ;MACnB;IACF;IACA,IAAI7E,gBAAgB,CAACkE,KAAK,CAAC,EAAE;MAC3BJ,MAAM,CAAC5B,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC,MAAM,IAAItC,WAAW,CAACsE,KAAK,CAAC,EAAE;MAC7BJ,MAAM,CAAC5B,IAAI,CAAC+C,gBAAgB,CAACf,KAAK,EAAEA,KAAK,CAACf,cAAc,CAAC,CAAC,EAAEqB,qBAAqB,CAAC,CAAC;IACrF,CAAC,MAAM,IAAI1E,cAAc,CAACoE,KAAK,CAAC,EAAE;MAChC;MACAJ,MAAM,CAAC5B,IAAI,CAAC0C,cAAc,CAACV,KAAK,EAAEM,qBAAqB,EAAEC,qBAAqB,CAAC,CAAC;IAClF,CAAC,MAAM,IAAI1E,gBAAgB,CAACmE,KAAK,CAAC,EAAE;MAClCJ,MAAM,CAAC5B,IAAI,CAACgC,KAAK,CAACf,cAAc,CAAC,CAAC,CAAC;IACrC;EACF;EACA,OAAOW,MAAM,CAACQ,IAAI,CAAC,EAAE,CAAC;AACxB;AACA,SAASW,gBAAgBA,CAACnC,IAAI,EAAEkC,WAAW,EAAEE,gBAAgB,EAAE;EAC7D;EACA;EACA;EACA;EACA,MAAMC,YAAY,GAAGH,WAAW,CAACI,IAAI,CAAC,CAAC;EACvC,IAAItB,MAAM,GAAGqB,YAAY;EACzB,MAAME,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,KAAK,MAAM1B,WAAW,IAAIsB,gBAAgB,EAAE;IAC1C,MAAMrB,MAAM,GAAGD,WAAW,CAACC,MAAM,CAAC,CAAC,CAAC;IACpC,MAAM0B,GAAG,GAAG3B,WAAW,CAAC2B,GAAG;IAC3B,IAAIC,SAAS,CAAC1C,IAAI,EAAEe,MAAM,CAAC,IAAI,CAACwB,OAAO,CAACI,GAAG,CAAC5B,MAAM,CAAC,EAAE;MACnD;MACAwB,OAAO,CAACK,GAAG,CAAC7B,MAAM,CAAC;MACnB;MACA,MAAM8B,YAAY,GAAGC,cAAc,CAAC9C,IAAI,EAAE,IAAI,CAAC;MAC/C,IAAI,CAAC0C,SAAS,CAACG,YAAY,EAAE9B,MAAM,CAAC,EAAE;QACpCC,MAAM,GAAGyB,GAAG,GAAGzB,MAAM;MACvB;;MAEA;MACA,MAAM+B,QAAQ,GAAGD,cAAc,CAAC9C,IAAI,EAAE,KAAK,CAAC;MAC5C,IAAI,CAAC0C,SAAS,CAACK,QAAQ,EAAEhC,MAAM,CAAC,EAAE;QAChCC,MAAM,IAAIyB,GAAG;MACf;IACF;EACF;;EAEA;EACA,OAAOP,WAAW,CAACc,OAAO,CAACX,YAAY,EAAE,MAAMrB,MAAM,CAAC;AACxD;;AAEA;AACA;AACA,SAAS8B,cAAcA,CAAC9C,IAAI,EAAEiD,QAAQ,EAAE;EACtC,IAAIC,OAAO,GAAGD,QAAQ,GAAGjD,IAAI,CAACmD,kBAAkB,CAAC,CAAC,GAAGnD,IAAI,CAACoD,cAAc,CAAC,CAAC;EAC1E,IAAI,CAACF,OAAO,EAAE;IACZ,MAAMG,MAAM,GAAGrD,IAAI,CAACsD,gBAAgB,CAAC,CAAC;IACtC,IAAID,MAAM,CAACE,QAAQ,CAAC,CAAC,EAAE;MACrBL,OAAO,GAAGD,QAAQ,GAAGI,MAAM,CAACF,kBAAkB,CAAC,CAAC,GAAGE,MAAM,CAACD,cAAc,CAAC,CAAC;IAC5E;EACF;EACA,OAAOF,OAAO,EAAE;IACd,IAAIlG,cAAc,CAACkG,OAAO,CAAC,EAAE;MAC3B,IAAI,CAACA,OAAO,CAACK,QAAQ,CAAC,CAAC,EAAE;QACvB;MACF;MACA,MAAMC,UAAU,GAAGP,QAAQ,GAAGC,OAAO,CAACO,iBAAiB,CAAC,CAAC,GAAGP,OAAO,CAACQ,kBAAkB,CAAC,CAAC;MACxF,IAAI5G,WAAW,CAAC0G,UAAU,CAAC,EAAE;QAC3B,OAAOA,UAAU;MACnB,CAAC,MAAM;QACLN,OAAO,GAAGD,QAAQ,GAAGC,OAAO,CAACC,kBAAkB,CAAC,CAAC,GAAGD,OAAO,CAACE,cAAc,CAAC,CAAC;MAC9E;IACF;IACA,IAAItG,WAAW,CAACoG,OAAO,CAAC,EAAE;MACxB,OAAOA,OAAO;IAChB;IACA,IAAI,CAAClG,cAAc,CAACkG,OAAO,CAAC,EAAE;MAC5B,OAAO,IAAI;IACb;EACF;EACA,OAAO,IAAI;AACb;AACA,SAASR,SAASA,CAAC1C,IAAI,EAAEe,MAAM,EAAE;EAC/B,OAAOjE,WAAW,CAACkD,IAAI,CAAC,IAAIA,IAAI,CAAC0C,SAAS,CAAC3B,MAAM,CAAC;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM4C,WAAW,GAAG,OAAOC,MAAM,KAAK,WAAW,IAAI,OAAOA,MAAM,CAACC,QAAQ,KAAK,WAAW,IAAI,OAAOD,MAAM,CAACC,QAAQ,CAACC,aAAa,KAAK,WAAW;;AAEnJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,YAAY,GAAGJ,WAAW,IAAI,cAAc,IAAIE,QAAQ,GAAGA,QAAQ,CAACE,YAAY,GAAG,IAAI;AAC7FJ,WAAW,IAAI,YAAY,IAAIC,MAAM,IAAI,CAACG,YAAY,GAAG,iBAAiB,IAAI,IAAIH,MAAM,CAACI,UAAU,CAAC,OAAO,CAAC,GAAG,KAAK;AACpH,MAAMC,SAAS,GAAGN,WAAW,IAAI,yBAAyB,CAACvD,IAAI,CAAC8D,SAAS,CAACC,SAAS,CAAC;AACpF,MAAMC,MAAM,GAAGT,WAAW,IAAI,kBAAkB,CAACvD,IAAI,CAAC8D,SAAS,CAACC,SAAS,CAAC,IAAI,CAACP,MAAM,CAACS,QAAQ;;AAE9F;AACA;AACA,MAAMC,SAAS,GAAGX,WAAW,IAAI,kBAAkB,CAACvD,IAAI,CAAC8D,SAAS,CAACC,SAAS,CAAC;AAC7E,MAAMI,eAAe,GAAGZ,WAAW,IAAI,qBAAqB,CAACvD,IAAI,CAAC8D,SAAS,CAACC,SAAS,CAAC,IAAI,CAACG,SAAS;;AAEpG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,kBAAkB,GAAG,2BAA2B;AACtD;AACA;AACA;AACA,SAASC,oBAAoBA,CAACnF,YAAY,EAAkC;EAAA,IAAhCiB,sBAAsB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACxE,MAAMjB,MAAM,GAAGF,kBAAkB,CAACC,YAAY,CAAC;EAC/C,MAAMoF,2BAA2B,GAAGC,iCAAiC,CAACpF,MAAM,CAACI,UAAU,CAAC;EACxF,OAAO,CAACiF,cAAc,EAAE5E,IAAI,KAAK;IAC/B,MAAM6E,KAAK,GAAGD,cAAc,CAACE,KAAK,CAAC,IAAI,CAAC;IACxC,MAAMC,WAAW,GAAGF,KAAK,CAACpE,MAAM;IAChC,MAAMuE,IAAI,GAAGhF,IAAI,IAAIjD,QAAQ,CAAC,CAAC;IAC/BiI,IAAI,CAACC,KAAK,CAAC,CAAC;IACZ,KAAK,IAAI9D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4D,WAAW,EAAE5D,CAAC,EAAE,EAAE;MACpC,MAAM+D,QAAQ,GAAGL,KAAK,CAAC1D,CAAC,CAAC;MACzB;MACA;MACA;MACA;MACA,MAAM,CAACgE,aAAa,EAAEC,YAAY,CAAC,GAAGC,gBAAgB,CAACR,KAAK,EAAE1D,CAAC,EAAE6D,IAAI,CAAC;MACtE,IAAIG,aAAa,IAAI,IAAI,EAAE;QACzBhE,CAAC,GAAGiE,YAAY;QAChB;MACF;MACAE,aAAa,CAACJ,QAAQ,EAAEF,IAAI,EAAEzF,MAAM,CAACG,OAAO,EAAEgF,2BAA2B,EAAEnF,MAAM,CAACK,SAAS,CAAC;IAC9F;;IAEA;IACA;IACA;IACA,MAAMqB,QAAQ,GAAG+D,IAAI,CAAC9D,WAAW,CAAC,CAAC;IACnC,KAAK,MAAME,KAAK,IAAIH,QAAQ,EAAE;MAC5B,IAAI,CAACV,sBAAsB,IAAIR,gBAAgB,CAACqB,KAAK,CAAC,IAAI4D,IAAI,CAAC7E,eAAe,CAAC,CAAC,GAAG,CAAC,EAAE;QACpFiB,KAAK,CAACmE,MAAM,CAAC,CAAC;MAChB;IACF;IACA,IAAIpI,aAAa,CAAC,CAAC,KAAK,IAAI,EAAE;MAC5B6H,IAAI,CAACQ,WAAW,CAAC,CAAC;IACpB;EACF,CAAC;AACH;AACA,SAASF,aAAaA,CAACJ,QAAQ,EAAEO,QAAQ,EAAEhE,mBAAmB,EAAEiD,2BAA2B,EAAE/C,qBAAqB,EAAE;EAClH,MAAMM,QAAQ,GAAG7E,eAAe,CAAC8H,QAAQ,CAAC;EAC1C,MAAMQ,WAAW,GAAGrI,oBAAoB,CAAC,CAAC;EAC1CqI,WAAW,CAACC,MAAM,CAAC1D,QAAQ,CAAC;EAC5BwD,QAAQ,CAACE,MAAM,CAACD,WAAW,CAAC;EAC5B,KAAK,MAAM;IACTE,MAAM;IACN5C;EACF,CAAC,IAAIvB,mBAAmB,EAAE;IACxB,MAAMoE,KAAK,GAAGX,QAAQ,CAACW,KAAK,CAACD,MAAM,CAAC;IACpC,IAAIC,KAAK,EAAE;MACT5D,QAAQ,CAAC6D,cAAc,CAACZ,QAAQ,CAACa,KAAK,CAACF,KAAK,CAAC,CAAC,CAAC,CAACpF,MAAM,CAAC,CAAC;MACxDuC,OAAO,CAAC0C,WAAW,EAAE,CAACzD,QAAQ,CAAC,EAAE4D,KAAK,EAAE,IAAI,CAAC;MAC7C;IACF;EACF;EACAG,4BAA4B,CAAC/D,QAAQ,EAAEyC,2BAA2B,EAAE/C,qBAAqB,CAAC;;EAE1F;EACA;EACA;EACA,IAAI+D,WAAW,CAACO,UAAU,CAAC,CAAC,IAAIf,QAAQ,CAACzE,MAAM,GAAG,CAAC,EAAE;IACnD,MAAMoC,YAAY,GAAG6C,WAAW,CAACvC,kBAAkB,CAAC,CAAC;IACrD,IAAItG,gBAAgB,CAACgG,YAAY,CAAC,IAAIzE,YAAY,CAACyE,YAAY,CAAC,IAAI/E,WAAW,CAAC+E,YAAY,CAAC,EAAE;MAC7F,IAAIqD,UAAU,GAAGrD,YAAY;MAC7B,IAAI/E,WAAW,CAAC+E,YAAY,CAAC,EAAE;QAC7B,MAAMsD,cAAc,GAAGtD,YAAY,CAACY,iBAAiB,CAAC,CAAC;QACvD,IAAI0C,cAAc,IAAI,IAAI,EAAE;UAC1BD,UAAU,GAAG,IAAI;QACnB,CAAC,MAAM;UACLA,UAAU,GAAGxH,mBAAmB,CAACyH,cAAc,EAAEpI,eAAe,CAAC;QACnE;MACF;MACA,IAAImI,UAAU,IAAI,IAAI,IAAIA,UAAU,CAACE,kBAAkB,CAAC,CAAC,GAAG,CAAC,EAAE;QAC7DF,UAAU,CAACG,MAAM,CAACH,UAAU,CAAC/F,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC7C,oBAAoB,CAAC,CAAC,EAAE,GAAGoI,WAAW,CAACxE,WAAW,CAAC,CAAC,CAAC,CAAC;QAC1GwE,WAAW,CAACH,MAAM,CAAC,CAAC;MACtB;IACF;EACF;AACF;AACA,SAASF,gBAAgBA,CAACR,KAAK,EAAEyB,cAAc,EAAEb,QAAQ,EAAE;EACzD,MAAMc,SAAS,GAAG1B,KAAK,CAACyB,cAAc,CAAC,CAACT,KAAK,CAACrB,kBAAkB,CAAC;EACjE,IAAI+B,SAAS,EAAE;IACb,IAAIC,YAAY,GAAGF,cAAc;IACjC,MAAMvB,WAAW,GAAGF,KAAK,CAACpE,MAAM;IAChC,OAAO,EAAE+F,YAAY,GAAGzB,WAAW,EAAE;MACnC,MAAM0B,UAAU,GAAG5B,KAAK,CAAC2B,YAAY,CAAC,CAACX,KAAK,CAACrB,kBAAkB,CAAC;MAChE,IAAIiC,UAAU,EAAE;QACd,MAAMtB,aAAa,GAAGxH,eAAe,CAAC4I,SAAS,CAAC,CAAC,CAAC,CAAC;QACnD,MAAMtE,QAAQ,GAAG7E,eAAe,CAACyH,KAAK,CAACkB,KAAK,CAACO,cAAc,GAAG,CAAC,EAAEE,YAAY,CAAC,CAAChF,IAAI,CAAC,IAAI,CAAC,CAAC;QAC1F2D,aAAa,CAACQ,MAAM,CAAC1D,QAAQ,CAAC;QAC9BwD,QAAQ,CAACE,MAAM,CAACR,aAAa,CAAC;QAC9B,OAAO,CAACA,aAAa,EAAEqB,YAAY,CAAC;MACtC;IACF;EACF;EACA,OAAO,CAAC,IAAI,EAAEF,cAAc,CAAC;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,4BAA4BA,CAAC/D,QAAQ,EAAEyC,2BAA2B,EAAE/C,qBAAqB,EAAE;EAClG,MAAMO,WAAW,GAAGD,QAAQ,CAAC5B,cAAc,CAAC,CAAC;EAC7C,MAAMwF,KAAK,GAAGa,kBAAkB,CAACxE,WAAW,EAAEwC,2BAA2B,CAAC;EAC1E,IAAI,CAACmB,KAAK,EAAE;IACV;IACA;IACAc,2BAA2B,CAAC1E,QAAQ,EAAEN,qBAAqB,CAAC;IAC5D;EACF;EACA,IAAIiF,WAAW,EAAEC,aAAa,EAAEC,WAAW;;EAE3C;EACA;EACA;EACA,IAAIjB,KAAK,CAAC,CAAC,CAAC,KAAK3D,WAAW,EAAE;IAC5B0E,WAAW,GAAG3E,QAAQ;EACxB,CAAC,MAAM;IACL,MAAM8E,UAAU,GAAGlB,KAAK,CAAC5G,KAAK,IAAI,CAAC;IACnC,MAAM+H,QAAQ,GAAGD,UAAU,GAAGlB,KAAK,CAAC,CAAC,CAAC,CAACpF,MAAM;IAC7C,IAAIsG,UAAU,KAAK,CAAC,EAAE;MACpB,CAACH,WAAW,EAAEC,aAAa,CAAC,GAAG5E,QAAQ,CAACgF,SAAS,CAACD,QAAQ,CAAC;IAC7D,CAAC,MAAM;MACL,CAACF,WAAW,EAAEF,WAAW,EAAEC,aAAa,CAAC,GAAG5E,QAAQ,CAACgF,SAAS,CAACF,UAAU,EAAEC,QAAQ,CAAC;IACtF;EACF;EACAJ,WAAW,CAACd,cAAc,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;EACpC,MAAM/E,WAAW,GAAG4D,2BAA2B,CAACwC,iBAAiB,CAACrB,KAAK,CAAC,CAAC,CAAC,CAAC;EAC3E,IAAI/E,WAAW,EAAE;IACf,KAAK,MAAMC,MAAM,IAAID,WAAW,CAACC,MAAM,EAAE;MACvC,IAAI,CAAC6F,WAAW,CAAClE,SAAS,CAAC3B,MAAM,CAAC,EAAE;QAClC6F,WAAW,CAACO,YAAY,CAACpG,MAAM,CAAC;MAClC;IACF;EACF;;EAEA;EACA,IAAI,CAAC6F,WAAW,CAAClE,SAAS,CAAC,MAAM,CAAC,EAAE;IAClCsD,4BAA4B,CAACY,WAAW,EAAElC,2BAA2B,EAAE/C,qBAAqB,CAAC;EAC/F;;EAEA;EACA,IAAImF,WAAW,EAAE;IACfd,4BAA4B,CAACc,WAAW,EAAEpC,2BAA2B,EAAE/C,qBAAqB,CAAC;EAC/F;EACA,IAAIkF,aAAa,EAAE;IACjBb,4BAA4B,CAACa,aAAa,EAAEnC,2BAA2B,EAAE/C,qBAAqB,CAAC;EACjG;AACF;AACA,SAASgF,2BAA2BA,CAACS,SAAS,EAAEzF,qBAAqB,EAAE;EACrE,IAAIM,QAAQ,GAAGmF,SAAS;EACxBrF,QAAQ,EAAE,OAAOE,QAAQ,EAAE;IACzB,KAAK,MAAMnB,WAAW,IAAIa,qBAAqB,EAAE;MAC/C,MAAMkE,KAAK,GAAG5D,QAAQ,CAAC5B,cAAc,CAAC,CAAC,CAACwF,KAAK,CAAC/E,WAAW,CAACuG,YAAY,CAAC;MACvE,IAAI,CAACxB,KAAK,EAAE;QACV;MACF;MACA,MAAMkB,UAAU,GAAGlB,KAAK,CAAC5G,KAAK,IAAI,CAAC;MACnC,MAAM+H,QAAQ,GAAGD,UAAU,GAAGlB,KAAK,CAAC,CAAC,CAAC,CAACpF,MAAM;MAC7C,IAAI6G,WAAW,EAAEC,WAAW;MAC5B,IAAIR,UAAU,KAAK,CAAC,EAAE;QACpB,CAACO,WAAW,EAAErF,QAAQ,CAAC,GAAGA,QAAQ,CAACgF,SAAS,CAACD,QAAQ,CAAC;MACxD,CAAC,MAAM;QACL,GAAGM,WAAW,EAAEC,WAAW,CAAC,GAAGtF,QAAQ,CAACgF,SAAS,CAACF,UAAU,EAAEC,QAAQ,CAAC;MACzE;MACA,IAAIO,WAAW,EAAE;QACfZ,2BAA2B,CAACY,WAAW,EAAE5F,qBAAqB,CAAC;MACjE;MACAb,WAAW,CAACkC,OAAO,CAACsE,WAAW,EAAEzB,KAAK,CAAC;MACvC,SAAS9D,QAAQ;IACnB;IACA;EACF;AACF;;AAEA;AACA,SAAS2E,kBAAkBA,CAACxE,WAAW,EAAER,qBAAqB,EAAE;EAC9D,MAAM8F,aAAa,GAAGtF,WAAW,CAAC2D,KAAK,CAACnE,qBAAqB,CAAC+F,cAAc,CAAC;EAC7E,IAAID,aAAa,IAAI,IAAI,EAAE;IACzB,OAAO,IAAI;EACb;EACA,KAAK,MAAM3B,KAAK,IAAI2B,aAAa,EAAE;IACjC;IACA;IACA,MAAM/E,GAAG,GAAGoD,KAAK,CAAC7C,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IACpC,MAAM0E,eAAe,GAAGhG,qBAAqB,CAACiG,oBAAoB,CAAClF,GAAG,CAAC;IACvE,IAAIiF,eAAe,IAAI,IAAI,EAAE;MAC3B;IACF;IACA,MAAME,SAAS,GAAG1F,WAAW,CAAC2D,KAAK,CAAC6B,eAAe,CAAC;IACpD,MAAM5G,WAAW,GAAGY,qBAAqB,CAACwF,iBAAiB,CAACzE,GAAG,CAAC;IAChE,IAAImF,SAAS,IAAI,IAAI,IAAI9G,WAAW,IAAI,IAAI,EAAE;MAC5C,IAAIA,WAAW,CAAC+G,SAAS,KAAK,KAAK,EAAE;QACnC,OAAOD,SAAS;MAClB;;MAEA;MACA;MACA,MAAM;QACJ3I,KAAK,GAAG;MACV,CAAC,GAAG2I,SAAS;MACb,MAAME,UAAU,GAAG5F,WAAW,CAACjD,KAAK,GAAG,CAAC,CAAC;MACzC,MAAM8I,SAAS,GAAG7F,WAAW,CAACjD,KAAK,GAAG2I,SAAS,CAAC,CAAC,CAAC,CAACnH,MAAM,CAAC;MAC1D,IAAI,CAAC,CAACqH,UAAU,IAAIjI,oBAAoB,CAACO,IAAI,CAAC0H,UAAU,CAAC,MAAM,CAACC,SAAS,IAAIlI,oBAAoB,CAACO,IAAI,CAAC2H,SAAS,CAAC,CAAC,EAAE;QAClH,OAAOH,SAAS;MAClB;IACF;EACF;EACA,OAAO,IAAI;AACb;AACA,SAASjD,iCAAiCA,CAACvC,gBAAgB,EAAE;EAC3D,MAAM8E,iBAAiB,GAAG,CAAC,CAAC;EAC5B,MAAMS,oBAAoB,GAAG,CAAC,CAAC;EAC/B,MAAMF,cAAc,GAAG,EAAE;EACzB,MAAMO,YAAY,GAAG,aAAa;EAClC,KAAK,MAAMlH,WAAW,IAAIsB,gBAAgB,EAAE;IAC1C,MAAM;MACJK;IACF,CAAC,GAAG3B,WAAW;IACfoG,iBAAiB,CAACzE,GAAG,CAAC,GAAG3B,WAAW;IACpC,MAAMmH,SAAS,GAAGxF,GAAG,CAACO,OAAO,CAAC,aAAa,EAAE,MAAM,CAAC;IACpDyE,cAAc,CAACrI,IAAI,CAAC6I,SAAS,CAAC;IAC9B,IAAIhE,SAAS,IAAIG,MAAM,IAAIG,eAAe,EAAE;MAC1CoD,oBAAoB,CAAClF,GAAG,CAAC,GAAG,IAAIyF,MAAM,CAAC,IAAID,SAAS,QAAQA,SAAS,cAAcA,SAAS,QAAQA,SAAS,MAAMA,SAAS,GAAG,CAAC;IAClI,CAAC,MAAM;MACLN,oBAAoB,CAAClF,GAAG,CAAC,GAAG,IAAIyF,MAAM,CAAC,YAAYD,SAAS,MAAMA,SAAS,UAAUA,SAAS,UAAUA,SAAS,YAAYA,SAAS,gCAAgCA,SAAS,YAAYA,SAAS,IAAI,CAAC;IAC3M;EACF;EACA,OAAO;IACL;IACAN,oBAAoB;IACpB;IACAF,cAAc,EAAE,IAAIS,MAAM,CAAC,CAACjE,SAAS,IAAIG,MAAM,IAAIG,eAAe,GAAG,EAAE,GAAG,GAAGyD,YAAY,EAAE,IAAI,GAAG,GAAGP,cAAc,CAACjG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,EAAE,GAAG,CAAC;IACzI0F;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASiB,sBAAsBA,CAACnG,UAAU,EAAEoG,UAAU,EAAEC,YAAY,EAAE5G,mBAAmB,EAAE;EACzF,MAAM6G,eAAe,GAAGtG,UAAU,CAACuG,SAAS,CAAC,CAAC;EAC9C,IAAI,CAAC/K,mBAAmB,CAAC8K,eAAe,CAAC,IAAItG,UAAU,CAAC9B,aAAa,CAAC,CAAC,KAAKkI,UAAU,EAAE;IACtF,OAAO,KAAK;EACd;EACA,MAAMlG,WAAW,GAAGkG,UAAU,CAAC/H,cAAc,CAAC,CAAC;;EAE/C;EACA;EACA;EACA;EACA;EACA;EACA,IAAI6B,WAAW,CAACmG,YAAY,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;IACzC,OAAO,KAAK;EACd;EACA,KAAK,MAAM;IACTzC,MAAM;IACN5C;EACF,CAAC,IAAIvB,mBAAmB,EAAE;IACxB,MAAMoE,KAAK,GAAG3D,WAAW,CAAC2D,KAAK,CAACD,MAAM,CAAC;IACvC,IAAIC,KAAK,IAAIA,KAAK,CAAC,CAAC,CAAC,CAACpF,MAAM,KAAK4H,YAAY,EAAE;MAC7C,MAAMG,YAAY,GAAGJ,UAAU,CAACK,eAAe,CAAC,CAAC;MACjD,MAAM,CAAC3B,WAAW,EAAED,aAAa,CAAC,GAAGuB,UAAU,CAACnB,SAAS,CAACoB,YAAY,CAAC;MACvEvB,WAAW,CAACvB,MAAM,CAAC,CAAC;MACpB,MAAMmD,QAAQ,GAAG7B,aAAa,GAAG,CAACA,aAAa,EAAE,GAAG2B,YAAY,CAAC,GAAGA,YAAY;MAChFxF,OAAO,CAAChB,UAAU,EAAE0G,QAAQ,EAAE7C,KAAK,EAAE,KAAK,CAAC;MAC3C,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AACA,SAAS8C,wBAAwBA,CAACP,UAAU,EAAEC,YAAY,EAAEO,qBAAqB,EAAE;EACjF,IAAI1G,WAAW,GAAGkG,UAAU,CAAC/H,cAAc,CAAC,CAAC;EAC7C,MAAMwI,QAAQ,GAAG3G,WAAW,CAACmG,YAAY,GAAG,CAAC,CAAC;EAC9C,MAAM/I,YAAY,GAAGsJ,qBAAqB,CAACC,QAAQ,CAAC;EACpD,IAAIvJ,YAAY,IAAI,IAAI,EAAE;IACxB,OAAO,KAAK;EACd;;EAEA;EACA;EACA,IAAI+I,YAAY,GAAGnG,WAAW,CAACzB,MAAM,EAAE;IACrCyB,WAAW,GAAGA,WAAW,CAAC6D,KAAK,CAAC,CAAC,EAAEsC,YAAY,CAAC;EAClD;EACA,KAAK,MAAMvH,WAAW,IAAIxB,YAAY,EAAE;IACtC,MAAMuG,KAAK,GAAG3D,WAAW,CAAC2D,KAAK,CAAC/E,WAAW,CAAC8E,MAAM,CAAC;IACnD,IAAIC,KAAK,KAAK,IAAI,EAAE;MAClB;IACF;IACA,MAAMkB,UAAU,GAAGlB,KAAK,CAAC5G,KAAK,IAAI,CAAC;IACnC,MAAM+H,QAAQ,GAAGD,UAAU,GAAGlB,KAAK,CAAC,CAAC,CAAC,CAACpF,MAAM;IAC7C,IAAI6G,WAAW;IACf,IAAIP,UAAU,KAAK,CAAC,EAAE;MACpB,CAACO,WAAW,CAAC,GAAGc,UAAU,CAACnB,SAAS,CAACD,QAAQ,CAAC;IAChD,CAAC,MAAM;MACL,GAAGM,WAAW,CAAC,GAAGc,UAAU,CAACnB,SAAS,CAACF,UAAU,EAAEC,QAAQ,CAAC;IAC9D;IACAM,WAAW,CAACwB,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC;IAC5BhI,WAAW,CAACkC,OAAO,CAACsE,WAAW,EAAEzB,KAAK,CAAC;IACvC,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AACA,SAASkD,0BAA0BA,CAACX,UAAU,EAAEC,YAAY,EAAEzH,sBAAsB,EAAE;EACpF,MAAMsB,WAAW,GAAGkG,UAAU,CAAC/H,cAAc,CAAC,CAAC;EAC/C,MAAM2I,gBAAgB,GAAGX,YAAY,GAAG,CAAC;EACzC,MAAMY,SAAS,GAAG/G,WAAW,CAAC8G,gBAAgB,CAAC;EAC/C;EACA,MAAME,QAAQ,GAAGtI,sBAAsB,CAACqI,SAAS,CAAC;EAClD,IAAI,CAACC,QAAQ,EAAE;IACb,OAAO,KAAK;EACd;EACA,KAAK,MAAMC,OAAO,IAAID,QAAQ,EAAE;IAC9B,MAAM;MACJzG;IACF,CAAC,GAAG0G,OAAO;IACX,MAAMC,SAAS,GAAG3G,GAAG,CAAChC,MAAM;IAC5B,MAAM4I,kBAAkB,GAAGL,gBAAgB,GAAGI,SAAS,GAAG,CAAC;;IAE3D;IACA,IAAIA,SAAS,GAAG,CAAC,EAAE;MACjB,IAAI,CAACE,gBAAgB,CAACpH,WAAW,EAAEmH,kBAAkB,EAAE5G,GAAG,EAAE,CAAC,EAAE2G,SAAS,CAAC,EAAE;QACzE;MACF;IACF;;IAEA;IACA,IAAIlH,WAAW,CAACmH,kBAAkB,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MAC/C;IACF;;IAEA;IACA,MAAME,iBAAiB,GAAGrH,WAAW,CAAC8G,gBAAgB,GAAG,CAAC,CAAC;IAC3D,IAAIG,OAAO,CAACtB,SAAS,KAAK,KAAK,IAAI0B,iBAAiB,IAAI,CAAC1J,oBAAoB,CAACO,IAAI,CAACmJ,iBAAiB,CAAC,EAAE;MACrG;IACF;IACA,MAAMC,SAAS,GAAGpB,UAAU;IAC5B,IAAIqB,QAAQ,GAAGD,SAAS;IACxB,IAAIE,iBAAiB,GAAGC,oBAAoB,CAACzH,WAAW,EAAEmH,kBAAkB,EAAE5G,GAAG,CAAC;;IAElF;IACA;IACA,IAAIS,OAAO,GAAGuG,QAAQ;IACtB,OAAOC,iBAAiB,GAAG,CAAC,KAAKxG,OAAO,GAAGA,OAAO,CAACC,kBAAkB,CAAC,CAAC,CAAC,EAAE;MACxE,IAAIjG,gBAAgB,CAACgG,OAAO,CAAC,EAAE;QAC7B;MACF;MACA,IAAIpG,WAAW,CAACoG,OAAO,CAAC,EAAE;QACxB,MAAM0G,kBAAkB,GAAG1G,OAAO,CAAC7C,cAAc,CAAC,CAAC;QACnDoJ,QAAQ,GAAGvG,OAAO;QAClBwG,iBAAiB,GAAGC,oBAAoB,CAACC,kBAAkB,EAAEA,kBAAkB,CAACnJ,MAAM,EAAEgC,GAAG,CAAC;MAC9F;IACF;;IAEA;IACA,IAAIiH,iBAAiB,GAAG,CAAC,EAAE;MACzB;IACF;;IAEA;IACA,IAAID,QAAQ,KAAKD,SAAS,IAAIE,iBAAiB,GAAGN,SAAS,KAAKC,kBAAkB,EAAE;MAClF;IACF;;IAEA;IACA,MAAMQ,gBAAgB,GAAGJ,QAAQ,CAACpJ,cAAc,CAAC,CAAC;IAClD,IAAIqJ,iBAAiB,GAAG,CAAC,IAAIG,gBAAgB,CAACH,iBAAiB,GAAG,CAAC,CAAC,KAAKT,SAAS,EAAE;MAClF;IACF;;IAEA;IACA,MAAMa,iBAAiB,GAAGD,gBAAgB,CAACH,iBAAiB,GAAG,CAAC,CAAC;IACjE,IAAIP,OAAO,CAACtB,SAAS,KAAK,KAAK,IAAIiC,iBAAiB,IAAI,CAACjK,oBAAoB,CAACO,IAAI,CAAC0J,iBAAiB,CAAC,EAAE;MACrG;IACF;;IAEA;IACA;IACA,MAAMC,iBAAiB,GAAGP,SAAS,CAACnJ,cAAc,CAAC,CAAC;IACpD,MAAM2J,aAAa,GAAGD,iBAAiB,CAAChE,KAAK,CAAC,CAAC,EAAEsD,kBAAkB,CAAC,GAAGU,iBAAiB,CAAChE,KAAK,CAACiD,gBAAgB,GAAG,CAAC,CAAC;IACpHQ,SAAS,CAAC1D,cAAc,CAACkE,aAAa,CAAC;IACvC,MAAMC,YAAY,GAAGR,QAAQ,KAAKD,SAAS,GAAGQ,aAAa,GAAGH,gBAAgB;IAC9EJ,QAAQ,CAAC3D,cAAc,CAACmE,YAAY,CAAClE,KAAK,CAAC,CAAC,EAAE2D,iBAAiB,CAAC,GAAGO,YAAY,CAAClE,KAAK,CAAC2D,iBAAiB,GAAGN,SAAS,CAAC,CAAC;IACrH,MAAMc,SAAS,GAAG/M,aAAa,CAAC,CAAC;IACjC,MAAMgN,aAAa,GAAG1M,qBAAqB,CAAC,CAAC;IAC7CC,aAAa,CAACyM,aAAa,CAAC;IAC5B;IACA,MAAMC,SAAS,GAAGpB,gBAAgB,GAAGI,SAAS,IAAIK,QAAQ,KAAKD,SAAS,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IACrFW,aAAa,CAACE,MAAM,CAACC,GAAG,CAACb,QAAQ,CAACc,KAAK,EAAEb,iBAAiB,EAAE,MAAM,CAAC;IACnES,aAAa,CAACK,KAAK,CAACF,GAAG,CAACd,SAAS,CAACe,KAAK,EAAEH,SAAS,EAAE,MAAM,CAAC;;IAE3D;IACA,KAAK,MAAMrJ,MAAM,IAAIoI,OAAO,CAACpI,MAAM,EAAE;MACnC,IAAI,CAACoJ,aAAa,CAACzH,SAAS,CAAC3B,MAAM,CAAC,EAAE;QACpCoJ,aAAa,CAACM,UAAU,CAAC1J,MAAM,CAAC;MAClC;IACF;;IAEA;IACAoJ,aAAa,CAACE,MAAM,CAACC,GAAG,CAACH,aAAa,CAACK,KAAK,CAACrL,GAAG,EAAEgL,aAAa,CAACK,KAAK,CAACE,MAAM,EAAEP,aAAa,CAACK,KAAK,CAAC/K,IAAI,CAAC;;IAEvG;IACA,KAAK,MAAMsB,MAAM,IAAIoI,OAAO,CAACpI,MAAM,EAAE;MACnC,IAAIoJ,aAAa,CAACzH,SAAS,CAAC3B,MAAM,CAAC,EAAE;QACnCoJ,aAAa,CAAChD,YAAY,CAACpG,MAAM,CAAC;MACpC;IACF;IACA,IAAIxD,iBAAiB,CAAC2M,SAAS,CAAC,EAAE;MAChCC,aAAa,CAACpJ,MAAM,GAAGmJ,SAAS,CAACnJ,MAAM;IACzC;IACA,OAAO,IAAI;EACb;EACA,OAAO,KAAK;AACd;AACA,SAAS4I,oBAAoBA,CAACgB,MAAM,EAAEC,QAAQ,EAAEnI,GAAG,EAAE;EACnD,MAAM2G,SAAS,GAAG3G,GAAG,CAAChC,MAAM;EAC5B,KAAK,IAAIU,CAAC,GAAGyJ,QAAQ,EAAEzJ,CAAC,IAAIiI,SAAS,EAAEjI,CAAC,EAAE,EAAE;IAC1C,MAAM4F,UAAU,GAAG5F,CAAC,GAAGiI,SAAS;IAChC,IAAIE,gBAAgB,CAACqB,MAAM,EAAE5D,UAAU,EAAEtE,GAAG,EAAE,CAAC,EAAE2G,SAAS,CAAC;IAC3D;IACAuB,MAAM,CAAC5D,UAAU,GAAGqC,SAAS,CAAC,KAAK,GAAG,EAAE;MACtC,OAAOrC,UAAU;IACnB;EACF;EACA,OAAO,CAAC,CAAC;AACX;AACA,SAASuC,gBAAgBA,CAACuB,OAAO,EAAEC,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAEvK,MAAM,EAAE;EAClE,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,EAAEU,CAAC,EAAE,EAAE;IAC/B,IAAI0J,OAAO,CAACC,MAAM,GAAG3J,CAAC,CAAC,KAAK4J,OAAO,CAACC,MAAM,GAAG7J,CAAC,CAAC,EAAE;MAC/C,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb;AACA,SAAS8J,yBAAyBA,CAACC,MAAM,EAA+B;EAAA,IAA7B5L,YAAY,GAAAkB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG2K,YAAY;EACpE,MAAM5L,MAAM,GAAGF,kBAAkB,CAACC,YAAY,CAAC;EAC/C,MAAMoF,2BAA2B,GAAG5F,OAAO,CAACS,MAAM,CAACI,UAAU,EAAEyL,IAAA;IAAA,IAAC;MAC9D3I;IACF,CAAC,GAAA2I,IAAA;IAAA,OAAK3I,GAAG,CAACA,GAAG,CAAChC,MAAM,GAAG,CAAC,CAAC;EAAA,EAAC;EAC1B,MAAM4K,0BAA0B,GAAGvM,OAAO,CAACS,MAAM,CAACK,SAAS,EAAE0L,KAAA;IAAA,IAAC;MAC5DC;IACF,CAAC,GAAAD,KAAA;IAAA,OAAKC,OAAO;EAAA,EAAC;EACd,KAAK,MAAMzK,WAAW,IAAIxB,YAAY,EAAE;IACtC,MAAMG,IAAI,GAAGqB,WAAW,CAACrB,IAAI;IAC7B,IAAIA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,YAAY,EAAE;MAC/C,MAAM+L,YAAY,GAAG1K,WAAW,CAAC0K,YAAY;MAC7C,KAAK,MAAMxL,IAAI,IAAIwL,YAAY,EAAE;QAC/B,IAAI,CAACN,MAAM,CAACO,OAAO,CAACzL,IAAI,CAAC,EAAE;UACzB;YACE,MAAM0L,KAAK,CAAC,yCAAyC1L,IAAI,CAAC2L,OAAO,CAAC,CAAC,gFAAgF,CAAC;UACtJ;QACF;MACF;IACF;EACF;EACA,MAAMC,UAAU,GAAGA,CAAC5J,UAAU,EAAEoG,UAAU,EAAEC,YAAY,KAAK;IAC3D,IAAIF,sBAAsB,CAACnG,UAAU,EAAEoG,UAAU,EAAEC,YAAY,EAAE9I,MAAM,CAACG,OAAO,CAAC,EAAE;MAChF;IACF;IACA,IAAIiJ,wBAAwB,CAACP,UAAU,EAAEC,YAAY,EAAEgD,0BAA0B,CAAC,EAAE;MAClF;IACF;IACAtC,0BAA0B,CAACX,UAAU,EAAEC,YAAY,EAAE3D,2BAA2B,CAAC;EACnF,CAAC;EACD,OAAOwG,MAAM,CAACW,sBAAsB,CAACC,KAAA,IAK/B;IAAA,IALgC;MACpCC,IAAI;MACJC,WAAW;MACXC,WAAW;MACXC;IACF,CAAC,GAAAJ,KAAA;IACC;IACA,IAAIC,IAAI,CAACpJ,GAAG,CAAC,eAAe,CAAC,IAAIoJ,IAAI,CAACpJ,GAAG,CAAC,UAAU,CAAC,EAAE;MACrD;IACF;;IAEA;IACA,IAAIuI,MAAM,CAACiB,WAAW,CAAC,CAAC,EAAE;MACxB;IACF;IACA,MAAMjC,SAAS,GAAG+B,WAAW,CAACG,IAAI,CAACjP,aAAa,CAAC;IACjD,MAAMkP,aAAa,GAAGH,eAAe,CAACE,IAAI,CAACjP,aAAa,CAAC;IACzD,IAAI,CAACI,iBAAiB,CAAC8O,aAAa,CAAC,IAAI,CAAC9O,iBAAiB,CAAC2M,SAAS,CAAC,IAAI,CAACA,SAAS,CAACoC,WAAW,CAAC,CAAC,EAAE;MAClG;IACF;IACA,MAAMC,SAAS,GAAGrC,SAAS,CAACG,MAAM,CAAClL,GAAG;IACtC,MAAMkJ,YAAY,GAAG6B,SAAS,CAACG,MAAM,CAACK,MAAM;IAC5C,MAAMtC,UAAU,GAAG6D,WAAW,CAACO,QAAQ,CAACC,GAAG,CAACF,SAAS,CAAC;IACtD,IAAI,CAACzP,WAAW,CAACsL,UAAU,CAAC,IAAI,CAAC4D,WAAW,CAACrJ,GAAG,CAAC4J,SAAS,CAAC,IAAIlE,YAAY,KAAK,CAAC,IAAIA,YAAY,GAAGgE,aAAa,CAAChC,MAAM,CAACK,MAAM,GAAG,CAAC,EAAE;MACnI;IACF;IACAQ,MAAM,CAACwB,MAAM,CAAC,MAAM;MAClB;MACA,IAAItE,UAAU,CAAC1F,SAAS,CAAC,MAAM,CAAC,EAAE;QAChC;MACF;MACA,MAAMV,UAAU,GAAGoG,UAAU,CAACG,SAAS,CAAC,CAAC;MACzC,IAAIvG,UAAU,KAAK,IAAI,IAAIpE,WAAW,CAACoE,UAAU,CAAC,EAAE;QAClD;MACF;MACA4J,UAAU,CAAC5J,UAAU,EAAEoG,UAAU,EAAE8B,SAAS,CAACG,MAAM,CAACK,MAAM,CAAC;IAC7D,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMiC,eAAe,GAAGC,UAAU,IAAI;EACpC,OAAO,CAAC5K,UAAU,EAAEf,QAAQ,EAAE4E,KAAK,KAAK;IACtC,MAAM7F,IAAI,GAAG4M,UAAU,CAAC/G,KAAK,CAAC;IAC9B7F,IAAI,CAAC2F,MAAM,CAAC,GAAG1E,QAAQ,CAAC;IACxBe,UAAU,CAACgB,OAAO,CAAChD,IAAI,CAAC;IACxBA,IAAI,CAAC6M,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;EACnB,CAAC;AACH,CAAC;;AAED;AACA;AACA,MAAMC,gBAAgB,GAAG,CAAC;AAC1B,SAASC,SAASA,CAACC,WAAW,EAAE;EAC9B,MAAMC,IAAI,GAAGD,WAAW,CAACnH,KAAK,CAAC,KAAK,CAAC;EACrC,MAAMqH,MAAM,GAAGF,WAAW,CAACnH,KAAK,CAAC,IAAI,CAAC;EACtC,IAAIsH,MAAM,GAAG,CAAC;EACd,IAAIF,IAAI,EAAE;IACRE,MAAM,IAAIF,IAAI,CAACxM,MAAM;EACvB;EACA,IAAIyM,MAAM,EAAE;IACVC,MAAM,IAAIC,IAAI,CAACC,KAAK,CAACH,MAAM,CAACzM,MAAM,GAAGqM,gBAAgB,CAAC;EACxD;EACA,OAAOK,MAAM;AACf;AACA,MAAMG,WAAW,GAAGC,QAAQ,IAAI;EAC9B,OAAO,CAACvL,UAAU,EAAEf,QAAQ,EAAE4E,KAAK,KAAK;IACtC,MAAMhD,YAAY,GAAGb,UAAU,CAACmB,kBAAkB,CAAC,CAAC;IACpD,MAAMJ,QAAQ,GAAGf,UAAU,CAACoB,cAAc,CAAC,CAAC;IAC5C,MAAMoK,QAAQ,GAAGtP,mBAAmB,CAACqP,QAAQ,KAAK,OAAO,GAAG1H,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,GAAGnF,SAAS,CAAC;IACzF,IAAI5C,WAAW,CAACiF,QAAQ,CAAC,IAAIA,QAAQ,CAAC0K,WAAW,CAAC,CAAC,KAAKF,QAAQ,EAAE;MAChE,MAAMtN,UAAU,GAAG8C,QAAQ,CAAC7C,aAAa,CAAC,CAAC;MAC3C,IAAID,UAAU,KAAK,IAAI,EAAE;QACvBA,UAAU,CAACyN,YAAY,CAACF,QAAQ,CAAC;MACnC,CAAC,MAAM;QACL;QACAzK,QAAQ,CAAC4C,MAAM,CAAC6H,QAAQ,CAAC;MAC3B;MACAxL,UAAU,CAACuD,MAAM,CAAC,CAAC;IACrB,CAAC,MAAM,IAAIzH,WAAW,CAAC+E,YAAY,CAAC,IAAIA,YAAY,CAAC4K,WAAW,CAAC,CAAC,KAAKF,QAAQ,EAAE;MAC/E1K,YAAY,CAAC8C,MAAM,CAAC6H,QAAQ,CAAC;MAC7BxL,UAAU,CAACuD,MAAM,CAAC,CAAC;IACrB,CAAC,MAAM;MACL,MAAMxG,IAAI,GAAGZ,eAAe,CAACoP,QAAQ,EAAEA,QAAQ,KAAK,QAAQ,GAAGI,MAAM,CAAC9H,KAAK,CAAC,CAAC,CAAC,CAAC,GAAGnF,SAAS,CAAC;MAC5F3B,IAAI,CAAC4G,MAAM,CAAC6H,QAAQ,CAAC;MACrBxL,UAAU,CAACgB,OAAO,CAACjE,IAAI,CAAC;IAC1B;IACAyO,QAAQ,CAAC7H,MAAM,CAAC,GAAG1E,QAAQ,CAAC;IAC5BuM,QAAQ,CAACX,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;IACrB,MAAMM,MAAM,GAAGJ,SAAS,CAAClH,KAAK,CAAC,CAAC,CAAC,CAAC;IAClC,IAAIsH,MAAM,EAAE;MACVK,QAAQ,CAACI,SAAS,CAACT,MAAM,CAAC;IAC5B;EACF,CAAC;AACH,CAAC;AACD,MAAMU,UAAU,GAAGA,CAACC,QAAQ,EAAEhM,cAAc,EAAEiM,KAAK,KAAK;EACtD,MAAM/M,MAAM,GAAG,EAAE;EACjB,MAAMC,QAAQ,GAAG6M,QAAQ,CAAC5M,WAAW,CAAC,CAAC;EACvC,IAAIjC,KAAK,GAAG,CAAC;EACb,KAAK,MAAM+O,YAAY,IAAI/M,QAAQ,EAAE;IACnC,IAAIlD,eAAe,CAACiQ,YAAY,CAAC,EAAE;MACjC,IAAIA,YAAY,CAAC7N,eAAe,CAAC,CAAC,KAAK,CAAC,EAAE;QACxC,MAAMF,UAAU,GAAG+N,YAAY,CAAC9N,aAAa,CAAC,CAAC;QAC/C,IAAIpC,WAAW,CAACmC,UAAU,CAAC,EAAE;UAC3Be,MAAM,CAAC5B,IAAI,CAACyO,UAAU,CAAC5N,UAAU,EAAE6B,cAAc,EAAEiM,KAAK,GAAG,CAAC,CAAC,CAAC;UAC9D;QACF;MACF;MACA,MAAMZ,MAAM,GAAG,GAAG,CAACc,MAAM,CAACF,KAAK,GAAGjB,gBAAgB,CAAC;MACnD,MAAMS,QAAQ,GAAGO,QAAQ,CAACL,WAAW,CAAC,CAAC;MACvC,MAAMS,MAAM,GAAGX,QAAQ,KAAK,QAAQ,GAAG,GAAGO,QAAQ,CAACK,QAAQ,CAAC,CAAC,GAAGlP,KAAK,IAAI,GAAGsO,QAAQ,KAAK,OAAO,GAAG,MAAMS,YAAY,CAACI,UAAU,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,IAAI;MACzJpN,MAAM,CAAC5B,IAAI,CAAC+N,MAAM,GAAGe,MAAM,GAAGpM,cAAc,CAACkM,YAAY,CAAC,CAAC;MAC3D/O,KAAK,EAAE;IACT;EACF;EACA,OAAO+B,MAAM,CAACQ,IAAI,CAAC,IAAI,CAAC;AAC1B,CAAC;AACD,MAAM6M,OAAO,GAAG;EACd7C,YAAY,EAAE,CAACnN,WAAW,CAAC;EAC3BuD,MAAM,EAAEA,CAAC5B,IAAI,EAAE8B,cAAc,KAAK;IAChC,IAAI,CAACxD,cAAc,CAAC0B,IAAI,CAAC,EAAE;MACzB,OAAO,IAAI;IACb;IACA,MAAMsO,KAAK,GAAGX,MAAM,CAAC3N,IAAI,CAACuO,MAAM,CAAC,CAAC,CAACxI,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5C,OAAO,GAAG,CAACkI,MAAM,CAACK,KAAK,CAAC,GAAG,GAAG,GAAGxM,cAAc,CAAC9B,IAAI,CAAC;EACvD,CAAC;EACD4F,MAAM,EAAE,aAAa;EACrB5C,OAAO,EAAE2J,eAAe,CAAC9G,KAAK,IAAI;IAChC,MAAMpD,GAAG,GAAG,GAAG,GAAGoD,KAAK,CAAC,CAAC,CAAC,CAACpF,MAAM;IACjC,OAAOhC,kBAAkB,CAACgE,GAAG,CAAC;EAChC,CAAC,CAAC;EACFhD,IAAI,EAAE;AACR,CAAC;AACD,MAAM+O,KAAK,GAAG;EACZhD,YAAY,EAAE,CAACjN,SAAS,CAAC;EACzBqD,MAAM,EAAEA,CAAC5B,IAAI,EAAE8B,cAAc,KAAK;IAChC,IAAI,CAAC1D,YAAY,CAAC4B,IAAI,CAAC,EAAE;MACvB,OAAO,IAAI;IACb;IACA,MAAM6E,KAAK,GAAG/C,cAAc,CAAC9B,IAAI,CAAC,CAAC8E,KAAK,CAAC,IAAI,CAAC;IAC9C,MAAM9D,MAAM,GAAG,EAAE;IACjB,KAAK,MAAMyN,IAAI,IAAI5J,KAAK,EAAE;MACxB7D,MAAM,CAAC5B,IAAI,CAAC,IAAI,GAAGqP,IAAI,CAAC;IAC1B;IACA,OAAOzN,MAAM,CAACQ,IAAI,CAAC,IAAI,CAAC;EAC1B,CAAC;EACDoE,MAAM,EAAE,MAAM;EACd5C,OAAO,EAAEA,CAAChB,UAAU,EAAEf,QAAQ,EAAEyN,MAAM,EAAEC,QAAQ,KAAK;IACnD,IAAIA,QAAQ,EAAE;MACZ,MAAM9L,YAAY,GAAGb,UAAU,CAACmB,kBAAkB,CAAC,CAAC;MACpD,IAAI/E,YAAY,CAACyE,YAAY,CAAC,EAAE;QAC9BA,YAAY,CAACwD,MAAM,CAACxD,YAAY,CAAC1C,eAAe,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC7C,oBAAoB,CAAC,CAAC,EAAE,GAAG2D,QAAQ,CAAC,CAAC;QAC7F4B,YAAY,CAACgK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;QACzB7K,UAAU,CAACuD,MAAM,CAAC,CAAC;QACnB;MACF;IACF;IACA,MAAMvF,IAAI,GAAGxB,gBAAgB,CAAC,CAAC;IAC/BwB,IAAI,CAAC2F,MAAM,CAAC,GAAG1E,QAAQ,CAAC;IACxBe,UAAU,CAACgB,OAAO,CAAChD,IAAI,CAAC;IACxBA,IAAI,CAAC6M,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;EACnB,CAAC;EACDpN,IAAI,EAAE;AACR,CAAC;AACD,MAAMmP,IAAI,GAAG;EACXpD,YAAY,EAAE,CAAC3N,QAAQ,CAAC;EACxB+D,MAAM,EAAE5B,IAAI,IAAI;IACd,IAAI,CAACpC,WAAW,CAACoC,IAAI,CAAC,EAAE;MACtB,OAAO,IAAI;IACb;IACA,MAAMkC,WAAW,GAAGlC,IAAI,CAACK,cAAc,CAAC,CAAC;IACzC,OAAO,KAAK,IAAIL,IAAI,CAAC6O,WAAW,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI3M,WAAW,GAAG,IAAI,GAAGA,WAAW,GAAG,EAAE,CAAC,GAAG,IAAI,GAAG,KAAK;EACpG,CAAC;EACD0D,MAAM,EAAE,yBAAyB;EACjC5C,OAAO,EAAE2J,eAAe,CAAC9G,KAAK,IAAI;IAChC,OAAOlI,eAAe,CAACkI,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAGnF,SAAS,CAAC;EACtD,CAAC,CAAC;EACFjB,IAAI,EAAE;AACR,CAAC;AACD,MAAMqP,cAAc,GAAG;EACrBtD,YAAY,EAAE,CAACxN,QAAQ,EAAEC,YAAY,CAAC;EACtC2D,MAAM,EAAEA,CAAC5B,IAAI,EAAE8B,cAAc,KAAK;IAChC,OAAOhE,WAAW,CAACkC,IAAI,CAAC,GAAG6N,UAAU,CAAC7N,IAAI,EAAE8B,cAAc,EAAE,CAAC,CAAC,GAAG,IAAI;EACvE,CAAC;EACD8D,MAAM,EAAE,eAAe;EACvB5C,OAAO,EAAEsK,WAAW,CAAC,QAAQ,CAAC;EAC9B7N,IAAI,EAAE;AACR,CAAC;AACD,MAAMsP,UAAU,GAAG;EACjBvD,YAAY,EAAE,CAACxN,QAAQ,EAAEC,YAAY,CAAC;EACtC2D,MAAM,EAAEA,CAAC5B,IAAI,EAAE8B,cAAc,KAAK;IAChC,OAAOhE,WAAW,CAACkC,IAAI,CAAC,GAAG6N,UAAU,CAAC7N,IAAI,EAAE8B,cAAc,EAAE,CAAC,CAAC,GAAG,IAAI;EACvE,CAAC;EACD8D,MAAM,EAAE,mCAAmC;EAC3C5C,OAAO,EAAEsK,WAAW,CAAC,OAAO,CAAC;EAC7B7N,IAAI,EAAE;AACR,CAAC;AACD,MAAMuP,YAAY,GAAG;EACnBxD,YAAY,EAAE,CAACxN,QAAQ,EAAEC,YAAY,CAAC;EACtC2D,MAAM,EAAEA,CAAC5B,IAAI,EAAE8B,cAAc,KAAK;IAChC,OAAOhE,WAAW,CAACkC,IAAI,CAAC,GAAG6N,UAAU,CAAC7N,IAAI,EAAE8B,cAAc,EAAE,CAAC,CAAC,GAAG,IAAI;EACvE,CAAC;EACD8D,MAAM,EAAE,oBAAoB;EAC5B5C,OAAO,EAAEsK,WAAW,CAAC,QAAQ,CAAC;EAC9B7N,IAAI,EAAE;AACR,CAAC;AACD,MAAMwP,WAAW,GAAG;EAClBlO,MAAM,EAAE,CAAC,MAAM,CAAC;EAChB0B,GAAG,EAAE,GAAG;EACRhD,IAAI,EAAE;AACR,CAAC;AACD,MAAMyP,SAAS,GAAG;EAChBnO,MAAM,EAAE,CAAC,WAAW,CAAC;EACrB0B,GAAG,EAAE,IAAI;EACThD,IAAI,EAAE;AACR,CAAC;AACD,MAAM0P,gBAAgB,GAAG;EACvBpO,MAAM,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC;EAC1B0B,GAAG,EAAE,KAAK;EACVhD,IAAI,EAAE;AACR,CAAC;AACD,MAAM2P,sBAAsB,GAAG;EAC7BrO,MAAM,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC;EAC1B8G,SAAS,EAAE,KAAK;EAChBpF,GAAG,EAAE,KAAK;EACVhD,IAAI,EAAE;AACR,CAAC;AACD,MAAM4P,SAAS,GAAG;EAChBtO,MAAM,EAAE,CAAC,MAAM,CAAC;EAChB0B,GAAG,EAAE,IAAI;EACThD,IAAI,EAAE;AACR,CAAC;AACD,MAAM6P,eAAe,GAAG;EACtBvO,MAAM,EAAE,CAAC,MAAM,CAAC;EAChB8G,SAAS,EAAE,KAAK;EAChBpF,GAAG,EAAE,IAAI;EACThD,IAAI,EAAE;AACR,CAAC;AACD,MAAM8P,aAAa,GAAG;EACpBxO,MAAM,EAAE,CAAC,eAAe,CAAC;EACzB0B,GAAG,EAAE,IAAI;EACThD,IAAI,EAAE;AACR,CAAC;AACD,MAAM+P,WAAW,GAAG;EAClBzO,MAAM,EAAE,CAAC,QAAQ,CAAC;EAClB0B,GAAG,EAAE,GAAG;EACRhD,IAAI,EAAE;AACR,CAAC;AACD,MAAMgQ,iBAAiB,GAAG;EACxB1O,MAAM,EAAE,CAAC,QAAQ,CAAC;EAClB8G,SAAS,EAAE,KAAK;EAChBpF,GAAG,EAAE,GAAG;EACRhD,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMiQ,IAAI,GAAG;EACXlE,YAAY,EAAE,CAAC7M,QAAQ,CAAC;EACxBiD,MAAM,EAAEA,CAAC5B,IAAI,EAAE8B,cAAc,EAAE6N,YAAY,KAAK;IAC9C,IAAI,CAAC/Q,WAAW,CAACoB,IAAI,CAAC,EAAE;MACtB,OAAO,IAAI;IACb;IACA,MAAM4P,KAAK,GAAG5P,IAAI,CAAC6P,QAAQ,CAAC,CAAC;IAC7B,MAAMC,WAAW,GAAGF,KAAK,GAAG,IAAI5P,IAAI,CAACK,cAAc,CAAC,CAAC,KAAKL,IAAI,CAAC+P,MAAM,CAAC,CAAC,KAAKH,KAAK,IAAI,GAAG,IAAI5P,IAAI,CAACK,cAAc,CAAC,CAAC,KAAKL,IAAI,CAAC+P,MAAM,CAAC,CAAC,GAAG;IACtI,MAAM9P,UAAU,GAAGD,IAAI,CAACE,aAAa,CAAC,CAAC;IACvC;IACA;IACA,IAAIF,IAAI,CAACG,eAAe,CAAC,CAAC,KAAK,CAAC,IAAIrD,WAAW,CAACmD,UAAU,CAAC,EAAE;MAC3D,OAAO0P,YAAY,CAAC1P,UAAU,EAAE6P,WAAW,CAAC;IAC9C,CAAC,MAAM;MACL,OAAOA,WAAW;IACpB;EACF,CAAC;EACDzI,YAAY,EAAE,uEAAuE;EACrFzB,MAAM,EAAE,wEAAwE;EAChF5C,OAAO,EAAEA,CAACf,QAAQ,EAAE4D,KAAK,KAAK;IAC5B,MAAM,GAAGmK,QAAQ,EAAEC,OAAO,EAAEC,SAAS,CAAC,GAAGrK,KAAK;IAC9C,MAAMsK,QAAQ,GAAGtR,eAAe,CAACoR,OAAO,EAAE;MACxCL,KAAK,EAAEM;IACT,CAAC,CAAC;IACF,MAAME,YAAY,GAAGhT,eAAe,CAAC4S,QAAQ,CAAC;IAC9CI,YAAY,CAACC,SAAS,CAACpO,QAAQ,CAACqO,SAAS,CAAC,CAAC,CAAC;IAC5CH,QAAQ,CAACxK,MAAM,CAACyK,YAAY,CAAC;IAC7BnO,QAAQ,CAACe,OAAO,CAACmN,QAAQ,CAAC;EAC5B,CAAC;EACD5E,OAAO,EAAE,GAAG;EACZ9L,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM8Q,oBAAoB,GAAG,CAAClC,OAAO,EAAEG,KAAK,EAAEI,IAAI,EAAEE,cAAc,EAAEE,YAAY,CAAC;;AAEjF;AACA;AACA;AACA;AACA,MAAMwB,wBAAwB,GAAG,CAACvB,WAAW,EAAEE,gBAAgB,EAAEC,sBAAsB,EAAEC,SAAS,EAAEC,eAAe,EAAEJ,SAAS,EAAEM,WAAW,EAAEC,iBAAiB,EAAEF,aAAa,CAAC;AAC9K,MAAMkB,uBAAuB,GAAG,CAACf,IAAI,CAAC;AACtC,MAAMvE,YAAY,GAAG,CAAC,GAAGoF,oBAAoB,EAAE,GAAGC,wBAAwB,EAAE,GAAGC,uBAAuB,CAAC;;AAEvG;AACA;AACA;AACA,SAASC,0BAA0BA,CAACC,QAAQ,EAAqE;EAAA,IAAnErR,YAAY,GAAAkB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG2K,YAAY;EAAA,IAAEnL,IAAI,GAAAQ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEH,sBAAsB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAC7G,MAAMoQ,cAAc,GAAGnM,oBAAoB,CAACnF,YAAY,EAAEiB,sBAAsB,CAAC;EACjF,OAAOqQ,cAAc,CAACD,QAAQ,EAAE3Q,IAAI,CAAC;AACvC;;AAEA;AACA;AACA;AACA,SAAS6Q,wBAAwBA,CAAA,EAAoE;EAAA,IAAnEvR,YAAY,GAAAkB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG2K,YAAY;EAAA,IAAEnL,IAAI,GAAAQ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEH,sBAAsB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACjG,MAAMsQ,cAAc,GAAGxQ,oBAAoB,CAAChB,YAAY,EAAEiB,sBAAsB,CAAC;EACjF,OAAOuQ,cAAc,CAAC9Q,IAAI,CAAC;AAC7B;AAEA,SAAS0Q,0BAA0B,EAAEG,wBAAwB,EAAE1B,gBAAgB,EAAEC,sBAAsB,EAAEC,SAAS,EAAEC,eAAe,EAAEP,UAAU,EAAEH,IAAI,EAAE2B,oBAAoB,EAAElC,OAAO,EAAEa,SAAS,EAAED,WAAW,EAAEO,WAAW,EAAEC,iBAAiB,EAAEC,IAAI,EAAEV,YAAY,EAAER,KAAK,EAAEe,aAAa,EAAEiB,wBAAwB,EAAEC,uBAAuB,EAAEtF,YAAY,EAAE2D,cAAc,EAAE7D,yBAAyB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}