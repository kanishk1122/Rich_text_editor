{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar code = require('@lexical/code');\nvar list = require('@lexical/list');\nvar richText = require('@lexical/rich-text');\nvar utils = require('@lexical/utils');\nvar link = require('@lexical/link');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n  for (const item of list) {\n    const key = callback(item);\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers); // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return () => {\n    const output = [];\n    const children = lexical.$getRoot().getChildren();\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n      if (result != null) {\n        output.push(result);\n      }\n    }\n    return output.join('\\n\\n');\n  };\n}\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n    if (result != null) {\n      return result;\n    }\n  }\n  return lexical.$isElementNode(node) ? exportChildren(node, textTransformersIndex, textMatchTransformers) : null;\n}\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    }\n  }\n  return output.join('');\n}\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format); // Prevent adding opening tag is already opened by the previous sibling\n\n      const previousNode = getTextSibling(node, true);\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      } // Prevent adding closing tag if next sibling will do it\n\n      const nextNode = getTextSibling(node, false);\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  } // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n\n  return textContent.replace(frozenString, output);\n} // Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\n\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n  return null;\n}\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n// export const IS_CHROME: boolean = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return markdownString => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = lexical.$getRoot();\n    root.clear();\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i]; // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    } // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n\n    const children = root.getChildren();\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n    root.selectEnd();\n  };\n}\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers); // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n  return [null, startLineIndex];\n} // Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\n\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n  let currentNode, remainderNode, leadingNode; // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  } // Recursively run over inner text if it's not inline code\n\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  } // Run over leading/remaining text if any\n\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n      if (!match) {\n        continue;\n      }\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode;\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [, replaceNode, textNode] = textNode.splitText(startIndex, endIndex);\n      }\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n    break;\n  }\n} // Finds first \"<tag>content<tag>\" match that is not nested into another tag\n\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n  if (openTagsMatch == null) {\n    return null;\n  }\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      } // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n  return null;\n}\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n    if (IS_SAFARI || IS_IOS) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n  const textContent = anchorNode.getTextContent(); // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n  return false;\n}\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n  if (transformers == null) {\n    return false;\n  } // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n    if (match === null) {\n      continue;\n    }\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n  return false;\n}\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex]; // Quick check if we're possibly at the end of inline markdown style\n\n  const matchers = textFormatTransformers[closeChar];\n  if (!matchers) {\n    return false;\n  }\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1; // If tag is not single char check if rest of it matches with text content\n\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    } // Space before closing tag cancels inline markdown\n\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation after it\n\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag); // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n\n    let sibling = openNode;\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    } // Opening tag is not found\n\n    if (openTagStartIndex < 0) {\n      continue;\n    } // No content between opening and closing tag\n\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    } // Checking longer tags for repeating chars (e.g. *** vs **)\n\n    const prevOpenNodeText = openNode.getTextContent();\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation before it\n\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    } // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection); // Adjust offset based on deleted chars\n\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text'); // Apply formatting to selected text\n\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    } // Collapse selection up to the focus point\n\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type); // Remove formatting from collapsed selection\n\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n    return true;\n  }\n  return false;\n}\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) &&\n    // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n  return -1;\n}\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction registerMarkdownShortcuts(editor) {\n  let transformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TRANSFORMERS;\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, _ref => {\n    let {\n      tag\n    } = _ref;\n    return tag[tag.length - 1];\n  });\n  const textMatchTransformersIndex = indexBy(byType.textMatch, _ref2 => {\n    let {\n      trigger\n    } = _ref2;\n    return trigger;\n  });\n  for (const transformer of transformers) {\n    const type = transformer.type;\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n      if (!editor.hasNodes(dependencies)) {\n        {\n          throw Error(`MarkdownShortcuts: missing dependency for transformer. Ensure node dependency is included in editor initial config.`);\n        }\n      }\n    }\n  }\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n  return editor.registerUpdateListener(_ref3 => {\n    let {\n      tags,\n      dirtyLeaves,\n      editorState,\n      prevEditorState\n    } = _ref3;\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    }\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset !== prevSelection.anchor.offset + 1) {\n      return;\n    }\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n      const parentNode = anchorNode.getParent();\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n}; // Amount of spaces that define indentation level\n// TODO: should be an option\n\nconst LIST_INDENT_SIZE = 4;\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n    if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n  return output.join('\\n');\n};\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n}; // Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n    const linkContent = `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild(); // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\(([^(]+)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\(([^(]+)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match;\n    const linkNode = link.$createLinkNode(linkUrl);\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST]; // Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\nfunction $convertFromMarkdownString(markdown) {\n  let transformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TRANSFORMERS;\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown);\n}\nfunction $convertToMarkdownString() {\n  let transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : TRANSFORMERS;\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown();\n}\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;","map":{"version":3,"names":["lexical","require","code","list","richText","utils","link","indexBy","callback","index","item","key","push","transformersByType","transformers","byType","t","type","element","textFormat","textMatch","PUNCTUATION_OR_SPACE","createMarkdownExport","textFormatTransformers","filter","transformer","format","length","output","children","$getRoot","getChildren","child","result","exportTopLevelElements","join","node","elementTransformers","textTransformersIndex","textMatchTransformers","export","_node","exportChildren","$isElementNode","mainLoop","parentNode","textNode","textContent","exportTextFormat","$isLineBreakNode","$isTextNode","getTextContent","textTransformers","frozenString","trim","applied","Set","tag","hasFormat","has","add","previousNode","getTextSibling","nextNode","replace","backward","sibling","getPreviousSibling","getNextSibling","parent","getParentOrThrow","isInline","descendant","getLastDescendant","getFirstDescendant","CAN_USE_DOM","window","document","createElement","documentMode","test","navigator","platform","userAgent","InputEvent","IS_SAFARI","IS_IOS","MSStream","MARKDOWN_EMPTY_LINE_REG_EXP","CODE_BLOCK_REG_EXP","createMarkdownImport","textFormatTransformersIndex","createTextFormatTransformersIndex","markdownString","lines","split","linesLength","root","clear","i","lineText","codeBlockNode","shiftedIndex","importCodeBlock","importBlocks","isEmptyParagraph","remove","selectEnd","$isParagraphNode","firstChild","getFirstChild","getChildrenSize","rootNode","lineTextTrimmed","$createTextNode","elementNode","$createParagraphNode","append","regExp","match","setTextContent","slice","importTextFormatTransformers","isAttached","$isQuoteNode","$isListNode","targetNode","lastDescendant","$findMatchingParent","$isListItemNode","getTextContentSize","splice","$createLineBreakNode","startLineIndex","openMatch","endLineIndex","closeMatch","$createCodeNode","findOutermostMatch","importTextMatchTransformers","currentNode","remainderNode","leadingNode","startIndex","endIndex","splitText","transformersByTag","toggleFormat","textNode_","importRegExp","replaceNode","openTagsMatch","openTagsRegExp","fullMatchRegExp","fullMatchRegExpByTag","fullMatch","intraword","beforeChar","afterChar","escapeRegExp","tagRegExp","RegExp","runElementTransformers","anchorNode","anchorOffset","grandParentNode","getParent","$isRootOrShadowRoot","nextSiblings","getNextSiblings","siblings","runTextMatchTransformers","transformersByTrigger","lastChar","selectNext","runTextFormatTransformers","closeTagEndIndex","closeChar","matchers","matcher","tagLength","closeTagStartIndex","isEqualSubString","afterCloseTagChar","closeNode","openNode","openTagStartIndex","getOpenTagStartIndex","siblingTextContent","prevOpenNodeText","beforeOpenTagChar","prevCloseNodeText","closeNodeText","openNodeText","selection","$getSelection","nextSelection","$createRangeSelection","$setSelection","newOffset","anchor","set","__key","focus","formatText","offset","$isRangeSelection","string","maxIndex","stringA","aStart","stringB","bStart","registerMarkdownShortcuts","editor","arguments","undefined","TRANSFORMERS","_ref","textMatchTransformersIndex","_ref2","trigger","dependencies","hasNodes","Error","transform","registerUpdateListener","_ref3","tags","dirtyLeaves","editorState","prevEditorState","read","prevSelection","isCollapsed","anchorKey","_nodeMap","get","update","$isCodeNode","createBlockNode","createNode","select","LIST_INDENT_SIZE","listReplace","listType","listItem","$createListItemNode","getListType","list$1","$createListNode","Number","indent","Math","floor","setIndent","listExport","listNode","depth","listItemNode","repeat","prefix","getStart","getChecked","HEADING","HeadingNode","$isHeadingNode","level","getTag","$createHeadingNode","QUOTE","QuoteNode","line","_match","isImport","$createQuoteNode","CODE","CodeNode","getLanguage","UNORDERED_LIST","ListNode","ListItemNode","CHECK_LIST","ORDERED_LIST","INLINE_CODE","BOLD_ITALIC_STAR","BOLD_ITALIC_UNDERSCORE","BOLD_STAR","BOLD_UNDERSCORE","STRIKETHROUGH","ITALIC_STAR","ITALIC_UNDERSCORE","LINK","LinkNode","exportFormat","$isLinkNode","linkContent","getURL","linkText","linkUrl","linkNode","$createLinkNode","linkTextNode","setFormat","getFormat","ELEMENT_TRANSFORMERS","TEXT_FORMAT_TRANSFORMERS","TEXT_MATCH_TRANSFORMERS","$convertFromMarkdownString","markdown","importMarkdown","$convertToMarkdownString","exportMarkdown","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/react/node_modules/@lexical/markdown/LexicalMarkdown.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar code = require('@lexical/code');\nvar list = require('@lexical/list');\nvar richText = require('@lexical/rich-text');\nvar utils = require('@lexical/utils');\nvar link = require('@lexical/link');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indexBy(list, callback) {\n  const index = {};\n\n  for (const item of list) {\n    const key = callback(item);\n\n    if (index[key]) {\n      index[key].push(item);\n    } else {\n      index[key] = [item];\n    }\n  }\n\n  return index;\n}\nfunction transformersByType(transformers) {\n  const byType = indexBy(transformers, t => t.type);\n  return {\n    element: byType.element || [],\n    textFormat: byType['text-format'] || [],\n    textMatch: byType['text-match'] || []\n  };\n}\nconst PUNCTUATION_OR_SPACE = /[!-/:-@[-`{-~\\s]/;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createMarkdownExport(transformers) {\n  const byType = transformersByType(transformers); // Export only uses text formats that are responsible for single format\n  // e.g. it will filter out *** (bold, italic) and instead use separate ** and *\n\n  const textFormatTransformers = byType.textFormat.filter(transformer => transformer.format.length === 1);\n  return () => {\n    const output = [];\n    const children = lexical.$getRoot().getChildren();\n\n    for (const child of children) {\n      const result = exportTopLevelElements(child, byType.element, textFormatTransformers, byType.textMatch);\n\n      if (result != null) {\n        output.push(result);\n      }\n    }\n\n    return output.join('\\n\\n');\n  };\n}\n\nfunction exportTopLevelElements(node, elementTransformers, textTransformersIndex, textMatchTransformers) {\n  for (const transformer of elementTransformers) {\n    const result = transformer.export(node, _node => exportChildren(_node, textTransformersIndex, textMatchTransformers));\n\n    if (result != null) {\n      return result;\n    }\n  }\n\n  return lexical.$isElementNode(node) ? exportChildren(node, textTransformersIndex, textMatchTransformers) : null;\n}\n\nfunction exportChildren(node, textTransformersIndex, textMatchTransformers) {\n  const output = [];\n  const children = node.getChildren();\n\n  mainLoop: for (const child of children) {\n    for (const transformer of textMatchTransformers) {\n      const result = transformer.export(child, parentNode => exportChildren(parentNode, textTransformersIndex, textMatchTransformers), (textNode, textContent) => exportTextFormat(textNode, textContent, textTransformersIndex));\n\n      if (result != null) {\n        output.push(result);\n        continue mainLoop;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(child)) {\n      output.push('\\n');\n    } else if (lexical.$isTextNode(child)) {\n      output.push(exportTextFormat(child, child.getTextContent(), textTransformersIndex));\n    } else if (lexical.$isElementNode(child)) {\n      output.push(exportChildren(child, textTransformersIndex, textMatchTransformers));\n    }\n  }\n\n  return output.join('');\n}\n\nfunction exportTextFormat(node, textContent, textTransformers) {\n  // This function handles the case of a string looking like this: \"   foo   \"\n  // Where it would be invalid markdown to generate: \"**   foo   **\"\n  // We instead want to trim the whitespace out, apply formatting, and then\n  // bring the whitespace back. So our returned string looks like this: \"   **foo**   \"\n  const frozenString = textContent.trim();\n  let output = frozenString;\n  const applied = new Set();\n\n  for (const transformer of textTransformers) {\n    const format = transformer.format[0];\n    const tag = transformer.tag;\n\n    if (hasFormat(node, format) && !applied.has(format)) {\n      // Multiple tags might be used for the same format (*, _)\n      applied.add(format); // Prevent adding opening tag is already opened by the previous sibling\n\n      const previousNode = getTextSibling(node, true);\n\n      if (!hasFormat(previousNode, format)) {\n        output = tag + output;\n      } // Prevent adding closing tag if next sibling will do it\n\n\n      const nextNode = getTextSibling(node, false);\n\n      if (!hasFormat(nextNode, format)) {\n        output += tag;\n      }\n    }\n  } // Replace trimmed version of textContent ensuring surrounding whitespace is not modified\n\n\n  return textContent.replace(frozenString, output);\n} // Get next or previous text sibling a text node, including cases\n// when it's a child of inline element (e.g. link)\n\n\nfunction getTextSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n\n  if (!sibling) {\n    const parent = node.getParentOrThrow();\n\n    if (parent.isInline()) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  while (sibling) {\n    if (lexical.$isElementNode(sibling)) {\n      if (!sibling.isInline()) {\n        break;\n      }\n\n      const descendant = backward ? sibling.getLastDescendant() : sibling.getFirstDescendant();\n\n      if (lexical.$isTextNode(descendant)) {\n        return descendant;\n      } else {\n        sibling = backward ? sibling.getPreviousSibling() : sibling.getNextSibling();\n      }\n    }\n\n    if (lexical.$isTextNode(sibling)) {\n      return sibling;\n    }\n\n    if (!lexical.$isElementNode(sibling)) {\n      return null;\n    }\n  }\n\n  return null;\n}\n\nfunction hasFormat(node, format) {\n  return lexical.$isTextNode(node) && node.hasFormat(format);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n// export const IS_CHROME: boolean = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst MARKDOWN_EMPTY_LINE_REG_EXP = /^\\s{0,3}$/;\nconst CODE_BLOCK_REG_EXP = /^```(\\w{1,10})?\\s?$/;\nfunction createMarkdownImport(transformers) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = createTextFormatTransformersIndex(byType.textFormat);\n  return markdownString => {\n    const lines = markdownString.split('\\n');\n    const linesLength = lines.length;\n    const root = lexical.$getRoot();\n    root.clear();\n\n    for (let i = 0; i < linesLength; i++) {\n      const lineText = lines[i]; // Codeblocks are processed first as anything inside such block\n      // is ignored for further processing\n      // TODO:\n      // Abstract it to be dynamic as other transformers (add multiline match option)\n\n      const [codeBlockNode, shiftedIndex] = importCodeBlock(lines, i, root);\n\n      if (codeBlockNode != null) {\n        i = shiftedIndex;\n        continue;\n      }\n\n      importBlocks(lineText, root, byType.element, textFormatTransformersIndex, byType.textMatch);\n    } // Removing empty paragraphs as md does not really\n    // allow empty lines and uses them as dilimiter\n\n\n    const children = root.getChildren();\n\n    for (const child of children) {\n      if (isEmptyParagraph(child)) {\n        child.remove();\n      }\n    }\n\n    root.selectEnd();\n  };\n}\n\nfunction isEmptyParagraph(node) {\n  if (!lexical.$isParagraphNode(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  return firstChild == null || node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild) && MARKDOWN_EMPTY_LINE_REG_EXP.test(firstChild.getTextContent());\n}\n\nfunction importBlocks(lineText, rootNode, elementTransformers, textFormatTransformersIndex, textMatchTransformers) {\n  const lineTextTrimmed = lineText.trim();\n  const textNode = lexical.$createTextNode(lineTextTrimmed);\n  const elementNode = lexical.$createParagraphNode();\n  elementNode.append(textNode);\n  rootNode.append(elementNode);\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = lineText.match(regExp);\n\n    if (match) {\n      textNode.setTextContent(lineText.slice(match[0].length));\n      replace(elementNode, [textNode], match, true);\n      break;\n    }\n  }\n\n  importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers); // If no transformer found and we left with original paragraph node\n  // can check if its content can be appended to the previous node\n  // if it's a paragraph, quote or list\n\n  if (elementNode.isAttached() && lineTextTrimmed.length > 0) {\n    const previousNode = elementNode.getPreviousSibling();\n\n    if (lexical.$isParagraphNode(previousNode) || richText.$isQuoteNode(previousNode) || list.$isListNode(previousNode)) {\n      let targetNode = previousNode;\n\n      if (list.$isListNode(previousNode)) {\n        const lastDescendant = previousNode.getLastDescendant();\n\n        if (lastDescendant == null) {\n          targetNode = null;\n        } else {\n          targetNode = utils.$findMatchingParent(lastDescendant, list.$isListItemNode);\n        }\n      }\n\n      if (targetNode != null && targetNode.getTextContentSize() > 0) {\n        targetNode.splice(targetNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...elementNode.getChildren()]);\n        elementNode.remove();\n      }\n    }\n  }\n}\n\nfunction importCodeBlock(lines, startLineIndex, rootNode) {\n  const openMatch = lines[startLineIndex].match(CODE_BLOCK_REG_EXP);\n\n  if (openMatch) {\n    let endLineIndex = startLineIndex;\n    const linesLength = lines.length;\n\n    while (++endLineIndex < linesLength) {\n      const closeMatch = lines[endLineIndex].match(CODE_BLOCK_REG_EXP);\n\n      if (closeMatch) {\n        const codeBlockNode = code.$createCodeNode(openMatch[1]);\n        const textNode = lexical.$createTextNode(lines.slice(startLineIndex + 1, endLineIndex).join('\\n'));\n        codeBlockNode.append(textNode);\n        rootNode.append(codeBlockNode);\n        return [codeBlockNode, endLineIndex];\n      }\n    }\n  }\n\n  return [null, startLineIndex];\n} // Processing text content and replaces text format tags.\n// It takes outermost tag match and its content, creates text node with\n// format based on tag and then recursively executed over node's content\n//\n// E.g. for \"*Hello **world**!*\" string it will create text node with\n// \"Hello **world**!\" content and italic format and run recursively over\n// its content to transform \"**world**\" part\n\n\nfunction importTextFormatTransformers(textNode, textFormatTransformersIndex, textMatchTransformers) {\n  const textContent = textNode.getTextContent();\n  const match = findOutermostMatch(textContent, textFormatTransformersIndex);\n\n  if (!match) {\n    // Once text format processing is done run text match transformers, as it\n    // only can span within single text node (unline formats that can cover multiple nodes)\n    importTextMatchTransformers(textNode, textMatchTransformers);\n    return;\n  }\n\n  let currentNode, remainderNode, leadingNode; // If matching full content there's no need to run splitText and can reuse existing textNode\n  // to update its content and apply format. E.g. for **_Hello_** string after applying bold\n  // format (**) it will reuse the same text node to apply italic (_)\n\n  if (match[0] === textContent) {\n    currentNode = textNode;\n  } else {\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n\n    if (startIndex === 0) {\n      [currentNode, remainderNode] = textNode.splitText(endIndex);\n    } else {\n      [leadingNode, currentNode, remainderNode] = textNode.splitText(startIndex, endIndex);\n    }\n  }\n\n  currentNode.setTextContent(match[2]);\n  const transformer = textFormatTransformersIndex.transformersByTag[match[1]];\n\n  if (transformer) {\n    for (const format of transformer.format) {\n      if (!currentNode.hasFormat(format)) {\n        currentNode.toggleFormat(format);\n      }\n    }\n  } // Recursively run over inner text if it's not inline code\n\n\n  if (!currentNode.hasFormat('code')) {\n    importTextFormatTransformers(currentNode, textFormatTransformersIndex, textMatchTransformers);\n  } // Run over leading/remaining text if any\n\n\n  if (leadingNode) {\n    importTextFormatTransformers(leadingNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n\n  if (remainderNode) {\n    importTextFormatTransformers(remainderNode, textFormatTransformersIndex, textMatchTransformers);\n  }\n}\n\nfunction importTextMatchTransformers(textNode_, textMatchTransformers) {\n  let textNode = textNode_;\n\n  mainLoop: while (textNode) {\n    for (const transformer of textMatchTransformers) {\n      const match = textNode.getTextContent().match(transformer.importRegExp);\n\n      if (!match) {\n        continue;\n      }\n\n      const startIndex = match.index || 0;\n      const endIndex = startIndex + match[0].length;\n      let replaceNode;\n\n      if (startIndex === 0) {\n        [replaceNode, textNode] = textNode.splitText(endIndex);\n      } else {\n        [, replaceNode, textNode] = textNode.splitText(startIndex, endIndex);\n      }\n\n      transformer.replace(replaceNode, match);\n      continue mainLoop;\n    }\n\n    break;\n  }\n} // Finds first \"<tag>content<tag>\" match that is not nested into another tag\n\n\nfunction findOutermostMatch(textContent, textTransformersIndex) {\n  const openTagsMatch = textContent.match(textTransformersIndex.openTagsRegExp);\n\n  if (openTagsMatch == null) {\n    return null;\n  }\n\n  for (const match of openTagsMatch) {\n    // Open tags reg exp might capture leading space so removing it\n    // before using match to find transformer\n    const tag = match.replace(/^\\s/, '');\n    const fullMatchRegExp = textTransformersIndex.fullMatchRegExpByTag[tag];\n\n    if (fullMatchRegExp == null) {\n      continue;\n    }\n\n    const fullMatch = textContent.match(fullMatchRegExp);\n    const transformer = textTransformersIndex.transformersByTag[tag];\n\n    if (fullMatch != null && transformer != null) {\n      if (transformer.intraword !== false) {\n        return fullMatch;\n      } // For non-intraword transformers checking if it's within a word\n      // or surrounded with space/punctuation/newline\n\n\n      const {\n        index = 0\n      } = fullMatch;\n      const beforeChar = textContent[index - 1];\n      const afterChar = textContent[index + fullMatch[0].length];\n\n      if ((!beforeChar || PUNCTUATION_OR_SPACE.test(beforeChar)) && (!afterChar || PUNCTUATION_OR_SPACE.test(afterChar))) {\n        return fullMatch;\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction createTextFormatTransformersIndex(textTransformers) {\n  const transformersByTag = {};\n  const fullMatchRegExpByTag = {};\n  const openTagsRegExp = [];\n  const escapeRegExp = `(?<![\\\\\\\\])`;\n\n  for (const transformer of textTransformers) {\n    const {\n      tag\n    } = transformer;\n    transformersByTag[tag] = transformer;\n    const tagRegExp = tag.replace(/(\\*|\\^)/g, '\\\\$1');\n    openTagsRegExp.push(tagRegExp);\n\n    if (IS_SAFARI || IS_IOS) {\n      fullMatchRegExpByTag[tag] = new RegExp(`(${tagRegExp})(?![${tagRegExp}\\\\s])(.*?[^${tagRegExp}\\\\s])${tagRegExp}(?!${tagRegExp})`);\n    } else {\n      fullMatchRegExpByTag[tag] = new RegExp(`(?<![\\\\\\\\${tagRegExp}])(${tagRegExp})((\\\\\\\\${tagRegExp})?.*?[^${tagRegExp}\\\\s](\\\\\\\\${tagRegExp})?)((?<!\\\\\\\\)|(?<=\\\\\\\\\\\\\\\\))(${tagRegExp})(?![\\\\\\\\${tagRegExp}])`);\n    }\n  }\n\n  return {\n    // Reg exp to find open tag + content + close tag\n    fullMatchRegExpByTag,\n    // Reg exp to find opening tags\n    openTagsRegExp: new RegExp((IS_SAFARI || IS_IOS ? '' : `${escapeRegExp}`) + '(' + openTagsRegExp.join('|') + ')', 'g'),\n    transformersByTag\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction runElementTransformers(parentNode, anchorNode, anchorOffset, elementTransformers) {\n  const grandParentNode = parentNode.getParent();\n\n  if (!lexical.$isRootOrShadowRoot(grandParentNode) || parentNode.getFirstChild() !== anchorNode) {\n    return false;\n  }\n\n  const textContent = anchorNode.getTextContent(); // Checking for anchorOffset position to prevent any checks for cases when caret is too far\n  // from a line start to be a part of block-level markdown trigger.\n  //\n  // TODO:\n  // Can have a quick check if caret is close enough to the beginning of the string (e.g. offset less than 10-20)\n  // since otherwise it won't be a markdown shortcut, but tables are exception\n\n  if (textContent[anchorOffset - 1] !== ' ') {\n    return false;\n  }\n\n  for (const {\n    regExp,\n    replace\n  } of elementTransformers) {\n    const match = textContent.match(regExp);\n\n    if (match && match[0].length === anchorOffset) {\n      const nextSiblings = anchorNode.getNextSiblings();\n      const [leadingNode, remainderNode] = anchorNode.splitText(anchorOffset);\n      leadingNode.remove();\n      const siblings = remainderNode ? [remainderNode, ...nextSiblings] : nextSiblings;\n      replace(parentNode, siblings, match, false);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction runTextMatchTransformers(anchorNode, anchorOffset, transformersByTrigger) {\n  let textContent = anchorNode.getTextContent();\n  const lastChar = textContent[anchorOffset - 1];\n  const transformers = transformersByTrigger[lastChar];\n\n  if (transformers == null) {\n    return false;\n  } // If typing in the middle of content, remove the tail to do\n  // reg exp match up to a string end (caret position)\n\n\n  if (anchorOffset < textContent.length) {\n    textContent = textContent.slice(0, anchorOffset);\n  }\n\n  for (const transformer of transformers) {\n    const match = textContent.match(transformer.regExp);\n\n    if (match === null) {\n      continue;\n    }\n\n    const startIndex = match.index || 0;\n    const endIndex = startIndex + match[0].length;\n    let replaceNode;\n\n    if (startIndex === 0) {\n      [replaceNode] = anchorNode.splitText(endIndex);\n    } else {\n      [, replaceNode] = anchorNode.splitText(startIndex, endIndex);\n    }\n\n    replaceNode.selectNext(0, 0);\n    transformer.replace(replaceNode, match);\n    return true;\n  }\n\n  return false;\n}\n\nfunction runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformers) {\n  const textContent = anchorNode.getTextContent();\n  const closeTagEndIndex = anchorOffset - 1;\n  const closeChar = textContent[closeTagEndIndex]; // Quick check if we're possibly at the end of inline markdown style\n\n  const matchers = textFormatTransformers[closeChar];\n\n  if (!matchers) {\n    return false;\n  }\n\n  for (const matcher of matchers) {\n    const {\n      tag\n    } = matcher;\n    const tagLength = tag.length;\n    const closeTagStartIndex = closeTagEndIndex - tagLength + 1; // If tag is not single char check if rest of it matches with text content\n\n    if (tagLength > 1) {\n      if (!isEqualSubString(textContent, closeTagStartIndex, tag, 0, tagLength)) {\n        continue;\n      }\n    } // Space before closing tag cancels inline markdown\n\n\n    if (textContent[closeTagStartIndex - 1] === ' ') {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation after it\n\n\n    const afterCloseTagChar = textContent[closeTagEndIndex + 1];\n\n    if (matcher.intraword === false && afterCloseTagChar && !PUNCTUATION_OR_SPACE.test(afterCloseTagChar)) {\n      continue;\n    }\n\n    const closeNode = anchorNode;\n    let openNode = closeNode;\n    let openTagStartIndex = getOpenTagStartIndex(textContent, closeTagStartIndex, tag); // Go through text node siblings and search for opening tag\n    // if haven't found it within the same text node as closing tag\n\n    let sibling = openNode;\n\n    while (openTagStartIndex < 0 && (sibling = sibling.getPreviousSibling())) {\n      if (lexical.$isLineBreakNode(sibling)) {\n        break;\n      }\n\n      if (lexical.$isTextNode(sibling)) {\n        const siblingTextContent = sibling.getTextContent();\n        openNode = sibling;\n        openTagStartIndex = getOpenTagStartIndex(siblingTextContent, siblingTextContent.length, tag);\n      }\n    } // Opening tag is not found\n\n\n    if (openTagStartIndex < 0) {\n      continue;\n    } // No content between opening and closing tag\n\n\n    if (openNode === closeNode && openTagStartIndex + tagLength === closeTagStartIndex) {\n      continue;\n    } // Checking longer tags for repeating chars (e.g. *** vs **)\n\n\n    const prevOpenNodeText = openNode.getTextContent();\n\n    if (openTagStartIndex > 0 && prevOpenNodeText[openTagStartIndex - 1] === closeChar) {\n      continue;\n    } // Some tags can not be used within words, hence should have newline/space/punctuation before it\n\n\n    const beforeOpenTagChar = prevOpenNodeText[openTagStartIndex - 1];\n\n    if (matcher.intraword === false && beforeOpenTagChar && !PUNCTUATION_OR_SPACE.test(beforeOpenTagChar)) {\n      continue;\n    } // Clean text from opening and closing tags (starting from closing tag\n    // to prevent any offset shifts if we start from opening one)\n\n\n    const prevCloseNodeText = closeNode.getTextContent();\n    const closeNodeText = prevCloseNodeText.slice(0, closeTagStartIndex) + prevCloseNodeText.slice(closeTagEndIndex + 1);\n    closeNode.setTextContent(closeNodeText);\n    const openNodeText = openNode === closeNode ? closeNodeText : prevOpenNodeText;\n    openNode.setTextContent(openNodeText.slice(0, openTagStartIndex) + openNodeText.slice(openTagStartIndex + tagLength));\n    const selection = lexical.$getSelection();\n    const nextSelection = lexical.$createRangeSelection();\n    lexical.$setSelection(nextSelection); // Adjust offset based on deleted chars\n\n    const newOffset = closeTagEndIndex - tagLength * (openNode === closeNode ? 2 : 1) + 1;\n    nextSelection.anchor.set(openNode.__key, openTagStartIndex, 'text');\n    nextSelection.focus.set(closeNode.__key, newOffset, 'text'); // Apply formatting to selected text\n\n    for (const format of matcher.format) {\n      if (!nextSelection.hasFormat(format)) {\n        nextSelection.formatText(format);\n      }\n    } // Collapse selection up to the focus point\n\n\n    nextSelection.anchor.set(nextSelection.focus.key, nextSelection.focus.offset, nextSelection.focus.type); // Remove formatting from collapsed selection\n\n    for (const format of matcher.format) {\n      if (nextSelection.hasFormat(format)) {\n        nextSelection.toggleFormat(format);\n      }\n    }\n\n    if (lexical.$isRangeSelection(selection)) {\n      nextSelection.format = selection.format;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction getOpenTagStartIndex(string, maxIndex, tag) {\n  const tagLength = tag.length;\n\n  for (let i = maxIndex; i >= tagLength; i--) {\n    const startIndex = i - tagLength;\n\n    if (isEqualSubString(string, startIndex, tag, 0, tagLength) && // Space after opening tag cancels transformation\n    string[startIndex + tagLength] !== ' ') {\n      return startIndex;\n    }\n  }\n\n  return -1;\n}\n\nfunction isEqualSubString(stringA, aStart, stringB, bStart, length) {\n  for (let i = 0; i < length; i++) {\n    if (stringA[aStart + i] !== stringB[bStart + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction registerMarkdownShortcuts(editor, transformers = TRANSFORMERS) {\n  const byType = transformersByType(transformers);\n  const textFormatTransformersIndex = indexBy(byType.textFormat, ({\n    tag\n  }) => tag[tag.length - 1]);\n  const textMatchTransformersIndex = indexBy(byType.textMatch, ({\n    trigger\n  }) => trigger);\n\n  for (const transformer of transformers) {\n    const type = transformer.type;\n\n    if (type === 'element' || type === 'text-match') {\n      const dependencies = transformer.dependencies;\n\n      if (!editor.hasNodes(dependencies)) {\n        {\n          throw Error(`MarkdownShortcuts: missing dependency for transformer. Ensure node dependency is included in editor initial config.`);\n        }\n      }\n    }\n  }\n\n  const transform = (parentNode, anchorNode, anchorOffset) => {\n    if (runElementTransformers(parentNode, anchorNode, anchorOffset, byType.element)) {\n      return;\n    }\n\n    if (runTextMatchTransformers(anchorNode, anchorOffset, textMatchTransformersIndex)) {\n      return;\n    }\n\n    runTextFormatTransformers(anchorNode, anchorOffset, textFormatTransformersIndex);\n  };\n\n  return editor.registerUpdateListener(({\n    tags,\n    dirtyLeaves,\n    editorState,\n    prevEditorState\n  }) => {\n    // Ignore updates from undo/redo (as changes already calculated)\n    if (tags.has('historic')) {\n      return;\n    }\n\n    const selection = editorState.read(lexical.$getSelection);\n    const prevSelection = prevEditorState.read(lexical.$getSelection);\n\n    if (!lexical.$isRangeSelection(prevSelection) || !lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return;\n    }\n\n    const anchorKey = selection.anchor.key;\n    const anchorOffset = selection.anchor.offset;\n\n    const anchorNode = editorState._nodeMap.get(anchorKey);\n\n    if (!lexical.$isTextNode(anchorNode) || !dirtyLeaves.has(anchorKey) || anchorOffset !== 1 && anchorOffset !== prevSelection.anchor.offset + 1) {\n      return;\n    }\n\n    editor.update(() => {\n      // Markdown is not available inside code\n      if (anchorNode.hasFormat('code')) {\n        return;\n      }\n\n      const parentNode = anchorNode.getParent();\n\n      if (parentNode === null || code.$isCodeNode(parentNode)) {\n        return;\n      }\n\n      transform(parentNode, anchorNode, selection.anchor.offset);\n    });\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst createBlockNode = createNode => {\n  return (parentNode, children, match) => {\n    const node = createNode(match);\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  };\n}; // Amount of spaces that define indentation level\n// TODO: should be an option\n\n\nconst LIST_INDENT_SIZE = 4;\n\nconst listReplace = listType => {\n  return (parentNode, children, match) => {\n    const previousNode = parentNode.getPreviousSibling();\n    const listItem = list.$createListItemNode(listType === 'check' ? match[3] === 'x' : undefined);\n\n    if (list.$isListNode(previousNode) && previousNode.getListType() === listType) {\n      previousNode.append(listItem);\n      parentNode.remove();\n    } else {\n      const list$1 = list.$createListNode(listType, listType === 'number' ? Number(match[2]) : undefined);\n      list$1.append(listItem);\n      parentNode.replace(list$1);\n    }\n\n    listItem.append(...children);\n    listItem.select(0, 0);\n    const indent = Math.floor(match[1].length / LIST_INDENT_SIZE);\n\n    if (indent) {\n      listItem.setIndent(indent);\n    }\n  };\n};\n\nconst listExport = (listNode, exportChildren, depth) => {\n  const output = [];\n  const children = listNode.getChildren();\n  let index = 0;\n\n  for (const listItemNode of children) {\n    if (list.$isListItemNode(listItemNode)) {\n      if (listItemNode.getChildrenSize() === 1) {\n        const firstChild = listItemNode.getFirstChild();\n\n        if (list.$isListNode(firstChild)) {\n          output.push(listExport(firstChild, exportChildren, depth + 1));\n          continue;\n        }\n      }\n\n      const indent = ' '.repeat(depth * LIST_INDENT_SIZE);\n      const listType = listNode.getListType();\n      const prefix = listType === 'number' ? `${listNode.getStart() + index}. ` : listType === 'check' ? `- [${listItemNode.getChecked() ? 'x' : ' '}] ` : '- ';\n      output.push(indent + prefix + exportChildren(listItemNode));\n      index++;\n    }\n  }\n\n  return output.join('\\n');\n};\n\nconst HEADING = {\n  dependencies: [richText.HeadingNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isHeadingNode(node)) {\n      return null;\n    }\n\n    const level = Number(node.getTag().slice(1));\n    return '#'.repeat(level) + ' ' + exportChildren(node);\n  },\n  regExp: /^(#{1,6})\\s/,\n  replace: createBlockNode(match => {\n    const tag = 'h' + match[1].length;\n    return richText.$createHeadingNode(tag);\n  }),\n  type: 'element'\n};\nconst QUOTE = {\n  dependencies: [richText.QuoteNode],\n  export: (node, exportChildren) => {\n    if (!richText.$isQuoteNode(node)) {\n      return null;\n    }\n\n    const lines = exportChildren(node).split('\\n');\n    const output = [];\n\n    for (const line of lines) {\n      output.push('> ' + line);\n    }\n\n    return output.join('\\n');\n  },\n  regExp: /^>\\s/,\n  replace: (parentNode, children, _match, isImport) => {\n    if (isImport) {\n      const previousNode = parentNode.getPreviousSibling();\n\n      if (richText.$isQuoteNode(previousNode)) {\n        previousNode.splice(previousNode.getChildrenSize(), 0, [lexical.$createLineBreakNode(), ...children]);\n        previousNode.select(0, 0);\n        parentNode.remove();\n        return;\n      }\n    }\n\n    const node = richText.$createQuoteNode();\n    node.append(...children);\n    parentNode.replace(node);\n    node.select(0, 0);\n  },\n  type: 'element'\n};\nconst CODE = {\n  dependencies: [code.CodeNode],\n  export: node => {\n    if (!code.$isCodeNode(node)) {\n      return null;\n    }\n\n    const textContent = node.getTextContent();\n    return '```' + (node.getLanguage() || '') + (textContent ? '\\n' + textContent : '') + '\\n' + '```';\n  },\n  regExp: /^```(\\w{1,10})?\\s/,\n  replace: createBlockNode(match => {\n    return code.$createCodeNode(match ? match[1] : undefined);\n  }),\n  type: 'element'\n};\nconst UNORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)[-*+]\\s/,\n  replace: listReplace('bullet'),\n  type: 'element'\n};\nconst CHECK_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(?:-\\s)?\\s?(\\[(\\s|x)?\\])\\s/i,\n  replace: listReplace('check'),\n  type: 'element'\n};\nconst ORDERED_LIST = {\n  dependencies: [list.ListNode, list.ListItemNode],\n  export: (node, exportChildren) => {\n    return list.$isListNode(node) ? listExport(node, exportChildren, 0) : null;\n  },\n  regExp: /^(\\s*)(\\d{1,})\\.\\s/,\n  replace: listReplace('number'),\n  type: 'element'\n};\nconst INLINE_CODE = {\n  format: ['code'],\n  tag: '`',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_STAR = {\n  format: ['bold', 'italic'],\n  tag: '***',\n  type: 'text-format'\n};\nconst BOLD_ITALIC_UNDERSCORE = {\n  format: ['bold', 'italic'],\n  intraword: false,\n  tag: '___',\n  type: 'text-format'\n};\nconst BOLD_STAR = {\n  format: ['bold'],\n  tag: '**',\n  type: 'text-format'\n};\nconst BOLD_UNDERSCORE = {\n  format: ['bold'],\n  intraword: false,\n  tag: '__',\n  type: 'text-format'\n};\nconst STRIKETHROUGH = {\n  format: ['strikethrough'],\n  tag: '~~',\n  type: 'text-format'\n};\nconst ITALIC_STAR = {\n  format: ['italic'],\n  tag: '*',\n  type: 'text-format'\n};\nconst ITALIC_UNDERSCORE = {\n  format: ['italic'],\n  intraword: false,\n  tag: '_',\n  type: 'text-format'\n}; // Order of text transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst LINK = {\n  dependencies: [link.LinkNode],\n  export: (node, exportChildren, exportFormat) => {\n    if (!link.$isLinkNode(node)) {\n      return null;\n    }\n\n    const linkContent = `[${node.getTextContent()}](${node.getURL()})`;\n    const firstChild = node.getFirstChild(); // Add text styles only if link has single text node inside. If it's more\n    // then one we ignore it as markdown does not support nested styles for links\n\n    if (node.getChildrenSize() === 1 && lexical.$isTextNode(firstChild)) {\n      return exportFormat(firstChild, linkContent);\n    } else {\n      return linkContent;\n    }\n  },\n  importRegExp: /(?:\\[([^[]+)\\])(?:\\(([^(]+)\\))/,\n  regExp: /(?:\\[([^[]+)\\])(?:\\(([^(]+)\\))$/,\n  replace: (textNode, match) => {\n    const [, linkText, linkUrl] = match;\n    const linkNode = link.$createLinkNode(linkUrl);\n    const linkTextNode = lexical.$createTextNode(linkText);\n    linkTextNode.setFormat(textNode.getFormat());\n    linkNode.append(linkTextNode);\n    textNode.replace(linkNode);\n  },\n  trigger: ')',\n  type: 'text-match'\n};\n\n/** @module @lexical/markdown */\nconst ELEMENT_TRANSFORMERS = [HEADING, QUOTE, CODE, UNORDERED_LIST, ORDERED_LIST]; // Order of text format transformers matters:\n//\n// - code should go first as it prevents any transformations inside\n// - then longer tags match (e.g. ** or __ should go before * or _)\n\nconst TEXT_FORMAT_TRANSFORMERS = [INLINE_CODE, BOLD_ITALIC_STAR, BOLD_ITALIC_UNDERSCORE, BOLD_STAR, BOLD_UNDERSCORE, ITALIC_STAR, ITALIC_UNDERSCORE, STRIKETHROUGH];\nconst TEXT_MATCH_TRANSFORMERS = [LINK];\nconst TRANSFORMERS = [...ELEMENT_TRANSFORMERS, ...TEXT_FORMAT_TRANSFORMERS, ...TEXT_MATCH_TRANSFORMERS];\n\nfunction $convertFromMarkdownString(markdown, transformers = TRANSFORMERS) {\n  const importMarkdown = createMarkdownImport(transformers);\n  return importMarkdown(markdown);\n}\n\nfunction $convertToMarkdownString(transformers = TRANSFORMERS) {\n  const exportMarkdown = createMarkdownExport(transformers);\n  return exportMarkdown();\n}\n\nexports.$convertFromMarkdownString = $convertFromMarkdownString;\nexports.$convertToMarkdownString = $convertToMarkdownString;\nexports.BOLD_ITALIC_STAR = BOLD_ITALIC_STAR;\nexports.BOLD_ITALIC_UNDERSCORE = BOLD_ITALIC_UNDERSCORE;\nexports.BOLD_STAR = BOLD_STAR;\nexports.BOLD_UNDERSCORE = BOLD_UNDERSCORE;\nexports.CHECK_LIST = CHECK_LIST;\nexports.CODE = CODE;\nexports.ELEMENT_TRANSFORMERS = ELEMENT_TRANSFORMERS;\nexports.HEADING = HEADING;\nexports.INLINE_CODE = INLINE_CODE;\nexports.ITALIC_STAR = ITALIC_STAR;\nexports.ITALIC_UNDERSCORE = ITALIC_UNDERSCORE;\nexports.LINK = LINK;\nexports.ORDERED_LIST = ORDERED_LIST;\nexports.QUOTE = QUOTE;\nexports.STRIKETHROUGH = STRIKETHROUGH;\nexports.TEXT_FORMAT_TRANSFORMERS = TEXT_FORMAT_TRANSFORMERS;\nexports.TEXT_MATCH_TRANSFORMERS = TEXT_MATCH_TRANSFORMERS;\nexports.TRANSFORMERS = TRANSFORMERS;\nexports.UNORDERED_LIST = UNORDERED_LIST;\nexports.registerMarkdownShortcuts = registerMarkdownShortcuts;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}