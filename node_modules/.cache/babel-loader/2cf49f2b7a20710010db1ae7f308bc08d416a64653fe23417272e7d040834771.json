{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { AutoLinkNode, $isAutoLinkNode, $isLinkNode, TOGGLE_LINK_COMMAND, $createAutoLinkNode } from '@lexical/link';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { mergeRegister } from '@lexical/utils';\nimport { TextNode, $getSelection, $isRangeSelection, COMMAND_PRIORITY_LOW, $isTextNode, $isElementNode, $isLineBreakNode, $createTextNode, $isNodeSelection } from 'lexical';\nimport { useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createLinkMatcherWithRegExp(regExp) {\n  let urlTransformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : text => text;\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) {\n      return null;\n    }\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0])\n    };\n  };\n}\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\n\n/**\n * Check if the text content starts with a fullstop followed by a top-level domain.\n * Meaning if the text content can be a beginning of a top level domain.\n * @param textContent\n * @param isEmail\n * @returns boolean\n */\nfunction startsWithTLD(textContent, isEmail) {\n  if (isEmail) {\n    return /^\\.[a-zA-Z]{2,}/.test(textContent);\n  } else {\n    return /^\\.[a-zA-Z0-9]{1,}/.test(textContent);\n  }\n}\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n  return previousNode === null || $isLineBreakNode(previousNode) || $isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n  return nextNode === null || $isLineBreakNode(nextNode) || $isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\nfunction isContentAroundIsValid(matchStart, matchEnd, text, nodes) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]);\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);\n  return contentAfterIsValid;\n}\nfunction extractMatchingNodes(nodes, startIndex, endIndex) {\n  const unmodifiedBeforeNodes = [];\n  const matchingNodes = [];\n  const unmodifiedAfterNodes = [];\n  let matchingOffset = 0;\n  let currentOffset = 0;\n  const currentNodes = [...nodes];\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0];\n    const currentNodeText = currentNode.getTextContent();\n    const currentNodeLength = currentNodeText.length;\n    const currentNodeStart = currentOffset;\n    const currentNodeEnd = currentOffset + currentNodeLength;\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode);\n      matchingOffset += currentNodeLength;\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode);\n    } else {\n      matchingNodes.push(currentNode);\n    }\n    currentOffset += currentNodeLength;\n    currentNodes.shift();\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];\n}\nfunction $createAutoLinkNode_(nodes, startIndex, endIndex, match) {\n  const linkNode = $createAutoLinkNode(match.url, match.attributes);\n  if (nodes.length === 1) {\n    let remainingTextNode = nodes[0];\n    let linkTextNode;\n    if (startIndex === 0) {\n      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);\n    } else {\n      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);\n    }\n    const textNode = $createTextNode(match.text);\n    textNode.setFormat(linkTextNode.getFormat());\n    textNode.setDetail(linkTextNode.getDetail());\n    textNode.setStyle(linkTextNode.getStyle());\n    linkNode.append(textNode);\n    linkTextNode.replace(linkNode);\n    return remainingTextNode;\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0];\n    let offset = firstTextNode.getTextContent().length;\n    let firstLinkTextNode;\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode;\n    } else {\n      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);\n    }\n    const linkNodes = [];\n    let remainingTextNode;\n    for (let i = 1; i < nodes.length; i++) {\n      const currentNode = nodes[i];\n      const currentNodeText = currentNode.getTextContent();\n      const currentNodeLength = currentNodeText.length;\n      const currentNodeStart = offset;\n      const currentNodeEnd = offset + currentNodeLength;\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode);\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);\n          linkNodes.push(linkTextNode);\n          remainingTextNode = endNode;\n        }\n      }\n      offset += currentNodeLength;\n    }\n    const selection = $getSelection();\n    const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined;\n    const textNode = $createTextNode(firstLinkTextNode.getTextContent());\n    textNode.setFormat(firstLinkTextNode.getFormat());\n    textNode.setDetail(firstLinkTextNode.getDetail());\n    textNode.setStyle(firstLinkTextNode.getStyle());\n    linkNode.append(textNode, ...linkNodes);\n    // it does not preserve caret position if caret was at the first text node\n    // so we need to restore caret position\n    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n      if ($isRangeSelection(selection)) {\n        textNode.select(selection.anchor.offset, selection.focus.offset);\n      } else if ($isNodeSelection(selection)) {\n        textNode.select(0, textNode.getTextContent().length);\n      }\n    }\n    firstLinkTextNode.replace(linkNode);\n    return remainingTextNode;\n  }\n  return undefined;\n}\nfunction $handleLinkCreation(nodes, matchers, onChange) {\n  let currentNodes = [...nodes];\n  const initialText = currentNodes.map(node => node.getTextContent()).join('');\n  let text = initialText;\n  let match;\n  let invalidMatchEnd = 0;\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);\n    if (isValid) {\n      const [matchingOffset,, matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;\n      const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);\n      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n    text = text.substring(matchEnd);\n  }\n}\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n  const url = linkNode.getURL();\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n    const target = linkNode.getTarget();\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n  if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text) || startsWithTLD(text, previousSibling.isEmailURI()))) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n  if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n  node.remove();\n  return children.map(child => child.getLatest());\n}\nfunction getTextNodesToMatch(textNode) {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode];\n  let nextSibling = textNode.getNextSibling();\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling);\n    if (/[\\s]/.test(nextSibling.getTextContent())) {\n      break;\n    }\n    nextSibling = nextSibling.getNextSibling();\n  }\n  return textNodesToMatch;\n}\nfunction useAutoLink(editor, matchers, onChange) {\n  useEffect(() => {\n    if (!editor.hasNodes([AutoLinkNode])) {\n      {\n        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n    return mergeRegister(editor.registerNodeTransform(TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n      const previous = textNode.getPreviousSibling();\n      if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!$isLinkNode(parent)) {\n        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))) {\n          const textNodesToMatch = getTextNodesToMatch(textNode);\n          $handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped);\n        }\n        handleBadNeighbors(textNode, matchers, onChangeWrapped);\n      }\n    }), editor.registerCommand(TOGGLE_LINK_COMMAND, payload => {\n      const selection = $getSelection();\n      if (payload !== null || !$isRangeSelection(selection)) {\n        return false;\n      }\n      const nodes = selection.extract();\n      nodes.forEach(node => {\n        const parent = node.getParent();\n        if ($isAutoLinkNode(parent)) {\n          // invert the value\n          parent.setIsUnlinked(!parent.getIsUnlinked());\n          parent.markDirty();\n          return true;\n        }\n      });\n      return false;\n    }, COMMAND_PRIORITY_LOW));\n  }, [editor, matchers, onChange]);\n}\nfunction AutoLinkPlugin(_ref) {\n  let {\n    matchers,\n    onChange\n  } = _ref;\n  const [editor] = useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\nexport { AutoLinkPlugin, createLinkMatcherWithRegExp };","map":{"version":3,"names":["AutoLinkNode","$isAutoLinkNode","$isLinkNode","TOGGLE_LINK_COMMAND","$createAutoLinkNode","useLexicalComposerContext","mergeRegister","TextNode","$getSelection","$isRangeSelection","COMMAND_PRIORITY_LOW","$isTextNode","$isElementNode","$isLineBreakNode","$createTextNode","$isNodeSelection","useEffect","createLinkMatcherWithRegExp","regExp","urlTransformer","arguments","length","undefined","text","match","exec","index","url","findFirstMatch","matchers","i","PUNCTUATION_OR_SPACE","isSeparator","char","test","endsWithSeparator","textContent","startsWithSeparator","startsWithTLD","isEmail","isPreviousNodeValid","node","previousNode","getPreviousSibling","getLastDescendant","getTextContent","isNextNodeValid","nextNode","getNextSibling","getFirstDescendant","isContentAroundIsValid","matchStart","matchEnd","nodes","contentBeforeIsValid","contentAfterIsValid","extractMatchingNodes","startIndex","endIndex","unmodifiedBeforeNodes","matchingNodes","unmodifiedAfterNodes","matchingOffset","currentOffset","currentNodes","currentNode","currentNodeText","currentNodeLength","currentNodeStart","currentNodeEnd","push","shift","$createAutoLinkNode_","linkNode","attributes","remainingTextNode","linkTextNode","splitText","textNode","setFormat","getFormat","setDetail","getDetail","setStyle","getStyle","append","replace","firstTextNode","offset","firstLinkTextNode","linkNodes","endNode","selection","selectedTextNode","getNodes","find","select","anchor","focus","$handleLinkCreation","onChange","initialText","map","join","invalidMatchEnd","matchLength","isValid","actualMatchStart","actualMatchEnd","substring","handleLinkEdit","children","getChildren","childrenLength","child","isSimpleText","replaceWithChildren","getURL","setURL","rel","getRel","setRel","target","getTarget","setTarget","handleBadNeighbors","previousSibling","nextSibling","getIsUnlinked","isEmailURI","j","insertAfter","remove","getLatest","getTextNodesToMatch","textNodesToMatch","useAutoLink","editor","hasNodes","Error","onChangeWrapped","prevUrl","registerNodeTransform","parent","getParentOrThrow","previous","registerCommand","payload","extract","forEach","getParent","setIsUnlinked","markDirty","AutoLinkPlugin","_ref"],"sources":["/media/ks/My thing/test/textditor_Using_lixical/node_modules/@lexical/react/LexicalAutoLinkPlugin.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { AutoLinkNode, $isAutoLinkNode, $isLinkNode, TOGGLE_LINK_COMMAND, $createAutoLinkNode } from '@lexical/link';\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { mergeRegister } from '@lexical/utils';\nimport { TextNode, $getSelection, $isRangeSelection, COMMAND_PRIORITY_LOW, $isTextNode, $isElementNode, $isLineBreakNode, $createTextNode, $isNodeSelection } from 'lexical';\nimport { useEffect } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createLinkMatcherWithRegExp(regExp, urlTransformer = text => text) {\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) {\n      return null;\n    }\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(match[0])\n    };\n  };\n}\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\n\n/**\n * Check if the text content starts with a fullstop followed by a top-level domain.\n * Meaning if the text content can be a beginning of a top level domain.\n * @param textContent\n * @param isEmail\n * @returns boolean\n */\nfunction startsWithTLD(textContent, isEmail) {\n  if (isEmail) {\n    return /^\\.[a-zA-Z]{2,}/.test(textContent);\n  } else {\n    return /^\\.[a-zA-Z0-9]{1,}/.test(textContent);\n  }\n}\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n  if ($isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n  return previousNode === null || $isLineBreakNode(previousNode) || $isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n  if ($isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n  return nextNode === null || $isLineBreakNode(nextNode) || $isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\nfunction isContentAroundIsValid(matchStart, matchEnd, text, nodes) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(nodes[0]);\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(nodes[nodes.length - 1]);\n  return contentAfterIsValid;\n}\nfunction extractMatchingNodes(nodes, startIndex, endIndex) {\n  const unmodifiedBeforeNodes = [];\n  const matchingNodes = [];\n  const unmodifiedAfterNodes = [];\n  let matchingOffset = 0;\n  let currentOffset = 0;\n  const currentNodes = [...nodes];\n  while (currentNodes.length > 0) {\n    const currentNode = currentNodes[0];\n    const currentNodeText = currentNode.getTextContent();\n    const currentNodeLength = currentNodeText.length;\n    const currentNodeStart = currentOffset;\n    const currentNodeEnd = currentOffset + currentNodeLength;\n    if (currentNodeEnd <= startIndex) {\n      unmodifiedBeforeNodes.push(currentNode);\n      matchingOffset += currentNodeLength;\n    } else if (currentNodeStart >= endIndex) {\n      unmodifiedAfterNodes.push(currentNode);\n    } else {\n      matchingNodes.push(currentNode);\n    }\n    currentOffset += currentNodeLength;\n    currentNodes.shift();\n  }\n  return [matchingOffset, unmodifiedBeforeNodes, matchingNodes, unmodifiedAfterNodes];\n}\nfunction $createAutoLinkNode_(nodes, startIndex, endIndex, match) {\n  const linkNode = $createAutoLinkNode(match.url, match.attributes);\n  if (nodes.length === 1) {\n    let remainingTextNode = nodes[0];\n    let linkTextNode;\n    if (startIndex === 0) {\n      [linkTextNode, remainingTextNode] = remainingTextNode.splitText(endIndex);\n    } else {\n      [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(startIndex, endIndex);\n    }\n    const textNode = $createTextNode(match.text);\n    textNode.setFormat(linkTextNode.getFormat());\n    textNode.setDetail(linkTextNode.getDetail());\n    textNode.setStyle(linkTextNode.getStyle());\n    linkNode.append(textNode);\n    linkTextNode.replace(linkNode);\n    return remainingTextNode;\n  } else if (nodes.length > 1) {\n    const firstTextNode = nodes[0];\n    let offset = firstTextNode.getTextContent().length;\n    let firstLinkTextNode;\n    if (startIndex === 0) {\n      firstLinkTextNode = firstTextNode;\n    } else {\n      [, firstLinkTextNode] = firstTextNode.splitText(startIndex);\n    }\n    const linkNodes = [];\n    let remainingTextNode;\n    for (let i = 1; i < nodes.length; i++) {\n      const currentNode = nodes[i];\n      const currentNodeText = currentNode.getTextContent();\n      const currentNodeLength = currentNodeText.length;\n      const currentNodeStart = offset;\n      const currentNodeEnd = offset + currentNodeLength;\n      if (currentNodeStart < endIndex) {\n        if (currentNodeEnd <= endIndex) {\n          linkNodes.push(currentNode);\n        } else {\n          const [linkTextNode, endNode] = currentNode.splitText(endIndex - currentNodeStart);\n          linkNodes.push(linkTextNode);\n          remainingTextNode = endNode;\n        }\n      }\n      offset += currentNodeLength;\n    }\n    const selection = $getSelection();\n    const selectedTextNode = selection ? selection.getNodes().find($isTextNode) : undefined;\n    const textNode = $createTextNode(firstLinkTextNode.getTextContent());\n    textNode.setFormat(firstLinkTextNode.getFormat());\n    textNode.setDetail(firstLinkTextNode.getDetail());\n    textNode.setStyle(firstLinkTextNode.getStyle());\n    linkNode.append(textNode, ...linkNodes);\n    // it does not preserve caret position if caret was at the first text node\n    // so we need to restore caret position\n    if (selectedTextNode && selectedTextNode === firstLinkTextNode) {\n      if ($isRangeSelection(selection)) {\n        textNode.select(selection.anchor.offset, selection.focus.offset);\n      } else if ($isNodeSelection(selection)) {\n        textNode.select(0, textNode.getTextContent().length);\n      }\n    }\n    firstLinkTextNode.replace(linkNode);\n    return remainingTextNode;\n  }\n  return undefined;\n}\nfunction $handleLinkCreation(nodes, matchers, onChange) {\n  let currentNodes = [...nodes];\n  const initialText = currentNodes.map(node => node.getTextContent()).join('');\n  let text = initialText;\n  let match;\n  let invalidMatchEnd = 0;\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, initialText, currentNodes);\n    if (isValid) {\n      const [matchingOffset,, matchingNodes, unmodifiedAfterNodes] = extractMatchingNodes(currentNodes, invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd);\n      const actualMatchStart = invalidMatchEnd + matchStart - matchingOffset;\n      const actualMatchEnd = invalidMatchEnd + matchEnd - matchingOffset;\n      const remainingTextNode = $createAutoLinkNode_(matchingNodes, actualMatchStart, actualMatchEnd, match);\n      currentNodes = remainingTextNode ? [remainingTextNode, ...unmodifiedAfterNodes] : unmodifiedAfterNodes;\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n    text = text.substring(matchEnd);\n  }\n}\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n    if (!$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  }\n\n  // Check text content fully matches\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  // Check neighbors\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n  const url = linkNode.getURL();\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n    const target = linkNode.getTarget();\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n}\n\n// Bad neighbors are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n  if ($isAutoLinkNode(previousSibling) && !previousSibling.getIsUnlinked() && (!startsWithSeparator(text) || startsWithTLD(text, previousSibling.isEmailURI()))) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n  if ($isAutoLinkNode(nextSibling) && !nextSibling.getIsUnlinked() && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n  node.remove();\n  return children.map(child => child.getLatest());\n}\nfunction getTextNodesToMatch(textNode) {\n  // check if next siblings are simple text nodes till a node contains a space separator\n  const textNodesToMatch = [textNode];\n  let nextSibling = textNode.getNextSibling();\n  while (nextSibling !== null && $isTextNode(nextSibling) && nextSibling.isSimpleText()) {\n    textNodesToMatch.push(nextSibling);\n    if (/[\\s]/.test(nextSibling.getTextContent())) {\n      break;\n    }\n    nextSibling = nextSibling.getNextSibling();\n  }\n  return textNodesToMatch;\n}\nfunction useAutoLink(editor, matchers, onChange) {\n  useEffect(() => {\n    if (!editor.hasNodes([AutoLinkNode])) {\n      {\n        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n    return mergeRegister(editor.registerNodeTransform(TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n      const previous = textNode.getPreviousSibling();\n      if ($isAutoLinkNode(parent) && !parent.getIsUnlinked()) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!$isLinkNode(parent)) {\n        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !$isAutoLinkNode(previous))) {\n          const textNodesToMatch = getTextNodesToMatch(textNode);\n          $handleLinkCreation(textNodesToMatch, matchers, onChangeWrapped);\n        }\n        handleBadNeighbors(textNode, matchers, onChangeWrapped);\n      }\n    }), editor.registerCommand(TOGGLE_LINK_COMMAND, payload => {\n      const selection = $getSelection();\n      if (payload !== null || !$isRangeSelection(selection)) {\n        return false;\n      }\n      const nodes = selection.extract();\n      nodes.forEach(node => {\n        const parent = node.getParent();\n        if ($isAutoLinkNode(parent)) {\n          // invert the value\n          parent.setIsUnlinked(!parent.getIsUnlinked());\n          parent.markDirty();\n          return true;\n        }\n      });\n      return false;\n    }, COMMAND_PRIORITY_LOW));\n  }, [editor, matchers, onChange]);\n}\nfunction AutoLinkPlugin({\n  matchers,\n  onChange\n}) {\n  const [editor] = useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\n\nexport { AutoLinkPlugin, createLinkMatcherWithRegExp };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}