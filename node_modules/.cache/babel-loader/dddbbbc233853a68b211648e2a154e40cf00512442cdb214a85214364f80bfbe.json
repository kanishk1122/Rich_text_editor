{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar list = require('@lexical/list');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return html.$generateHtmlFromNodes(editor, selection);\n}\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n  if (selection == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      } // eslint-disable-next-line no-empty\n    } catch {}\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection); // eslint-disable-next-line no-empty\n    } catch {}\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n\n  const text = dataTransfer.getData('text/plain');\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n  let list$1 = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    /**\n     * There's no good way to add this to importDOM or importJSON directly,\n     * so this is here in order to safely correct faulty clipboard data\n     * that we can't control and avoid crashing the app.\n     * https://github.com/facebook/lexical/issues/2405\n     */\n\n    if (list.$isListItemNode(node)) {\n      if (list$1 == null) {\n        list$1 = list.$createListNode('bullet');\n        topLevelBlocks.push(list$1);\n      }\n      list$1.append(node);\n      continue;\n    } else if (list$1 != null) {\n      list$1 = null;\n    }\n    if (lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || lexical.$isLineBreakNode(node)) {\n      if (currentBlock === null) {\n        currentBlock = lexical.$createParagraphNode();\n        topLevelBlocks.push(currentBlock);\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n    anchorCell.append(...topLevelBlocks);\n  }\n}\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const newGridRowNode = newGridRows[newRowIdx];\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n    newRowIdx++;\n  }\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  const serializedChildren = serializedNode.children;\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection$1, currentNode) {\n  let targetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    serializedNode.text = target.__text;\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;","map":{"version":3,"names":["html","require","list","selection","utils","lexical","$getHtmlContent","editor","$getSelection","Error","$isRangeSelection","isCollapsed","getNodes","length","$generateHtmlFromNodes","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","htmlString","parser","DOMParser","dom","parseFromString","$generateNodesFromDOM","lines","split","linesLength","i","insertText","insertParagraph","isSelectionInsideOfGrid","DEPRECATED_$isGridSelection","$findMatchingParent","anchor","getNode","n","DEPRECATED_$isGridCellNode","focus","DEPRECATED_$isGridNode","$mergeGridNodesStrategy","$basicInsertStrategy","topLevelBlocks","currentBlock","list$1","node","$isListItemNode","$createListNode","push","append","$isDecoratorNode","isInline","$isElementNode","$isTextNode","$isLineBreakNode","$createParagraphNode","insertNodes","anchorCell","isFromLexical","newGrid","newGridRows","getChildren","newColumnCount","getFirstChildOrThrow","getChildrenSize","newRowCount","gridCellNode","gridRowNode","DEPRECATED_$isGridRowNode","gridNode","startY","getIndexWithinParent","stopY","Math","min","startX","stopX","fromX","fromY","toX","max","toY","gridRowNodes","newRowIdx","newAnchorCellKey","newFocusCellKey","r","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","c","currentGridCellNode","newGridCellNode","getKey","originalChildren","forEach","child","paragraphNode","remove","newGridSelection","DEPRECATED_$createGridSelection","set","$setSelection","dispatchCommand","SELECTION_CHANGE_COMMAND","undefined","exportNodeToJSON","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","selection$1","currentNode","targetArray","arguments","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","$cloneWithProperties","$sliceSelectedTextNodeContent","__text","childNode","shouldIncludeChild","extractWithChild","serializedChildNode","root","$getRoot","topLevelChildren","topLevelNode","serializedNodes","$parseSerializedNode","$addNodeStyle","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/clipboard/LexicalClipboard.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar list = require('@lexical/list');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return html.$generateHtmlFromNodes(editor, selection);\n}\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    throw new Error('Expected valid LexicalSelection');\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      } // eslint-disable-next-line no-empty\n\n    } catch {}\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection); // eslint-disable-next-line no-empty\n    } catch {}\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n\n\n  const text = dataTransfer.getData('text/plain');\n\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const lines = text.split(/\\r?\\n/);\n      const linesLength = lines.length;\n\n      for (let i = 0; i < linesLength; i++) {\n        selection.insertText(lines[i]);\n\n        if (i < linesLength - 1) {\n          selection.insertParagraph();\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\n\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n  let list$1 = null;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    /**\n     * There's no good way to add this to importDOM or importJSON directly,\n     * so this is here in order to safely correct faulty clipboard data\n     * that we can't control and avoid crashing the app.\n     * https://github.com/facebook/lexical/issues/2405\n     */\n\n    if (list.$isListItemNode(node)) {\n      if (list$1 == null) {\n        list$1 = list.$createListNode('bullet');\n        topLevelBlocks.push(list$1);\n      }\n\n      list$1.append(node);\n      continue;\n    } else if (list$1 != null) {\n      list$1 = null;\n    }\n\n    if (lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || lexical.$isLineBreakNode(node)) {\n      if (currentBlock === null) {\n        currentBlock = lexical.$createParagraphNode();\n        topLevelBlocks.push(currentBlock);\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...topLevelBlocks);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    serializedNode.text = target.__text;\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n}\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}