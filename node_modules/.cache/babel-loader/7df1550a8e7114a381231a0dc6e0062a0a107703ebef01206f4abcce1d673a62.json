{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar Prism = require('prismjs');\nrequire('prismjs/components/prism-clike');\nrequire('prismjs/components/prism-javascript');\nrequire('prismjs/components/prism-markup');\nrequire('prismjs/components/prism-markdown');\nrequire('prismjs/components/prism-c');\nrequire('prismjs/components/prism-css');\nrequire('prismjs/components/prism-objectivec');\nrequire('prismjs/components/prism-sql');\nrequire('prismjs/components/prism-python');\nrequire('prismjs/components/prism-rust');\nrequire('prismjs/components/prism-swift');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  css: 'CSS',\n  html: 'HTML',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter(\n// Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n/** @noInheritDoc */\n\nclass CodeHighlightNode extends lexical.TextNode {\n  /** @internal */\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n  static getType() {\n    return 'code-highlight';\n  }\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n    return update;\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  } // Prevent formatting (bold, underline, etc)\n\n  setFormat(format) {\n    return this;\n  }\n}\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\nfunction $createCodeHighlightNode(text, highlightType) {\n  return new CodeHighlightNode(text, highlightType);\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n  return currentNode;\n}\nfunction getLastCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n  return currentNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n/** @noInheritDoc */\n\nclass CodeNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'code';\n  }\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  } // View\n\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise\n      code: node => {\n        const isMultiLine = node.textContent != null && /\\r?\\n/.test(node.textContent);\n        return isMultiLine ? {\n          conversion: convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node; // domNode is a <table> since we matched it by nodeName\n\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 4\n          };\n        }\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 4\n          };\n        }\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 4\n          };\n        }\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 4\n          };\n        }\n        return null;\n      }\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  } // Mutation\n\n  insertNewAfter(selection) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement);\n      return newElement;\n    } // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n\n    const anchor = selection.anchor.getNode();\n    const firstNode = getFirstCodeHighlightNodeOfLine(anchor);\n    if (firstNode != null) {\n      let leadingWhitespace = 0;\n      const firstNodeText = firstNode.getTextContent();\n      while (leadingWhitespace < firstNodeText.length && /[\\t ]/.test(firstNodeText[leadingWhitespace])) {\n        leadingWhitespace += 1;\n      }\n      if (leadingWhitespace > 0) {\n        const whitespace = firstNodeText.substring(0, leadingWhitespace);\n        const indentedChild = $createCodeHighlightNode(whitespace);\n        anchor.insertAfter(indentedChild);\n        selection.insertNodes([lexical.$createLineBreakNode()]);\n        indentedChild.select();\n        return indentedChild;\n      }\n    }\n    return null;\n  }\n  canInsertTab() {\n    const selection = lexical.$getSelection();\n    if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return false;\n    }\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n}\nfunction $createCodeNode(language) {\n  return new CodeNode(language);\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\nfunction convertPreElement(domNode) {\n  return {\n    node: $createCodeNode(),\n    preformatted: true\n  };\n}\nfunction convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n      return childLexicalNodes;\n    },\n    node: isCode ? $createCodeNode() : null,\n    preformatted: isCode\n  };\n}\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode(),\n    preformatted: true\n  };\n}\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\nfunction convertTableCellElement(domNode) {\n  // domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction isSpaceOrTabChar(char) {\n  return char === ' ' || char === '\\t';\n}\nfunction findFirstNotSpaceOrTabCharAtText(text, isForward) {\n  const length = text.length;\n  let offset = -1;\n  if (isForward) {\n    for (let i = 0; i < length; i++) {\n      const char = text[i];\n      if (!isSpaceOrTabChar(char)) {\n        offset = i;\n        break;\n      }\n    }\n  } else {\n    for (let i = length - 1; i > -1; i--) {\n      const char = text[i];\n      if (!isSpaceOrTabChar(char)) {\n        offset = i;\n        break;\n      }\n    }\n  }\n  return offset;\n}\nfunction getStartOfCodeInLine(anchor) {\n  let currentNode = null;\n  let currentNodeOffset = -1;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n    if ($isCodeHighlightNode(node)) {\n      const text = node.getTextContent();\n      const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n      if (offset !== -1) {\n        currentNode = node;\n        currentNodeOffset = offset;\n      }\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n  if (currentNode === null) {\n    const nextSiblings = anchor.getNextSiblings();\n    while (nextSiblings.length > 0) {\n      const node = nextSiblings.shift();\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset;\n          break;\n        }\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n  }\n  return {\n    node: currentNode,\n    offset: currentNodeOffset\n  };\n}\nfunction getEndOfCodeInLine(anchor) {\n  let currentNode = null;\n  let currentNodeOffset = -1;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n    if ($isCodeHighlightNode(node)) {\n      const text = node.getTextContent();\n      const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n      if (offset !== -1) {\n        currentNode = node;\n        currentNodeOffset = offset + 1;\n      }\n    }\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n  if (currentNode === null) {\n    const previousSiblings = anchor.getPreviousSiblings();\n    while (previousSiblings.length > 0) {\n      const node = previousSiblings.pop();\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset + 1;\n          break;\n        }\n      }\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n  }\n  return {\n    node: currentNode,\n    offset: currentNodeOffset\n  };\n}\nfunction textNodeTransform(node, editor) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n  if (codeElement === null) {\n    return;\n  }\n  const children = node.getChildren();\n  const childrenLength = children.length; // @ts-ignore: internal field\n\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  } // @ts-ignore:: internal field\n\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n  codeElement.setAttribute('data-gutter', gutter);\n} // Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra flag (`isHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\nlet isHighlighting = false;\nfunction codeNodeTransform(node, editor) {\n  if (isHighlighting) {\n    return;\n  }\n  isHighlighting = true; // When new code block inserted it might not have language selected\n\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(DEFAULT_CODE_LANGUAGE);\n  }\n  const nodeKey = node.getKey(); // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n\n  editor.update(() => {\n    updateAndRetainSelection(nodeKey, () => {\n      const currentNode = lexical.$getNodeByKey(nodeKey);\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n      const code = currentNode.getTextContent();\n      const tokens = Prism.tokenize(code, Prism.languages[currentNode.getLanguage() || ''] || Prism.languages[DEFAULT_CODE_LANGUAGE]);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      isHighlighting = false;\n    },\n    skipTransforms: true\n  });\n}\nfunction getHighlightNodes(tokens) {\n  const nodes = [];\n  tokens.forEach(token => {\n    if (typeof token === 'string') {\n      const partials = token.split('\\n');\n      for (let i = 0; i < partials.length; i++) {\n        const text = partials[i];\n        if (text.length) {\n          nodes.push($createCodeHighlightNode(text));\n        }\n        if (i < partials.length - 1) {\n          nodes.push(lexical.$createLineBreakNode());\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n      if (typeof content === 'string') {\n        nodes.push($createCodeHighlightNode(content, token.type));\n      } else if (Array.isArray(content) && content.length === 1 && typeof content[0] === 'string') {\n        nodes.push($createCodeHighlightNode(content[0], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...getHighlightNodes(content));\n      }\n    }\n  });\n  return nodes;\n} // Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\n\nfunction updateAndRetainSelection(nodeKey, updateFn) {\n  const node = lexical.$getNodeByKey(nodeKey);\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n  const selection = lexical.$getSelection(); // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n\n  if (!lexical.$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + (lexical.$isLineBreakNode(_node) ? 0 : _node.getTextContentSize());\n    }, 0);\n  }\n  const hasChanges = updateFn();\n  if (!hasChanges) {\n    return;\n  } // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  } // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n\n  node.getChildren().some(_node => {\n    if (lexical.$isTextNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n      if (textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n        return true;\n      }\n      textOffset -= textContentSize;\n    }\n    return false;\n  });\n} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\n\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n    leadingMatch++;\n  }\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {\n    return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;\n  }\n  if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {\n    return true;\n  }\n  return false;\n}\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {\n    return false;\n  } // Only run multiline indent logic on selections exclusively composed of code highlights and linebreaks\n\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n  const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);\n  if (startOfLine != null) {\n    doIndent(startOfLine, type);\n  }\n  for (let i = 1; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {\n      doIndent(node, type);\n    }\n  }\n  return true;\n}\nfunction doIndent(node, type) {\n  const text = node.getTextContent();\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    // If the codeblock node doesn't start with whitespace, we don't want to\n    // naively prepend a '\\t'; Prism will then mangle all of our nodes when\n    // it separates the whitespace from the first non-whitespace node. This\n    // will lead to selection bugs when indenting lines that previously\n    // didn't start with a whitespace character\n    if (text.length > 0 && /\\s/.test(text[0])) {\n      node.setTextContent('\\t' + text);\n    } else {\n      const indentNode = $createCodeHighlightNode('\\t');\n      node.insertBefore(indentNode);\n    }\n  } else {\n    if (text.indexOf('\\t') === 0) {\n      // Same as above - if we leave empty text nodes lying around, the resulting\n      // selection will be mangled\n      if (text.length === 1) {\n        node.remove();\n      } else {\n        node.setTextContent(text.substring(1));\n      }\n    }\n  }\n}\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock\n\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  const start = getFirstCodeHighlightNodeOfLine(anchorNode);\n  const end = getLastCodeHighlightNodeOfLine(focusNode);\n  if (start == null || end == null) {\n    return false;\n  }\n  const range = start.getNodesBetween(end);\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  } // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n  if (sibling == null) {\n    return true;\n  }\n  const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\nfunction handleMoveTo(type, event) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === lexical.MOVE_TO_START;\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n  let node;\n  let offset;\n  if (isMoveToStart) {\n    ({\n      node,\n      offset\n    } = getStartOfCodeInLine(focusNode));\n  } else {\n    ({\n      node,\n      offset\n    } = getEndOfCodeInLine(focusNode));\n  }\n  if (node !== null && offset !== -1) {\n    selection.setTextNodeRange(node, offset, node, offset);\n  }\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\nfunction registerCodeHighlighting(editor) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n}\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getEndOfCodeInLine = getEndOfCodeInLine;\nexports.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;\nexports.getLanguageFriendlyName = getLanguageFriendlyName;\nexports.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;\nexports.getStartOfCodeInLine = getStartOfCodeInLine;\nexports.normalizeCodeLang = normalizeCodeLang;\nexports.registerCodeHighlighting = registerCodeHighlighting;","map":{"version":3,"names":["Prism","require","utils","lexical","DEFAULT_CODE_LANGUAGE","CODE_LANGUAGE_FRIENDLY_NAME_MAP","c","clike","css","html","js","markdown","objc","plain","py","rust","sql","swift","xml","CODE_LANGUAGE_MAP","javascript","md","plaintext","python","text","normalizeCodeLang","lang","getLanguageFriendlyName","_lang","getDefaultCodeLanguage","getCodeLanguages","Object","keys","languages","filter","language","sort","CodeHighlightNode","TextNode","constructor","highlightType","key","__highlightType","getType","clone","node","__text","undefined","__key","getHighlightType","self","getLatest","createDOM","config","element","className","getHighlightThemeClass","theme","addClassNamesToElement","updateDOM","prevNode","dom","update","prevClassName","nextClassName","removeClassNamesFromElement","importJSON","serializedNode","$createCodeHighlightNode","setFormat","format","setDetail","detail","setMode","mode","setStyle","style","exportJSON","type","version","codeHighlight","$isCodeHighlightNode","getFirstCodeHighlightNodeOfLine","anchor","currentNode","previousSiblings","getPreviousSiblings","push","length","pop","$isLineBreakNode","getLastCodeHighlightNodeOfLine","nextSiblings","getNextSiblings","unshift","shift","mapToPrismLanguage","hasOwnProperty","LANGUAGE_DATA_ATTRIBUTE","CodeNode","ElementNode","__language","document","createElement","code","setAttribute","getLanguage","prevLanguage","removeAttribute","importDOM","isMultiLine","textContent","test","conversion","convertPreElement","priority","div","convertDivElement","pre","table","isGitHubCodeTable","convertTableElement","td","closest","isGitHubCodeCell","convertTableCellElement","convertCodeNoop","tr","$createCodeNode","setIndent","indent","setDirection","direction","insertNewAfter","selection","children","getChildren","childrenLength","getTextContent","isCollapsed","offset","remove","newElement","$createParagraphNode","insertAfter","getNode","firstNode","leadingWhitespace","firstNodeText","whitespace","substring","indentedChild","insertNodes","$createLineBreakNode","select","canInsertTab","$getSelection","$isRangeSelection","canIndent","collapseAtStart","paragraph","forEach","child","append","replace","setLanguage","writable","getWritable","$isCodeNode","domNode","preformatted","isCode","isCodeElement","after","childLexicalNodes","domParent","parentNode","lastChild","cell","nextSibling","fontFamily","match","classList","contains","isSpaceOrTabChar","char","findFirstNotSpaceOrTabCharAtText","isForward","i","getStartOfCodeInLine","currentNodeOffset","getEndOfCodeInLine","textNodeTransform","editor","getParent","codeNodeTransform","$createTextNode","updateCodeGutter","codeElement","getElementByKey","getKey","__cachedChildrenLength","gutter","count","isHighlighting","nodeKey","updateAndRetainSelection","$getNodeByKey","isAttached","tokens","tokenize","highlightNodes","getHighlightNodes","diffRange","getDiffRange","from","to","nodesForReplacement","splice","onUpdate","skipTransforms","nodes","token","partials","split","content","Array","isArray","updateFn","anchorOffset","isNewLineAnchor","getChildAtIndex","textOffset","anchorNode","reduce","_node","getTextContentSize","hasChanges","some","$isTextNode","textContentSize","prevNodes","nextNodes","leadingMatch","isEqual","prevNodesLength","nextNodesLength","maxTrailingMatch","Math","min","trailingMatch","slice","nodeA","nodeB","handleMultilineIndent","getNodes","startOfLine","doIndent","INDENT_CONTENT_COMMAND","setTextContent","indentNode","insertBefore","indexOf","handleShiftLines","event","focus","focusOffset","focusNode","arrowIsUp","KEY_ARROW_UP_COMMAND","altKey","codeNode","getParentOrThrow","getPreviousSibling","codeNodeSibling","selectPrevious","preventDefault","getNextSibling","selectNext","start","end","range","getNodesBetween","stopPropagation","linebreak","sibling","maybeInsertionPoint","insertionPoint","setTextNodeRange","handleMoveTo","isMoveToStart","MOVE_TO_START","registerCodeHighlighting","hasNodes","Error","mergeRegister","registerMutationListener","mutations","registerNodeTransform","registerCommand","payload","COMMAND_PRIORITY_LOW","OUTDENT_CONTENT_COMMAND","KEY_ARROW_DOWN_COMMAND","MOVE_TO_END","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/code/LexicalCode.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar Prism = require('prismjs');\nrequire('prismjs/components/prism-clike');\nrequire('prismjs/components/prism-javascript');\nrequire('prismjs/components/prism-markup');\nrequire('prismjs/components/prism-markdown');\nrequire('prismjs/components/prism-c');\nrequire('prismjs/components/prism-css');\nrequire('prismjs/components/prism-objectivec');\nrequire('prismjs/components/prism-sql');\nrequire('prismjs/components/prism-python');\nrequire('prismjs/components/prism-rust');\nrequire('prismjs/components/prism-swift');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst DEFAULT_CODE_LANGUAGE = 'javascript';\nconst CODE_LANGUAGE_FRIENDLY_NAME_MAP = {\n  c: 'C',\n  clike: 'C-like',\n  css: 'CSS',\n  html: 'HTML',\n  js: 'JavaScript',\n  markdown: 'Markdown',\n  objc: 'Objective-C',\n  plain: 'Plain Text',\n  py: 'Python',\n  rust: 'Rust',\n  sql: 'SQL',\n  swift: 'Swift',\n  xml: 'XML'\n};\nconst CODE_LANGUAGE_MAP = {\n  javascript: 'js',\n  md: 'markdown',\n  plaintext: 'plain',\n  python: 'py',\n  text: 'plain'\n};\nfunction normalizeCodeLang(lang) {\n  return CODE_LANGUAGE_MAP[lang] || lang;\n}\nfunction getLanguageFriendlyName(lang) {\n  const _lang = normalizeCodeLang(lang);\n\n  return CODE_LANGUAGE_FRIENDLY_NAME_MAP[_lang] || _lang;\n}\nconst getDefaultCodeLanguage = () => DEFAULT_CODE_LANGUAGE;\nconst getCodeLanguages = () => Object.keys(Prism.languages).filter( // Prism has several language helpers mixed into languages object\n// so filtering them out here to get langs list\nlanguage => typeof Prism.languages[language] !== 'function').sort();\n/** @noInheritDoc */\n\nclass CodeHighlightNode extends lexical.TextNode {\n  /** @internal */\n  constructor(text, highlightType, key) {\n    super(text, key);\n    this.__highlightType = highlightType;\n  }\n\n  static getType() {\n    return 'code-highlight';\n  }\n\n  static clone(node) {\n    return new CodeHighlightNode(node.__text, node.__highlightType || undefined, node.__key);\n  }\n\n  getHighlightType() {\n    const self = this.getLatest();\n    return self.__highlightType;\n  }\n\n  createDOM(config) {\n    const element = super.createDOM(config);\n    const className = getHighlightThemeClass(config.theme, this.__highlightType);\n    utils.addClassNamesToElement(element, className);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const update = super.updateDOM(prevNode, dom, config);\n    const prevClassName = getHighlightThemeClass(config.theme, prevNode.__highlightType);\n    const nextClassName = getHighlightThemeClass(config.theme, this.__highlightType);\n\n    if (prevClassName !== nextClassName) {\n      if (prevClassName) {\n        utils.removeClassNamesFromElement(dom, prevClassName);\n      }\n\n      if (nextClassName) {\n        utils.addClassNamesToElement(dom, nextClassName);\n      }\n    }\n\n    return update;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeHighlightNode(serializedNode.text, serializedNode.highlightType);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      highlightType: this.getHighlightType(),\n      type: 'code-highlight',\n      version: 1\n    };\n  } // Prevent formatting (bold, underline, etc)\n\n\n  setFormat(format) {\n    return this;\n  }\n\n}\n\nfunction getHighlightThemeClass(theme, highlightType) {\n  return highlightType && theme && theme.codeHighlight && theme.codeHighlight[highlightType];\n}\n\nfunction $createCodeHighlightNode(text, highlightType) {\n  return new CodeHighlightNode(text, highlightType);\n}\nfunction $isCodeHighlightNode(node) {\n  return node instanceof CodeHighlightNode;\n}\nfunction getFirstCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  return currentNode;\n}\nfunction getLastCodeHighlightNodeOfLine(anchor) {\n  let currentNode = null;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n\n    if ($isCodeHighlightNode(node)) {\n      currentNode = node;\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  return currentNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mapToPrismLanguage = language => {\n  // eslint-disable-next-line no-prototype-builtins\n  return language != null && Prism.languages.hasOwnProperty(language) ? language : undefined;\n};\n\nconst LANGUAGE_DATA_ATTRIBUTE = 'data-highlight-language';\n/** @noInheritDoc */\n\nclass CodeNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'code';\n  }\n\n  static clone(node) {\n    return new CodeNode(node.__language, node.__key);\n  }\n\n  constructor(language, key) {\n    super(key);\n    this.__language = mapToPrismLanguage(language);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('code');\n    utils.addClassNamesToElement(element, config.theme.code);\n    element.setAttribute('spellcheck', 'false');\n    const language = this.getLanguage();\n\n    if (language) {\n      element.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    const language = this.__language;\n    const prevLanguage = prevNode.__language;\n\n    if (language) {\n      if (language !== prevLanguage) {\n        dom.setAttribute(LANGUAGE_DATA_ATTRIBUTE, language);\n      }\n    } else if (prevLanguage) {\n      dom.removeAttribute(LANGUAGE_DATA_ATTRIBUTE);\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      // Typically <pre> is used for code blocks, and <code> for inline code styles\n      // but if it's a multi line <code> we'll create a block. Pass through to\n      // inline format handled by TextNode otherwise\n      code: node => {\n        const isMultiLine = node.textContent != null && /\\r?\\n/.test(node.textContent);\n        return isMultiLine ? {\n          conversion: convertPreElement,\n          priority: 1\n        } : null;\n      },\n      div: node => ({\n        conversion: convertDivElement,\n        priority: 1\n      }),\n      pre: node => ({\n        conversion: convertPreElement,\n        priority: 0\n      }),\n      table: node => {\n        const table = node; // domNode is a <table> since we matched it by nodeName\n\n        if (isGitHubCodeTable(table)) {\n          return {\n            conversion: convertTableElement,\n            priority: 4\n          };\n        }\n\n        return null;\n      },\n      td: node => {\n        // element is a <td> since we matched it by nodeName\n        const td = node;\n        const table = td.closest('table');\n\n        if (isGitHubCodeCell(td)) {\n          return {\n            conversion: convertTableCellElement,\n            priority: 4\n          };\n        }\n\n        if (table && isGitHubCodeTable(table)) {\n          // Return a no-op if it's a table cell in a code table, but not a code line.\n          // Otherwise it'll fall back to the T\n          return {\n            conversion: convertCodeNoop,\n            priority: 4\n          };\n        }\n\n        return null;\n      },\n      tr: node => {\n        // element is a <tr> since we matched it by nodeName\n        const tr = node;\n        const table = tr.closest('table');\n\n        if (table && isGitHubCodeTable(table)) {\n          return {\n            conversion: convertCodeNoop,\n            priority: 4\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createCodeNode(serializedNode.language);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      language: this.getLanguage(),\n      type: 'code',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    if (childrenLength >= 2 && children[childrenLength - 1].getTextContent() === '\\n' && children[childrenLength - 2].getTextContent() === '\\n' && selection.isCollapsed() && selection.anchor.key === this.__key && selection.anchor.offset === childrenLength) {\n      children[childrenLength - 1].remove();\n      children[childrenLength - 2].remove();\n      const newElement = lexical.$createParagraphNode();\n      this.insertAfter(newElement);\n      return newElement;\n    } // If the selection is within the codeblock, find all leading tabs and\n    // spaces of the current line. Create a new line that has all those\n    // tabs and spaces, such that leading indentation is preserved.\n\n\n    const anchor = selection.anchor.getNode();\n    const firstNode = getFirstCodeHighlightNodeOfLine(anchor);\n\n    if (firstNode != null) {\n      let leadingWhitespace = 0;\n      const firstNodeText = firstNode.getTextContent();\n\n      while (leadingWhitespace < firstNodeText.length && /[\\t ]/.test(firstNodeText[leadingWhitespace])) {\n        leadingWhitespace += 1;\n      }\n\n      if (leadingWhitespace > 0) {\n        const whitespace = firstNodeText.substring(0, leadingWhitespace);\n        const indentedChild = $createCodeHighlightNode(whitespace);\n        anchor.insertAfter(indentedChild);\n        selection.insertNodes([lexical.$createLineBreakNode()]);\n        indentedChild.select();\n        return indentedChild;\n      }\n    }\n\n    return null;\n  }\n\n  canInsertTab() {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n  setLanguage(language) {\n    const writable = this.getWritable();\n    writable.__language = mapToPrismLanguage(language);\n  }\n\n  getLanguage() {\n    return this.getLatest().__language;\n  }\n\n}\nfunction $createCodeNode(language) {\n  return new CodeNode(language);\n}\nfunction $isCodeNode(node) {\n  return node instanceof CodeNode;\n}\n\nfunction convertPreElement(domNode) {\n  return {\n    node: $createCodeNode(),\n    preformatted: true\n  };\n}\n\nfunction convertDivElement(domNode) {\n  // domNode is a <div> since we matched it by nodeName\n  const div = domNode;\n  const isCode = isCodeElement(div);\n  return {\n    after: childLexicalNodes => {\n      const domParent = domNode.parentNode;\n\n      if (domParent != null && domNode !== domParent.lastChild) {\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: isCode ? $createCodeNode() : null,\n    preformatted: isCode\n  };\n}\n\nfunction convertTableElement() {\n  return {\n    node: $createCodeNode(),\n    preformatted: true\n  };\n}\n\nfunction convertCodeNoop() {\n  return {\n    node: null\n  };\n}\n\nfunction convertTableCellElement(domNode) {\n  // domNode is a <td> since we matched it by nodeName\n  const cell = domNode;\n  return {\n    after: childLexicalNodes => {\n      if (cell.parentNode && cell.parentNode.nextSibling) {\n        // Append newline between code lines\n        childLexicalNodes.push(lexical.$createLineBreakNode());\n      }\n\n      return childLexicalNodes;\n    },\n    node: null\n  };\n}\n\nfunction isCodeElement(div) {\n  return div.style.fontFamily.match('monospace') !== null;\n}\n\nfunction isGitHubCodeCell(cell) {\n  return cell.classList.contains('js-file-line');\n}\n\nfunction isGitHubCodeTable(table) {\n  return table.classList.contains('js-file-line-container');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction isSpaceOrTabChar(char) {\n  return char === ' ' || char === '\\t';\n}\n\nfunction findFirstNotSpaceOrTabCharAtText(text, isForward) {\n  const length = text.length;\n  let offset = -1;\n\n  if (isForward) {\n    for (let i = 0; i < length; i++) {\n      const char = text[i];\n\n      if (!isSpaceOrTabChar(char)) {\n        offset = i;\n        break;\n      }\n    }\n  } else {\n    for (let i = length - 1; i > -1; i--) {\n      const char = text[i];\n\n      if (!isSpaceOrTabChar(char)) {\n        offset = i;\n        break;\n      }\n    }\n  }\n\n  return offset;\n}\n\nfunction getStartOfCodeInLine(anchor) {\n  let currentNode = null;\n  let currentNodeOffset = -1;\n  const previousSiblings = anchor.getPreviousSiblings();\n  previousSiblings.push(anchor);\n\n  while (previousSiblings.length > 0) {\n    const node = previousSiblings.pop();\n\n    if ($isCodeHighlightNode(node)) {\n      const text = node.getTextContent();\n      const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n\n      if (offset !== -1) {\n        currentNode = node;\n        currentNodeOffset = offset;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  if (currentNode === null) {\n    const nextSiblings = anchor.getNextSiblings();\n\n    while (nextSiblings.length > 0) {\n      const node = nextSiblings.shift();\n\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, true);\n\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset;\n          break;\n        }\n      }\n\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n  }\n\n  return {\n    node: currentNode,\n    offset: currentNodeOffset\n  };\n}\nfunction getEndOfCodeInLine(anchor) {\n  let currentNode = null;\n  let currentNodeOffset = -1;\n  const nextSiblings = anchor.getNextSiblings();\n  nextSiblings.unshift(anchor);\n\n  while (nextSiblings.length > 0) {\n    const node = nextSiblings.shift();\n\n    if ($isCodeHighlightNode(node)) {\n      const text = node.getTextContent();\n      const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n\n      if (offset !== -1) {\n        currentNode = node;\n        currentNodeOffset = offset + 1;\n      }\n    }\n\n    if (lexical.$isLineBreakNode(node)) {\n      break;\n    }\n  }\n\n  if (currentNode === null) {\n    const previousSiblings = anchor.getPreviousSiblings();\n\n    while (previousSiblings.length > 0) {\n      const node = previousSiblings.pop();\n\n      if ($isCodeHighlightNode(node)) {\n        const text = node.getTextContent();\n        const offset = findFirstNotSpaceOrTabCharAtText(text, false);\n\n        if (offset !== -1) {\n          currentNode = node;\n          currentNodeOffset = offset + 1;\n          break;\n        }\n      }\n\n      if (lexical.$isLineBreakNode(node)) {\n        break;\n      }\n    }\n  }\n\n  return {\n    node: currentNode,\n    offset: currentNodeOffset\n  };\n}\n\nfunction textNodeTransform(node, editor) {\n  // Since CodeNode has flat children structure we only need to check\n  // if node's parent is a code node and run highlighting if so\n  const parentNode = node.getParent();\n\n  if ($isCodeNode(parentNode)) {\n    codeNodeTransform(parentNode, editor);\n  } else if ($isCodeHighlightNode(node)) {\n    // When code block converted into paragraph or other element\n    // code highlight nodes converted back to normal text\n    node.replace(lexical.$createTextNode(node.__text));\n  }\n}\n\nfunction updateCodeGutter(node, editor) {\n  const codeElement = editor.getElementByKey(node.getKey());\n\n  if (codeElement === null) {\n    return;\n  }\n\n  const children = node.getChildren();\n  const childrenLength = children.length; // @ts-ignore: internal field\n\n  if (childrenLength === codeElement.__cachedChildrenLength) {\n    // Avoid updating the attribute if the children length hasn't changed.\n    return;\n  } // @ts-ignore:: internal field\n\n\n  codeElement.__cachedChildrenLength = childrenLength;\n  let gutter = '1';\n  let count = 1;\n\n  for (let i = 0; i < childrenLength; i++) {\n    if (lexical.$isLineBreakNode(children[i])) {\n      gutter += '\\n' + ++count;\n    }\n  }\n\n  codeElement.setAttribute('data-gutter', gutter);\n} // Using `skipTransforms` to prevent extra transforms since reformatting the code\n// will not affect code block content itself.\n//\n// Using extra flag (`isHighlighting`) since both CodeNode and CodeHighlightNode\n// transforms might be called at the same time (e.g. new CodeHighlight node inserted) and\n// in both cases we'll rerun whole reformatting over CodeNode, which is redundant.\n// Especially when pasting code into CodeBlock.\n\n\nlet isHighlighting = false;\n\nfunction codeNodeTransform(node, editor) {\n  if (isHighlighting) {\n    return;\n  }\n\n  isHighlighting = true; // When new code block inserted it might not have language selected\n\n  if (node.getLanguage() === undefined) {\n    node.setLanguage(DEFAULT_CODE_LANGUAGE);\n  }\n\n  const nodeKey = node.getKey(); // Using nested update call to pass `skipTransforms` since we don't want\n  // each individual codehighlight node to be transformed again as it's already\n  // in its final state\n\n  editor.update(() => {\n    updateAndRetainSelection(nodeKey, () => {\n      const currentNode = lexical.$getNodeByKey(nodeKey);\n\n      if (!$isCodeNode(currentNode) || !currentNode.isAttached()) {\n        return false;\n      }\n\n      const code = currentNode.getTextContent();\n      const tokens = Prism.tokenize(code, Prism.languages[currentNode.getLanguage() || ''] || Prism.languages[DEFAULT_CODE_LANGUAGE]);\n      const highlightNodes = getHighlightNodes(tokens);\n      const diffRange = getDiffRange(currentNode.getChildren(), highlightNodes);\n      const {\n        from,\n        to,\n        nodesForReplacement\n      } = diffRange;\n\n      if (from !== to || nodesForReplacement.length) {\n        node.splice(from, to - from, nodesForReplacement);\n        return true;\n      }\n\n      return false;\n    });\n  }, {\n    onUpdate: () => {\n      isHighlighting = false;\n    },\n    skipTransforms: true\n  });\n}\n\nfunction getHighlightNodes(tokens) {\n  const nodes = [];\n  tokens.forEach(token => {\n    if (typeof token === 'string') {\n      const partials = token.split('\\n');\n\n      for (let i = 0; i < partials.length; i++) {\n        const text = partials[i];\n\n        if (text.length) {\n          nodes.push($createCodeHighlightNode(text));\n        }\n\n        if (i < partials.length - 1) {\n          nodes.push(lexical.$createLineBreakNode());\n        }\n      }\n    } else {\n      const {\n        content\n      } = token;\n\n      if (typeof content === 'string') {\n        nodes.push($createCodeHighlightNode(content, token.type));\n      } else if (Array.isArray(content) && content.length === 1 && typeof content[0] === 'string') {\n        nodes.push($createCodeHighlightNode(content[0], token.type));\n      } else if (Array.isArray(content)) {\n        nodes.push(...getHighlightNodes(content));\n      }\n    }\n  });\n  return nodes;\n} // Wrapping update function into selection retainer, that tries to keep cursor at the same\n// position as before.\n\n\nfunction updateAndRetainSelection(nodeKey, updateFn) {\n  const node = lexical.$getNodeByKey(nodeKey);\n\n  if (!$isCodeNode(node) || !node.isAttached()) {\n    return;\n  }\n\n  const selection = lexical.$getSelection(); // If it's not range selection (or null selection) there's no need to change it,\n  // but we can still run highlighting logic\n\n  if (!lexical.$isRangeSelection(selection)) {\n    updateFn();\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const isNewLineAnchor = anchor.type === 'element' && lexical.$isLineBreakNode(node.getChildAtIndex(anchor.offset - 1));\n  let textOffset = 0; // Calculating previous text offset (all text node prior to anchor + anchor own text offset)\n\n  if (!isNewLineAnchor) {\n    const anchorNode = anchor.getNode();\n    textOffset = anchorOffset + anchorNode.getPreviousSiblings().reduce((offset, _node) => {\n      return offset + (lexical.$isLineBreakNode(_node) ? 0 : _node.getTextContentSize());\n    }, 0);\n  }\n\n  const hasChanges = updateFn();\n\n  if (!hasChanges) {\n    return;\n  } // Non-text anchors only happen for line breaks, otherwise\n  // selection will be within text node (code highlight node)\n\n\n  if (isNewLineAnchor) {\n    anchor.getNode().select(anchorOffset, anchorOffset);\n    return;\n  } // If it was non-element anchor then we walk through child nodes\n  // and looking for a position of original text offset\n\n\n  node.getChildren().some(_node => {\n    if (lexical.$isTextNode(_node)) {\n      const textContentSize = _node.getTextContentSize();\n\n      if (textContentSize >= textOffset) {\n        _node.select(textOffset, textOffset);\n\n        return true;\n      }\n\n      textOffset -= textContentSize;\n    }\n\n    return false;\n  });\n} // Finds minimal diff range between two nodes lists. It returns from/to range boundaries of prevNodes\n// that needs to be replaced with `nodes` (subset of nextNodes) to make prevNodes equal to nextNodes.\n\n\nfunction getDiffRange(prevNodes, nextNodes) {\n  let leadingMatch = 0;\n\n  while (leadingMatch < prevNodes.length) {\n    if (!isEqual(prevNodes[leadingMatch], nextNodes[leadingMatch])) {\n      break;\n    }\n\n    leadingMatch++;\n  }\n\n  const prevNodesLength = prevNodes.length;\n  const nextNodesLength = nextNodes.length;\n  const maxTrailingMatch = Math.min(prevNodesLength, nextNodesLength) - leadingMatch;\n  let trailingMatch = 0;\n\n  while (trailingMatch < maxTrailingMatch) {\n    trailingMatch++;\n\n    if (!isEqual(prevNodes[prevNodesLength - trailingMatch], nextNodes[nextNodesLength - trailingMatch])) {\n      trailingMatch--;\n      break;\n    }\n  }\n\n  const from = leadingMatch;\n  const to = prevNodesLength - trailingMatch;\n  const nodesForReplacement = nextNodes.slice(leadingMatch, nextNodesLength - trailingMatch);\n  return {\n    from,\n    nodesForReplacement,\n    to\n  };\n}\n\nfunction isEqual(nodeA, nodeB) {\n  // Only checking for code higlight nodes and linebreaks. If it's regular text node\n  // returning false so that it's transformed into code highlight node\n  if ($isCodeHighlightNode(nodeA) && $isCodeHighlightNode(nodeB)) {\n    return nodeA.__text === nodeB.__text && nodeA.__highlightType === nodeB.__highlightType;\n  }\n\n  if (lexical.$isLineBreakNode(nodeA) && lexical.$isLineBreakNode(nodeB)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleMultilineIndent(type) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || selection.isCollapsed()) {\n    return false;\n  } // Only run multiline indent logic on selections exclusively composed of code highlights and linebreaks\n\n\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  }\n\n  const startOfLine = getFirstCodeHighlightNodeOfLine(nodes[0]);\n\n  if (startOfLine != null) {\n    doIndent(startOfLine, type);\n  }\n\n  for (let i = 1; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isLineBreakNode(nodes[i - 1]) && $isCodeHighlightNode(node)) {\n      doIndent(node, type);\n    }\n  }\n\n  return true;\n}\n\nfunction doIndent(node, type) {\n  const text = node.getTextContent();\n\n  if (type === lexical.INDENT_CONTENT_COMMAND) {\n    // If the codeblock node doesn't start with whitespace, we don't want to\n    // naively prepend a '\\t'; Prism will then mangle all of our nodes when\n    // it separates the whitespace from the first non-whitespace node. This\n    // will lead to selection bugs when indenting lines that previously\n    // didn't start with a whitespace character\n    if (text.length > 0 && /\\s/.test(text[0])) {\n      node.setTextContent('\\t' + text);\n    } else {\n      const indentNode = $createCodeHighlightNode('\\t');\n      node.insertBefore(indentNode);\n    }\n  } else {\n    if (text.indexOf('\\t') === 0) {\n      // Same as above - if we leave empty text nodes lying around, the resulting\n      // selection will be mangled\n      if (text.length === 1) {\n        node.remove();\n      } else {\n        node.setTextContent(text.substring(1));\n      }\n    }\n  }\n}\n\nfunction handleShiftLines(type, event) {\n  // We only care about the alt+arrow keys\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  } // I'm not quite sure why, but it seems like calling anchor.getNode() collapses the selection here\n  // So first, get the anchor and the focus, then get their nodes\n\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const arrowIsUp = type === lexical.KEY_ARROW_UP_COMMAND; // Ensure the selection is within the codeblock\n\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n\n  if (!event.altKey) {\n    // Handle moving selection out of the code block, given there are no\n    // sibling thats can natively take the selection.\n    if (selection.isCollapsed()) {\n      const codeNode = anchorNode.getParentOrThrow();\n\n      if (arrowIsUp && anchorOffset === 0 && anchorNode.getPreviousSibling() === null) {\n        const codeNodeSibling = codeNode.getPreviousSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectPrevious();\n          event.preventDefault();\n          return true;\n        }\n      } else if (!arrowIsUp && anchorOffset === anchorNode.getTextContentSize() && anchorNode.getNextSibling() === null) {\n        const codeNodeSibling = codeNode.getNextSibling();\n\n        if (codeNodeSibling === null) {\n          codeNode.selectNext();\n          event.preventDefault();\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  const start = getFirstCodeHighlightNodeOfLine(anchorNode);\n  const end = getLastCodeHighlightNodeOfLine(focusNode);\n\n  if (start == null || end == null) {\n    return false;\n  }\n\n  const range = start.getNodesBetween(end);\n\n  for (let i = 0; i < range.length; i++) {\n    const node = range[i];\n\n    if (!$isCodeHighlightNode(node) && !lexical.$isLineBreakNode(node)) {\n      return false;\n    }\n  } // After this point, we know the selection is within the codeblock. We may not be able to\n  // actually move the lines around, but we want to return true either way to prevent\n  // the event's default behavior\n\n\n  event.preventDefault();\n  event.stopPropagation(); // required to stop cursor movement under Firefox\n\n  const linebreak = arrowIsUp ? start.getPreviousSibling() : end.getNextSibling();\n\n  if (!lexical.$isLineBreakNode(linebreak)) {\n    return true;\n  }\n\n  const sibling = arrowIsUp ? linebreak.getPreviousSibling() : linebreak.getNextSibling();\n\n  if (sibling == null) {\n    return true;\n  }\n\n  const maybeInsertionPoint = arrowIsUp ? getFirstCodeHighlightNodeOfLine(sibling) : getLastCodeHighlightNodeOfLine(sibling);\n  let insertionPoint = maybeInsertionPoint != null ? maybeInsertionPoint : sibling;\n  linebreak.remove();\n  range.forEach(node => node.remove());\n\n  if (type === lexical.KEY_ARROW_UP_COMMAND) {\n    range.forEach(node => insertionPoint.insertBefore(node));\n    insertionPoint.insertBefore(linebreak);\n  } else {\n    insertionPoint.insertAfter(linebreak);\n    insertionPoint = linebreak;\n    range.forEach(node => {\n      insertionPoint.insertAfter(node);\n      insertionPoint = node;\n    });\n  }\n\n  selection.setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset);\n  return true;\n}\n\nfunction handleMoveTo(type, event) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  const isMoveToStart = type === lexical.MOVE_TO_START;\n\n  if (!$isCodeHighlightNode(anchorNode) || !$isCodeHighlightNode(focusNode)) {\n    return false;\n  }\n\n  let node;\n  let offset;\n\n  if (isMoveToStart) {\n    ({\n      node,\n      offset\n    } = getStartOfCodeInLine(focusNode));\n  } else {\n    ({\n      node,\n      offset\n    } = getEndOfCodeInLine(focusNode));\n  }\n\n  if (node !== null && offset !== -1) {\n    selection.setTextNodeRange(node, offset, node, offset);\n  }\n\n  event.preventDefault();\n  event.stopPropagation();\n  return true;\n}\n\nfunction registerCodeHighlighting(editor) {\n  if (!editor.hasNodes([CodeNode, CodeHighlightNode])) {\n    throw new Error('CodeHighlightPlugin: CodeNode or CodeHighlightNode not registered on editor');\n  }\n\n  return utils.mergeRegister(editor.registerMutationListener(CodeNode, mutations => {\n    editor.update(() => {\n      for (const [key, type] of mutations) {\n        if (type !== 'destroyed') {\n          const node = lexical.$getNodeByKey(key);\n\n          if (node !== null) {\n            updateCodeGutter(node, editor);\n          }\n        }\n      }\n    });\n  }), editor.registerNodeTransform(CodeNode, node => codeNodeTransform(node, editor)), editor.registerNodeTransform(lexical.TextNode, node => textNodeTransform(node, editor)), editor.registerNodeTransform(CodeHighlightNode, node => textNodeTransform(node, editor)), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.INDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, payload => handleMultilineIndent(lexical.OUTDENT_CONTENT_COMMAND), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_UP_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => handleShiftLines(lexical.KEY_ARROW_DOWN_COMMAND, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_END, payload => handleMoveTo(lexical.MOVE_TO_END, payload), lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.MOVE_TO_START, payload => handleMoveTo(lexical.MOVE_TO_START, payload), lexical.COMMAND_PRIORITY_LOW));\n}\n\nexports.$createCodeHighlightNode = $createCodeHighlightNode;\nexports.$createCodeNode = $createCodeNode;\nexports.$isCodeHighlightNode = $isCodeHighlightNode;\nexports.$isCodeNode = $isCodeNode;\nexports.CODE_LANGUAGE_FRIENDLY_NAME_MAP = CODE_LANGUAGE_FRIENDLY_NAME_MAP;\nexports.CODE_LANGUAGE_MAP = CODE_LANGUAGE_MAP;\nexports.CodeHighlightNode = CodeHighlightNode;\nexports.CodeNode = CodeNode;\nexports.DEFAULT_CODE_LANGUAGE = DEFAULT_CODE_LANGUAGE;\nexports.getCodeLanguages = getCodeLanguages;\nexports.getDefaultCodeLanguage = getDefaultCodeLanguage;\nexports.getEndOfCodeInLine = getEndOfCodeInLine;\nexports.getFirstCodeHighlightNodeOfLine = getFirstCodeHighlightNodeOfLine;\nexports.getLanguageFriendlyName = getLanguageFriendlyName;\nexports.getLastCodeHighlightNodeOfLine = getLastCodeHighlightNodeOfLine;\nexports.getStartOfCodeInLine = getStartOfCodeInLine;\nexports.normalizeCodeLang = normalizeCodeLang;\nexports.registerCodeHighlighting = registerCodeHighlighting;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}