{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister() {\n  for (var _len = arguments.length, func = new Array(_len), _key = 0; _key < _len; _key++) {\n    func[_key] = arguments[_key];\n  }\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = selection.createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(_ref => {\n    let {\n      editorState\n    } = _ref;\n    return compute(editorState);\n  }), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/** @module @lexical/utils */\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element) {\n  for (var _len2 = arguments.length, classNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    classNames[_key2 - 1] = arguments[_key2];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element) {\n  for (var _len3 = arguments.length, classNames = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    classNames[_key3 - 1] = arguments[_key3];\n  }\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n    if (lexical.$isTextNode(clone)) {\n      if (!lexical.$isTextNode(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection() || lexical.$getPreviousSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nexports.$splitNode = lexical.$splitNode;\nexports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;\nexports.isHTMLElement = lexical.isHTMLElement;\nexports.$dfs = $dfs;\nexports.$filter = $filter;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertFirst = $insertFirst;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isMimeType = isMimeType;\nexports.markSelection = markSelection;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.objectKlassEquals = objectKlassEquals;\nexports.positionNodeOnRange = positionNodeOnRange;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;","map":{"version":3,"names":["selection","require","lexical","mergeRegister","_len","arguments","length","func","Array","_key","forEach","f","px","value","mutationObserverConfig","attributes","characterData","childList","subtree","positionNodeOnRange","editor","range","onReposition","rootDOMNode","parentDOMNode","observer","lastNodes","wrapperNode","document","createElement","position","Error","left","rootLeft","top","rootTop","getBoundingClientRect","parentDOMNode_","rects","createRectsFromDOMRange","isConnected","append","hasRepositioned","i","rect","rectNode","rectNodeStyle","style","width","height","parentNode","pop","stop","disconnect","remove","node","restart","currentRootDOMNode","getRootElement","currentParentDOMNode","parentElement","HTMLElement","MutationObserver","mutations","nextRootDOMNode","nextParentDOMNode","mutation","contains","target","observe","removeRootListener","registerRootListener","markSelection","previousAnchorNode","previousAnchorOffset","previousFocusNode","previousFocusOffset","removeRangeListener","compute","editorState","read","$getSelection","$isRangeSelection","anchor","focus","currentAnchorNode","getNode","currentAnchorNodeKey","getKey","currentAnchorOffset","offset","currentFocusNode","currentFocusNodeKey","currentFocusOffset","currentAnchorNodeDOM","getElementByKey","currentFocusNodeDOM","differentAnchorDOM","TextNode","updateDOM","_config","differentFocusDOM","anchorHTMLElement","focusHTMLElement","tagName","createRange","firstHTMLElement","firstOffset","lastHTMLElement","lastOffset","isBefore","firstTextNode","firstChild","lastTextNode","setStart","setEnd","domNodes","domNode","domNodeStyle","background","color","zIndex","pointerEvents","marginTop","paddingTop","paddingBottom","undefined","getEditorState","registerUpdateListener","_ref","addClassNamesToElement","element","_len2","classNames","_key2","className","classesToAdd","split","filter","n","classList","add","removeClassNamesFromElement","_len3","_key3","isMimeType","file","acceptableMimeTypes","acceptableType","type","startsWith","mediaFileReader","files","filesIterator","Symbol","iterator","Promise","resolve","reject","processed","handleNextFile","done","next","fileReader","FileReader","addEventListener","result","push","readAsDataURL","$dfs","startingNode","endingNode","nodes","start","$getRoot","getLatest","end","$isElementNode","getLastDescendant","depth","$getDepth","is","getChildrenSize","getFirstChild","sibling","getNextSibling","getParent","innerNode","$getNearestNodeOfType","klass","parent","$getNearestBlockElementAncestorOrThrow","startNode","blockNode","$findMatchingParent","isInline","__key","findFn","curr","registerNestedElementResolver","targetNode","cloneNode","handleOverlap","$isTargetNode","$findMatch","children","getChildren","child","childNode","elementNodeTransform","match","nextSiblings","getNextSiblings","nextSiblingsLength","insertAfter","newParent","canBeEmpty","registerNodeTransform","$restoreEditorState","FULL_RECONCILE","nodeMap","Map","activeEditorState","_pendingEditorState","key","_nodeMap","clone","$cloneWithProperties","$isTextNode","__text","set","_dirtyType","selection$1","_selection","$setSelection","$insertNodeToNearestRoot","$getPreviousSelection","focusNode","focusOffset","$isRootOrShadowRoot","focusChild","getChildAtIndex","insertBefore","selectNext","splitNode","splitOffset","getParentOrThrow","getIndexWithinParent","splitText","rightTree","$splitNode","selectStart","getNodes","getTopLevelElementOrThrow","root","paragraphNode","$createParagraphNode","select","$wrapNodeInElement","createElementNode","elementNode","replace","objectKlassEquals","object","objectClass","Object","getPrototypeOf","constructor","name","$filter","filterFn","$insertFirst","exports","isHTMLAnchorElement","isHTMLElement"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/utils/LexicalUtils.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = selection.createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = lexical.$getSelection();\n      if (!lexical.$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof lexical.TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof lexical.TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/** @module @lexical/utils */\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n    if (lexical.$isTextNode(clone)) {\n      if (!lexical.$isTextNode(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection() || lexical.$getPreviousSelection();\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;\nexports.isHTMLElement = lexical.isHTMLElement;\nexports.$dfs = $dfs;\nexports.$filter = $filter;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertFirst = $insertFirst;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isMimeType = isMimeType;\nexports.markSelection = markSelection;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.objectKlassEquals = objectKlassEquals;\nexports.positionNodeOnRange = positionNodeOnRange;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}