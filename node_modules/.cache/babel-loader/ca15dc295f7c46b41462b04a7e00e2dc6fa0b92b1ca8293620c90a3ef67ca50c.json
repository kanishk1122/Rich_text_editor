{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n} // TODO: rewrite with $findMatchingParent or *nodeOfType\n\nfunction findNearestListItemNode(node) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isListItemNode(currentNode)) {\n      return currentNode;\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\nfunction getUniqueListItemNodes(nodeList) {\n  const keys = new Set();\n  for (let i = 0; i < nodeList.length; i++) {\n    const node = nodeList[i];\n    if ($isListItemNode(node)) {\n      keys.add(node);\n    }\n  }\n  return Array.from(keys);\n}\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n  const siblings = listItem.getPreviousSiblings();\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n  return value;\n}\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      } else {\n        const handled = new Set();\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n            while (parent != null) {\n              const parentKey = parent.getKey();\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n                break;\n              } else {\n                const nextParent = parent.getParent();\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\nfunction updateChildrenListItemValue(list, children) {\n  (children || list.getChildren()).forEach(child => {\n    const prevValue = child.getValue();\n    const nextValue = $getListItemValue(child);\n    if (prevValue !== nextValue) {\n      child.setValue(nextValue);\n    }\n  });\n}\nfunction $handleIndent(listItemNodes) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n      return;\n    }\n    const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n    const nextSibling = listItemNode.getNextSibling();\n    const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        const nextInnerList = nextSibling.getFirstChild();\n        if ($isListNode(nextInnerList)) {\n          const children = nextInnerList.getChildren();\n          append(innerList, children);\n          nextSibling.remove();\n          removed.add(nextSibling.getKey());\n        }\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(nextSibling)) {\n      // if the ListItemNode is next to a nested ListNode, merge them\n      const innerList = nextSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        const firstChild = innerList.getFirstChild();\n        if (firstChild !== null) {\n          firstChild.insertBefore(listItemNode);\n        }\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        updateChildrenListItemValue(innerList);\n      }\n    } else {\n      // otherwise, we need to create a new nested ListNode\n      if ($isListNode(parent)) {\n        const newListItem = $createListItemNode();\n        const newList = $createListNode(parent.getListType());\n        newListItem.append(newList);\n        newList.append(listItemNode);\n        if (previousSibling) {\n          previousSibling.insertAfter(newListItem);\n        } else if (nextSibling) {\n          nextSibling.insertBefore(newListItem);\n        } else {\n          parent.append(newListItem);\n        }\n      }\n    }\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n    }\n  });\n}\nfunction $handleOutdent(listItemNodes) {\n  // go through each node and decide where to move it.\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode)) {\n      return;\n    }\n    const parentList = listItemNode.getParent();\n    const grandparentListItem = parentList ? parentList.getParent() : undefined;\n    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n      // if it's the first child in it's parent list, insert it into the\n      // great grandparent list before the grandparent\n      const firstChild = parentList ? parentList.getFirstChild() : undefined;\n      const lastChild = parentList ? parentList.getLastChild() : undefined;\n      if (listItemNode.is(firstChild)) {\n        grandparentListItem.insertBefore(listItemNode);\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        } // if it's the last child in it's parent list, insert it into the\n        // great grandparent list after the grandparent.\n      } else if (listItemNode.is(lastChild)) {\n        grandparentListItem.insertAfter(listItemNode);\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        }\n      } else {\n        // otherwise, we need to split the siblings into two new nested lists\n        const listType = parentList.getListType();\n        const previousSiblingsListItem = $createListItemNode();\n        const previousSiblingsList = $createListNode(listType);\n        previousSiblingsListItem.append(previousSiblingsList);\n        listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n        const nextSiblingsListItem = $createListItemNode();\n        const nextSiblingsList = $createListNode(listType);\n        nextSiblingsListItem.append(nextSiblingsList);\n        append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n        grandparentListItem.insertBefore(previousSiblingsListItem);\n        grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n        grandparentListItem.replace(listItemNode);\n      }\n      updateChildrenListItemValue(parentList);\n      updateChildrenListItemValue(greatGrandparentList);\n    }\n  });\n}\nfunction maybeIndentOrOutdent(direction) {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n  const selectedNodes = selection.getNodes();\n  let listItemNodes = [];\n  if (selectedNodes.length === 0) {\n    selectedNodes.push(selection.anchor.getNode());\n  }\n  if (selectedNodes.length === 1) {\n    // Only 1 node selected. Selection may not contain the ListNodeItem so we traverse the tree to\n    // find whether this is part of a ListItemNode\n    const nearestListItemNode = findNearestListItemNode(selectedNodes[0]);\n    if (nearestListItemNode !== null) {\n      listItemNodes = [nearestListItemNode];\n    }\n  } else {\n    listItemNodes = getUniqueListItemNodes(selectedNodes);\n  }\n  if (listItemNodes.length > 0) {\n    if (direction === 'indent') {\n      $handleIndent(listItemNodes);\n    } else {\n      $handleOutdent(listItemNodes);\n    }\n  }\n}\nfunction indentList() {\n  maybeIndentOrOutdent('indent');\n}\nfunction outdentList() {\n  maybeIndentOrOutdent('outdent');\n}\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(element, this, null, parent);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(dom, this, prevNode, parent);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    const list = this.getParentOrThrow();\n    if ($isListNode(list)) {\n      const childrenKeys = list.__children;\n      const childrenLength = childrenKeys.length;\n      const index = childrenKeys.indexOf(this.__key);\n      if (index === 0) {\n        list.insertBefore(replaceWithNode);\n      } else if (index === childrenLength - 1) {\n        list.insertAfter(replaceWithNode);\n      } else {\n        // Split the list\n        const newList = $createListNode(list.getListType());\n        const children = list.getChildren();\n        for (let i = index + 1; i < childrenLength; i++) {\n          const child = children[i];\n          newList.append(child);\n        }\n        list.insertAfter(replaceWithNode);\n        replaceWithNode.insertAfter(newList);\n      }\n      this.remove();\n      if (childrenLength === 1) {\n        list.remove();\n      }\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    const siblings = this.getNextSiblings();\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node);\n      const afterListNode = node.getParentOrThrow();\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child);\n      }\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n    listNode.insertAfter(node);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (nextSibling !== null) {\n      const parent = nextSibling.getParent();\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n  insertNewAfter() {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.replace(paragraph); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent([this]);\n        currentIndent++;\n      } else {\n        $handleOutdent([this]);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n  canIndent() {\n    // Indent/outdent is handled specifically in the RichText logic.\n    return false;\n  }\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n    return super.insertBefore(nodeToInsert);\n  }\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  const isCheckList = listNode.getListType() === 'check';\n  if (isCheckList) {\n    // Only add attributes for leaf list items\n    if ($isListNode(listItemNode.getFirstChild())) {\n      dom.removeAttribute('role');\n      dom.removeAttribute('tabIndex');\n      dom.removeAttribute('aria-checked');\n    } else {\n      dom.setAttribute('role', 'checkbox');\n      dom.setAttribute('tabIndex', '-1');\n      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n        dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n      }\n    }\n  } else {\n    // Clean up checked state\n    if (listItemNode.getChecked() != null) {\n      listItemNode.setChecked(undefined);\n    }\n  }\n}\nfunction convertListItemElement(domNode) {\n  return {\n    node: $createListItemNode()\n  };\n}\nfunction $createListItemNode(checked) {\n  return new ListItemNode(undefined, checked);\n}\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  } // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const currentNode = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      node.getChildren().forEach(child => {\n        if ($isListNode(child)) {\n          normalizedListItems.push(wrapInListItem(child));\n        }\n      });\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    node = $createListNode('number');\n  } else if (nodeName === 'ul') {\n    node = $createListNode('bullet');\n  }\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\nfunction $createListNode(listType) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return new ListNode(listType, start);\n}\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand();\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand();\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand();\nconst REMOVE_LIST_COMMAND = lexical.createCommand();\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.indentList = indentList;\nexports.insertList = insertList;\nexports.outdentList = outdentList;\nexports.removeList = removeList;","map":{"version":3,"names":["lexical","require","utils","$getListDepth","listNode","depth","parent","getParent","$isListItemNode","parentList","$isListNode","Error","$getTopListNode","listItem","list","$getAllListItems","node","listItemNodes","listChildren","getChildren","filter","i","length","listItemNode","firstChild","getFirstChild","concat","push","isNestedListNode","findNearestListItemNode","currentNode","getUniqueListItemNodes","nodeList","keys","Set","add","Array","from","$removeHighestEmptyListParent","sublist","emptyListPtr","getNextSibling","getPreviousSibling","remove","wrapInListItem","listItemWrapper","$createListItemNode","append","$isSelectingEmptyListItem","anchorNode","nodes","is","getChildrenSize","$getListItemValue","value","getStart","siblings","getPreviousSiblings","sibling","insertList","editor","listType","update","selection","$getSelection","$isRangeSelection","getNodes","anchor","getNode","anchorNodeParent","$createListNode","$isRootOrShadowRoot","replace","$isElementNode","setFormat","getFormatType","setIndent","getIndent","getParentOrThrow","handled","isEmpty","has","getKey","createListOrMerge","$isLeafNode","parentKey","newListNode","updateChildrenListItemValue","nextParent","nodesToAppend","splice","previousSibling","nextSibling","getListType","getFirstChildOrThrow","insertBefore","removeList","listNodes","$getNearestNodeOfType","ListItemNode","insertionPoint","listItems","paragraph","$createParagraphNode","insertAfter","__key","key","set","focus","children","forEach","child","prevValue","getValue","nextValue","setValue","$handleIndent","removed","innerList","nextInnerList","newListItem","newList","$handleOutdent","grandparentListItem","undefined","greatGrandparentList","lastChild","getLastChild","previousSiblingsListItem","previousSiblingsList","nextSiblingsListItem","nextSiblingsList","getNextSiblings","maybeIndentOrOutdent","direction","selectedNodes","nearestListItemNode","indentList","outdentList","$handleListInsertParagraph","isCollapsed","getTextContent","topListNode","grandparent","replacementNode","select","nextSiblings","$isParagraphNode","ElementNode","getType","clone","__value","__checked","constructor","checked","createDOM","config","element","document","createElement","updateListItemChecked","$setListItemThemeClassNames","theme","updateDOM","prevNode","dom","importDOM","li","conversion","convertListItemElement","priority","importJSON","serializedNode","format","indent","setDirection","exportJSON","getChecked","type","version","arguments","canMergeWith","replaceWithNode","childrenKeys","__children","childrenLength","index","indexOf","after","afterListNode","preserveEmptyParent","insertNewAfter","newElement","collapseAtStart","listNodeParent","isIndented","offset","self","getLatest","getWritable","setChecked","toggleChecked","__indent","indentLevel","currentIndent","canIndent","nodeToInsert","canInsertAfter","canReplaceWith","replacement","extractWithChild","focusNode","isParentOf","editorThemeClasses","classesToAdd","classesToRemove","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","listItemClasses","split","parentNode","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","some","removeClassNamesFromElement","addClassNamesToElement","prevListItemNode","removeAttribute","setAttribute","domNode","ListNode","__listType","TAG_TO_LIST_TYPE","__tag","__start","start","_listType","getTag","_editor","tag","String","__lexicalListType","setListThemeClassNames","ol","convertListNode","ul","canBeEmpty","textNode","$createTextNode","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","normalizeChildren","normalizedListItems","nodeName","toLowerCase","INSERT_UNORDERED_LIST_COMMAND","createCommand","INSERT_ORDERED_LIST_COMMAND","INSERT_CHECK_LIST_COMMAND","REMOVE_LIST_COMMAND","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/list/LexicalList.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n\n  let parent = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n} // TODO: rewrite with $findMatchingParent or *nodeOfType\n\nfunction findNearestListItemNode(node) {\n  let currentNode = node;\n\n  while (currentNode !== null) {\n    if ($isListItemNode(currentNode)) {\n      return currentNode;\n    }\n\n    currentNode = currentNode.getParent();\n  }\n\n  return null;\n}\nfunction getUniqueListItemNodes(nodeList) {\n  const keys = new Set();\n\n  for (let i = 0; i < nodeList.length; i++) {\n    const node = nodeList[i];\n\n    if ($isListItemNode(node)) {\n      keys.add(node);\n    }\n  }\n\n  return Array.from(keys);\n}\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n\n  const siblings = listItem.getPreviousSiblings();\n\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n\n  return value;\n}\n\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n\n        return;\n      } else {\n        const handled = new Set();\n\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n\n            while (parent != null) {\n              const parentKey = parent.getKey();\n\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n\n                break;\n              } else {\n                const nextParent = parent.getParent();\n\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\n\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n\n          listItemNode.remove();\n        }\n\n        listNode.remove();\n      }\n    }\n  });\n}\nfunction updateChildrenListItemValue(list, children) {\n  (children || list.getChildren()).forEach(child => {\n    const prevValue = child.getValue();\n    const nextValue = $getListItemValue(child);\n\n    if (prevValue !== nextValue) {\n      child.setValue(nextValue);\n    }\n  });\n}\nfunction $handleIndent(listItemNodes) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n      return;\n    }\n\n    const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n    const nextSibling = listItemNode.getNextSibling();\n    const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n    if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        const nextInnerList = nextSibling.getFirstChild();\n\n        if ($isListNode(nextInnerList)) {\n          const children = nextInnerList.getChildren();\n          append(innerList, children);\n          nextSibling.remove();\n          removed.add(nextSibling.getKey());\n        }\n\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(nextSibling)) {\n      // if the ListItemNode is next to a nested ListNode, merge them\n      const innerList = nextSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        const firstChild = innerList.getFirstChild();\n\n        if (firstChild !== null) {\n          firstChild.insertBefore(listItemNode);\n        }\n\n        updateChildrenListItemValue(innerList);\n      }\n    } else if (isNestedListNode(previousSibling)) {\n      const innerList = previousSibling.getFirstChild();\n\n      if ($isListNode(innerList)) {\n        innerList.append(listItemNode);\n        updateChildrenListItemValue(innerList);\n      }\n    } else {\n      // otherwise, we need to create a new nested ListNode\n      if ($isListNode(parent)) {\n        const newListItem = $createListItemNode();\n        const newList = $createListNode(parent.getListType());\n        newListItem.append(newList);\n        newList.append(listItemNode);\n\n        if (previousSibling) {\n          previousSibling.insertAfter(newListItem);\n        } else if (nextSibling) {\n          nextSibling.insertBefore(newListItem);\n        } else {\n          parent.append(newListItem);\n        }\n      }\n    }\n\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n    }\n  });\n}\nfunction $handleOutdent(listItemNodes) {\n  // go through each node and decide where to move it.\n  listItemNodes.forEach(listItemNode => {\n    if (isNestedListNode(listItemNode)) {\n      return;\n    }\n\n    const parentList = listItemNode.getParent();\n    const grandparentListItem = parentList ? parentList.getParent() : undefined;\n    const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n    if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n      // if it's the first child in it's parent list, insert it into the\n      // great grandparent list before the grandparent\n      const firstChild = parentList ? parentList.getFirstChild() : undefined;\n      const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n      if (listItemNode.is(firstChild)) {\n        grandparentListItem.insertBefore(listItemNode);\n\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        } // if it's the last child in it's parent list, insert it into the\n        // great grandparent list after the grandparent.\n\n      } else if (listItemNode.is(lastChild)) {\n        grandparentListItem.insertAfter(listItemNode);\n\n        if (parentList.isEmpty()) {\n          grandparentListItem.remove();\n        }\n      } else {\n        // otherwise, we need to split the siblings into two new nested lists\n        const listType = parentList.getListType();\n        const previousSiblingsListItem = $createListItemNode();\n        const previousSiblingsList = $createListNode(listType);\n        previousSiblingsListItem.append(previousSiblingsList);\n        listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n        const nextSiblingsListItem = $createListItemNode();\n        const nextSiblingsList = $createListNode(listType);\n        nextSiblingsListItem.append(nextSiblingsList);\n        append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n        grandparentListItem.insertBefore(previousSiblingsListItem);\n        grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n        grandparentListItem.replace(listItemNode);\n      }\n\n      updateChildrenListItemValue(parentList);\n      updateChildrenListItemValue(greatGrandparentList);\n    }\n  });\n}\n\nfunction maybeIndentOrOutdent(direction) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return;\n  }\n\n  const selectedNodes = selection.getNodes();\n  let listItemNodes = [];\n\n  if (selectedNodes.length === 0) {\n    selectedNodes.push(selection.anchor.getNode());\n  }\n\n  if (selectedNodes.length === 1) {\n    // Only 1 node selected. Selection may not contain the ListNodeItem so we traverse the tree to\n    // find whether this is part of a ListItemNode\n    const nearestListItemNode = findNearestListItemNode(selectedNodes[0]);\n\n    if (nearestListItemNode !== null) {\n      listItemNodes = [nearestListItemNode];\n    }\n  } else {\n    listItemNodes = getUniqueListItemNodes(selectedNodes);\n  }\n\n  if (listItemNodes.length > 0) {\n    if (direction === 'indent') {\n      $handleIndent(listItemNodes);\n    } else {\n      $handleOutdent(listItemNodes);\n    }\n  }\n}\n\nfunction indentList() {\n  maybeIndentOrOutdent('indent');\n}\nfunction outdentList() {\n  maybeIndentOrOutdent('outdent');\n}\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getTextContent() !== '') {\n    return false;\n  }\n\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n\n  const grandparent = parent.getParent();\n  let replacementNode;\n\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(element, this, null, parent);\n    }\n\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n\n    if ($isListNode(parent)) {\n      updateChildrenListItemValue(parent);\n      updateListItemChecked(dom, this, prevNode, parent);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = new ListItemNode(serializedNode.value, serializedNode.checked);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace(replaceWithNode) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n\n    const list = this.getParentOrThrow();\n\n    if ($isListNode(list)) {\n      const childrenKeys = list.__children;\n      const childrenLength = childrenKeys.length;\n      const index = childrenKeys.indexOf(this.__key);\n\n      if (index === 0) {\n        list.insertBefore(replaceWithNode);\n      } else if (index === childrenLength - 1) {\n        list.insertAfter(replaceWithNode);\n      } else {\n        // Split the list\n        const newList = $createListNode(list.getListType());\n        const children = list.getChildren();\n\n        for (let i = index + 1; i < childrenLength; i++) {\n          const child = children[i];\n          newList.append(child);\n        }\n\n        list.insertAfter(replaceWithNode);\n        replaceWithNode.insertAfter(newList);\n      }\n\n      this.remove();\n\n      if (childrenLength === 1) {\n        list.remove();\n      }\n    }\n\n    return replaceWithNode;\n  }\n\n  insertAfter(node) {\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node);\n      const afterListNode = node.getParentOrThrow();\n\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n\n    if ($isListNode(node) && node.getListType() === listNode.getListType()) {\n      let child = node;\n      const children = node.getChildren();\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child);\n      }\n\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n\n    listNode.insertAfter(node);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode);\n    }\n\n    return node;\n  }\n\n  remove(preserveEmptyParent) {\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n\n    if (nextSibling !== null) {\n      const parent = nextSibling.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n\n  insertNewAfter() {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement);\n    return newElement;\n  }\n\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.replace(paragraph); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent) {\n    let currentIndent = this.getIndent();\n\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent([this]);\n        currentIndent++;\n      } else {\n        $handleOutdent([this]);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  canIndent() {\n    // Indent/outdent is handled specifically in the RichText logic.\n    return false;\n  }\n\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n\n    return super.insertBefore(nodeToInsert);\n  }\n\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n\n}\n\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  const isCheckList = listNode.getListType() === 'check';\n\n  if (isCheckList) {\n    // Only add attributes for leaf list items\n    if ($isListNode(listItemNode.getFirstChild())) {\n      dom.removeAttribute('role');\n      dom.removeAttribute('tabIndex');\n      dom.removeAttribute('aria-checked');\n    } else {\n      dom.setAttribute('role', 'checkbox');\n      dom.setAttribute('tabIndex', '-1');\n\n      if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n        dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n      }\n    }\n  } else {\n    // Clean up checked state\n    if (listItemNode.getChecked() != null) {\n      listItemNode.setChecked(undefined);\n    }\n  }\n}\n\nfunction convertListItemElement(domNode) {\n  return {\n    node: $createListItemNode()\n  };\n}\n\nfunction $createListItemNode(checked) {\n  return new ListItemNode(undefined, checked);\n}\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n\n  constructor(listType, start, key) {\n    super(key);\n\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n\n  getTag() {\n    return this.__tag;\n  }\n\n  getListType() {\n    return this.__listType;\n  }\n\n  getStart() {\n    return this.__start;\n  } // View\n\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        }\n\n        super.append(listItemNode);\n      }\n    }\n\n    return this;\n  }\n\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n\n}\n\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      node.getChildren().forEach(child => {\n        if ($isListNode(child)) {\n          normalizedListItems.push(wrapInListItem(child));\n        }\n      });\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n\n  return normalizedListItems;\n}\n\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'ol') {\n    node = $createListNode('number');\n  } else if (nodeName === 'ul') {\n    node = $createListNode('bullet');\n  }\n\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\n\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\nfunction $createListNode(listType, start = 1) {\n  return new ListNode(listType, start);\n}\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand();\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand();\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand();\nconst REMOVE_LIST_COMMAND = lexical.createCommand();\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.indentList = indentList;\nexports.insertList = insertList;\nexports.outdentList = outdentList;\nexports.removeList = removeList;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}