{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    utils.addClassNamesToElement(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      utils.addClassNamesToElement(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          utils.addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        utils.removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    const ids = this.getIDs();\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n  addID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) return;\n      }\n      ids.push(id);\n    }\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n  insertNewAfter(selection) {\n    const element = this.getParentOrThrow().insertNewAfter(selection);\n    if (lexical.$isElementNode(element)) {\n      const markNode = $createMarkNode(this.__ids);\n      element.append(markNode);\n      return markNode;\n    }\n    return null;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids) {\n  return new MarkNode(ids);\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/** @module @lexical/mark */\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode; // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (lexical.$isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n    if (lexical.$isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (lexical.$isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        lastCreatedMarkNode = $createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      } // Add the target node to be wrapped in the latest created mark node\n\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if (lexical.$isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\nexports.$createMarkNode = $createMarkNode;\nexports.$getMarkIDs = $getMarkIDs;\nexports.$isMarkNode = $isMarkNode;\nexports.$unwrapMarkNode = $unwrapMarkNode;\nexports.$wrapSelectionInMarkNode = $wrapSelectionInMarkNode;\nexports.MarkNode = MarkNode;","map":{"version":3,"names":["lexical","require","utils","MarkNode","ElementNode","getType","clone","node","Array","from","__ids","__key","importDOM","importJSON","serializedNode","$createMarkNode","ids","setFormat","format","setIndent","indent","setDirection","direction","exportJSON","getIDs","type","version","constructor","key","createDOM","config","element","document","createElement","addClassNamesToElement","theme","mark","length","markOverlap","updateDOM","prevNode","prevIDs","nextIDs","prevIDsCount","nextIDsCount","overlapTheme","removeClassNamesFromElement","hasID","id","i","self","getLatest","$isMarkNode","addID","getWritable","push","deleteID","splice","insertNewAfter","selection","getParentOrThrow","$isElementNode","markNode","append","canInsertTextBefore","canInsertTextAfter","canBeEmpty","isInline","extractWithChild","child","destination","$isRangeSelection","anchor","focus","anchorNode","getNode","focusNode","isBackward","selectionLength","offset","isParentOf","getTextContent","excludeFromCopy","$unwrapMarkNode","children","getChildren","target","insertBefore","insertAfter","remove","$wrapSelectionInMarkNode","nodes","getNodes","anchorOffset","focusOffset","nodesLength","startOffset","endOffset","currentNodeParent","lastCreatedMarkNode","isFirstNode","isLastNode","targetNode","$isTextNode","textContentSize","getTextContentSize","startTextOffset","endTextOffset","splitNodes","splitText","is","parentNode","getParent","undefined","$getMarkIDs","currentNode","nextSibling","getNextSibling","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/react/node_modules/@lexical/mark/LexicalMark.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass MarkNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'mark';\n  }\n\n  static clone(node) {\n    return new MarkNode(Array.from(node.__ids), node.__key);\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createMarkNode(serializedNode.ids);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      ids: this.getIDs(),\n      type: 'mark',\n      version: 1\n    };\n  }\n\n  constructor(ids, key) {\n    super(key);\n    this.__ids = ids || [];\n  }\n\n  createDOM(config) {\n    const element = document.createElement('mark');\n    utils.addClassNamesToElement(element, config.theme.mark);\n\n    if (this.__ids.length > 1) {\n      utils.addClassNamesToElement(element, config.theme.markOverlap);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          utils.addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        utils.removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n\n    return false;\n  }\n\n  hasID(id) {\n    const ids = this.getIDs();\n\n    for (let i = 0; i < ids.length; i++) {\n      if (id === ids[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  getIDs() {\n    const self = this.getLatest();\n    return $isMarkNode(self) ? self.__ids : [];\n  }\n\n  addID(id) {\n    const self = this.getWritable();\n\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n\n      for (let i = 0; i < ids.length; i++) {\n        // If we already have it, don't add again\n        if (id === ids[i]) return;\n      }\n\n      ids.push(id);\n    }\n  }\n\n  deleteID(id) {\n    const self = this.getWritable();\n\n    if ($isMarkNode(self)) {\n      const ids = self.__ids;\n      self.__ids = ids;\n\n      for (let i = 0; i < ids.length; i++) {\n        if (id === ids[i]) {\n          ids.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }\n\n  insertNewAfter(selection) {\n    const element = this.getParentOrThrow().insertNewAfter(selection);\n\n    if (lexical.$isElementNode(element)) {\n      const markNode = $createMarkNode(this.__ids);\n      element.append(markNode);\n      return markNode;\n    }\n\n    return null;\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  extractWithChild(child, selection, destination) {\n    if (!lexical.$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n\n}\nfunction $createMarkNode(ids) {\n  return new MarkNode(ids);\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/** @module @lexical/mark */\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n\n    target = child;\n  }\n\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode; // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n\n    if (lexical.$isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (lexical.$isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n\n      const parentNode = targetNode.getParent();\n\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n\n      currentNodeParent = parentNode;\n\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        lastCreatedMarkNode = $createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      } // Add the target node to be wrapped in the latest created mark node\n\n\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if (lexical.$isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n\n    currentNode = currentNode.getParent();\n  }\n\n  return null;\n}\n\nexports.$createMarkNode = $createMarkNode;\nexports.$getMarkIDs = $getMarkIDs;\nexports.$isMarkNode = $isMarkNode;\nexports.$unwrapMarkNode = $unwrapMarkNode;\nexports.$wrapSelectionInMarkNode = $wrapSelectionInMarkNode;\nexports.MarkNode = MarkNode;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAChC,IAAIC,KAAK,GAAGD,OAAO,CAAC,gBAAgB,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAME,QAAQ,SAASH,OAAO,CAACI,WAAW,CAAC;EACzC;EACA,OAAOC,OAAOA,CAAA,EAAG;IACf,OAAO,MAAM;EACf;EAEA,OAAOC,KAAKA,CAACC,IAAI,EAAE;IACjB,OAAO,IAAIJ,QAAQ,CAACK,KAAK,CAACC,IAAI,CAACF,IAAI,CAACG,KAAK,CAAC,EAAEH,IAAI,CAACI,KAAK,CAAC;EACzD;EAEA,OAAOC,SAASA,CAAA,EAAG;IACjB,OAAO,IAAI;EACb;EAEA,OAAOC,UAAUA,CAACC,cAAc,EAAE;IAChC,MAAMP,IAAI,GAAGQ,eAAe,CAACD,cAAc,CAACE,GAAG,CAAC;IAChDT,IAAI,CAACU,SAAS,CAACH,cAAc,CAACI,MAAM,CAAC;IACrCX,IAAI,CAACY,SAAS,CAACL,cAAc,CAACM,MAAM,CAAC;IACrCb,IAAI,CAACc,YAAY,CAACP,cAAc,CAACQ,SAAS,CAAC;IAC3C,OAAOf,IAAI;EACb;EAEAgB,UAAUA,CAAA,EAAG;IACX,OAAO;MAAE,GAAG,KAAK,CAACA,UAAU,CAAC,CAAC;MAC5BP,GAAG,EAAE,IAAI,CAACQ,MAAM,CAAC,CAAC;MAClBC,IAAI,EAAE,MAAM;MACZC,OAAO,EAAE;IACX,CAAC;EACH;EAEAC,WAAWA,CAACX,GAAG,EAAEY,GAAG,EAAE;IACpB,KAAK,CAACA,GAAG,CAAC;IACV,IAAI,CAAClB,KAAK,GAAGM,GAAG,IAAI,EAAE;EACxB;EAEAa,SAASA,CAACC,MAAM,EAAE;IAChB,MAAMC,OAAO,GAAGC,QAAQ,CAACC,aAAa,CAAC,MAAM,CAAC;IAC9C/B,KAAK,CAACgC,sBAAsB,CAACH,OAAO,EAAED,MAAM,CAACK,KAAK,CAACC,IAAI,CAAC;IAExD,IAAI,IAAI,CAAC1B,KAAK,CAAC2B,MAAM,GAAG,CAAC,EAAE;MACzBnC,KAAK,CAACgC,sBAAsB,CAACH,OAAO,EAAED,MAAM,CAACK,KAAK,CAACG,WAAW,CAAC;IACjE;IAEA,OAAOP,OAAO;EAChB;EAEAQ,SAASA,CAACC,QAAQ,EAAET,OAAO,EAAED,MAAM,EAAE;IACnC,MAAMW,OAAO,GAAGD,QAAQ,CAAC9B,KAAK;IAC9B,MAAMgC,OAAO,GAAG,IAAI,CAAChC,KAAK;IAC1B,MAAMiC,YAAY,GAAGF,OAAO,CAACJ,MAAM;IACnC,MAAMO,YAAY,GAAGF,OAAO,CAACL,MAAM;IACnC,MAAMQ,YAAY,GAAGf,MAAM,CAACK,KAAK,CAACG,WAAW;IAE7C,IAAIK,YAAY,KAAKC,YAAY,EAAE;MACjC,IAAID,YAAY,KAAK,CAAC,EAAE;QACtB,IAAIC,YAAY,KAAK,CAAC,EAAE;UACtB1C,KAAK,CAACgC,sBAAsB,CAACH,OAAO,EAAEc,YAAY,CAAC;QACrD;MACF,CAAC,MAAM,IAAID,YAAY,KAAK,CAAC,EAAE;QAC7B1C,KAAK,CAAC4C,2BAA2B,CAACf,OAAO,EAAEc,YAAY,CAAC;MAC1D;IACF;IAEA,OAAO,KAAK;EACd;EAEAE,KAAKA,CAACC,EAAE,EAAE;IACR,MAAMhC,GAAG,GAAG,IAAI,CAACQ,MAAM,CAAC,CAAC;IAEzB,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjC,GAAG,CAACqB,MAAM,EAAEY,CAAC,EAAE,EAAE;MACnC,IAAID,EAAE,KAAKhC,GAAG,CAACiC,CAAC,CAAC,EAAE;QACjB,OAAO,IAAI;MACb;IACF;IAEA,OAAO,KAAK;EACd;EAEAzB,MAAMA,CAAA,EAAG;IACP,MAAM0B,IAAI,GAAG,IAAI,CAACC,SAAS,CAAC,CAAC;IAC7B,OAAOC,WAAW,CAACF,IAAI,CAAC,GAAGA,IAAI,CAACxC,KAAK,GAAG,EAAE;EAC5C;EAEA2C,KAAKA,CAACL,EAAE,EAAE;IACR,MAAME,IAAI,GAAG,IAAI,CAACI,WAAW,CAAC,CAAC;IAE/B,IAAIF,WAAW,CAACF,IAAI,CAAC,EAAE;MACrB,MAAMlC,GAAG,GAAGkC,IAAI,CAACxC,KAAK;MACtBwC,IAAI,CAACxC,KAAK,GAAGM,GAAG;MAEhB,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjC,GAAG,CAACqB,MAAM,EAAEY,CAAC,EAAE,EAAE;QACnC;QACA,IAAID,EAAE,KAAKhC,GAAG,CAACiC,CAAC,CAAC,EAAE;MACrB;MAEAjC,GAAG,CAACuC,IAAI,CAACP,EAAE,CAAC;IACd;EACF;EAEAQ,QAAQA,CAACR,EAAE,EAAE;IACX,MAAME,IAAI,GAAG,IAAI,CAACI,WAAW,CAAC,CAAC;IAE/B,IAAIF,WAAW,CAACF,IAAI,CAAC,EAAE;MACrB,MAAMlC,GAAG,GAAGkC,IAAI,CAACxC,KAAK;MACtBwC,IAAI,CAACxC,KAAK,GAAGM,GAAG;MAEhB,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjC,GAAG,CAACqB,MAAM,EAAEY,CAAC,EAAE,EAAE;QACnC,IAAID,EAAE,KAAKhC,GAAG,CAACiC,CAAC,CAAC,EAAE;UACjBjC,GAAG,CAACyC,MAAM,CAACR,CAAC,EAAE,CAAC,CAAC;UAChB;QACF;MACF;IACF;EACF;EAEAS,cAAcA,CAACC,SAAS,EAAE;IACxB,MAAM5B,OAAO,GAAG,IAAI,CAAC6B,gBAAgB,CAAC,CAAC,CAACF,cAAc,CAACC,SAAS,CAAC;IAEjE,IAAI3D,OAAO,CAAC6D,cAAc,CAAC9B,OAAO,CAAC,EAAE;MACnC,MAAM+B,QAAQ,GAAG/C,eAAe,CAAC,IAAI,CAACL,KAAK,CAAC;MAC5CqB,OAAO,CAACgC,MAAM,CAACD,QAAQ,CAAC;MACxB,OAAOA,QAAQ;IACjB;IAEA,OAAO,IAAI;EACb;EAEAE,mBAAmBA,CAAA,EAAG;IACpB,OAAO,KAAK;EACd;EAEAC,kBAAkBA,CAAA,EAAG;IACnB,OAAO,KAAK;EACd;EAEAC,UAAUA,CAAA,EAAG;IACX,OAAO,KAAK;EACd;EAEAC,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI;EACb;EAEAC,gBAAgBA,CAACC,KAAK,EAAEV,SAAS,EAAEW,WAAW,EAAE;IAC9C,IAAI,CAACtE,OAAO,CAACuE,iBAAiB,CAACZ,SAAS,CAAC,IAAIW,WAAW,KAAK,MAAM,EAAE;MACnE,OAAO,KAAK;IACd;IAEA,MAAME,MAAM,GAAGb,SAAS,CAACa,MAAM;IAC/B,MAAMC,KAAK,GAAGd,SAAS,CAACc,KAAK;IAC7B,MAAMC,UAAU,GAAGF,MAAM,CAACG,OAAO,CAAC,CAAC;IACnC,MAAMC,SAAS,GAAGH,KAAK,CAACE,OAAO,CAAC,CAAC;IACjC,MAAME,UAAU,GAAGlB,SAAS,CAACkB,UAAU,CAAC,CAAC;IACzC,MAAMC,eAAe,GAAGD,UAAU,GAAGL,MAAM,CAACO,MAAM,GAAGN,KAAK,CAACM,MAAM,GAAGN,KAAK,CAACM,MAAM,GAAGP,MAAM,CAACO,MAAM;IAChG,OAAO,IAAI,CAACC,UAAU,CAACN,UAAU,CAAC,IAAI,IAAI,CAACM,UAAU,CAACJ,SAAS,CAAC,IAAI,IAAI,CAACK,cAAc,CAAC,CAAC,CAAC5C,MAAM,KAAKyC,eAAe;EACtH;EAEAI,eAAeA,CAACZ,WAAW,EAAE;IAC3B,OAAOA,WAAW,KAAK,OAAO;EAChC;AAEF;AACA,SAASvD,eAAeA,CAACC,GAAG,EAAE;EAC5B,OAAO,IAAIb,QAAQ,CAACa,GAAG,CAAC;AAC1B;AACA,SAASoC,WAAWA,CAAC7C,IAAI,EAAE;EACzB,OAAOA,IAAI,YAAYJ,QAAQ;AACjC;;AAEA;AACA,SAASgF,eAAeA,CAAC5E,IAAI,EAAE;EAC7B,MAAM6E,QAAQ,GAAG7E,IAAI,CAAC8E,WAAW,CAAC,CAAC;EACnC,IAAIC,MAAM,GAAG,IAAI;EAEjB,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmC,QAAQ,CAAC/C,MAAM,EAAEY,CAAC,EAAE,EAAE;IACxC,MAAMoB,KAAK,GAAGe,QAAQ,CAACnC,CAAC,CAAC;IAEzB,IAAIqC,MAAM,KAAK,IAAI,EAAE;MACnB/E,IAAI,CAACgF,YAAY,CAAClB,KAAK,CAAC;IAC1B,CAAC,MAAM;MACLiB,MAAM,CAACE,WAAW,CAACnB,KAAK,CAAC;IAC3B;IAEAiB,MAAM,GAAGjB,KAAK;EAChB;EAEA9D,IAAI,CAACkF,MAAM,CAAC,CAAC;AACf;AACA,SAASC,wBAAwBA,CAAC/B,SAAS,EAAEkB,UAAU,EAAE7B,EAAE,EAAE;EAC3D,MAAM2C,KAAK,GAAGhC,SAAS,CAACiC,QAAQ,CAAC,CAAC;EAClC,MAAMC,YAAY,GAAGlC,SAAS,CAACa,MAAM,CAACO,MAAM;EAC5C,MAAMe,WAAW,GAAGnC,SAAS,CAACc,KAAK,CAACM,MAAM;EAC1C,MAAMgB,WAAW,GAAGJ,KAAK,CAACtD,MAAM;EAChC,MAAM2D,WAAW,GAAGnB,UAAU,GAAGiB,WAAW,GAAGD,YAAY;EAC3D,MAAMI,SAAS,GAAGpB,UAAU,GAAGgB,YAAY,GAAGC,WAAW;EACzD,IAAII,iBAAiB;EACrB,IAAIC,mBAAmB,CAAC,CAAC;EACzB;EACA;EACA;;EAEA,KAAK,IAAIlD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG8C,WAAW,EAAE9C,CAAC,EAAE,EAAE;IACpC,MAAM1C,IAAI,GAAGoF,KAAK,CAAC1C,CAAC,CAAC;IAErB,IAAIjD,OAAO,CAAC6D,cAAc,CAACsC,mBAAmB,CAAC,IAAIA,mBAAmB,CAACnB,UAAU,CAACzE,IAAI,CAAC,EAAE;MACvF;MACA;IACF;IAEA,MAAM6F,WAAW,GAAGnD,CAAC,KAAK,CAAC;IAC3B,MAAMoD,UAAU,GAAGpD,CAAC,KAAK8C,WAAW,GAAG,CAAC;IACxC,IAAIO,UAAU,GAAG,IAAI;IAErB,IAAItG,OAAO,CAACuG,WAAW,CAAChG,IAAI,CAAC,EAAE;MAC7B;MACA,MAAMiG,eAAe,GAAGjG,IAAI,CAACkG,kBAAkB,CAAC,CAAC;MACjD,MAAMC,eAAe,GAAGN,WAAW,GAAGJ,WAAW,GAAG,CAAC;MACrD,MAAMW,aAAa,GAAGN,UAAU,GAAGJ,SAAS,GAAGO,eAAe;MAE9D,IAAIE,eAAe,KAAK,CAAC,IAAIC,aAAa,KAAK,CAAC,EAAE;QAChD;MACF;MAEA,MAAMC,UAAU,GAAGrG,IAAI,CAACsG,SAAS,CAACH,eAAe,EAAEC,aAAa,CAAC;MACjEL,UAAU,GAAGM,UAAU,CAACvE,MAAM,GAAG,CAAC,KAAKuE,UAAU,CAACvE,MAAM,KAAK,CAAC,IAAI+D,WAAW,IAAI,CAACC,UAAU,IAAIM,aAAa,KAAKH,eAAe,CAAC,GAAGI,UAAU,CAAC,CAAC,CAAC,GAAGA,UAAU,CAAC,CAAC,CAAC;IACpK,CAAC,MAAM,IAAIxD,WAAW,CAAC7C,IAAI,CAAC,EAAE;MAC5B;MACA;MACA;MACA;MACA;MACA;IACF,CAAC,MAAM,IAAIP,OAAO,CAAC6D,cAAc,CAACtD,IAAI,CAAC,IAAIA,IAAI,CAAC4D,QAAQ,CAAC,CAAC,EAAE;MAC1D;MACA;MACAmC,UAAU,GAAG/F,IAAI;IACnB;IAEA,IAAI+F,UAAU,KAAK,IAAI,EAAE;MACvB;MACA;MACA,IAAIA,UAAU,IAAIA,UAAU,CAACQ,EAAE,CAACZ,iBAAiB,CAAC,EAAE;QAClD;QACA;QACA;MACF;MAEA,MAAMa,UAAU,GAAGT,UAAU,CAACU,SAAS,CAAC,CAAC;MAEzC,IAAID,UAAU,IAAI,IAAI,IAAI,CAACA,UAAU,CAACD,EAAE,CAACZ,iBAAiB,CAAC,EAAE;QAC3D;QACA;QACAC,mBAAmB,GAAGc,SAAS;MACjC;MAEAf,iBAAiB,GAAGa,UAAU;MAE9B,IAAIZ,mBAAmB,KAAKc,SAAS,EAAE;QACrC;QACAd,mBAAmB,GAAGpF,eAAe,CAAC,CAACiC,EAAE,CAAC,CAAC;QAC3CsD,UAAU,CAACf,YAAY,CAACY,mBAAmB,CAAC;MAC9C,CAAC,CAAC;;MAGFA,mBAAmB,CAACpC,MAAM,CAACuC,UAAU,CAAC;IACxC,CAAC,MAAM;MACL;MACA;MACAJ,iBAAiB,GAAGe,SAAS;MAC7Bd,mBAAmB,GAAGc,SAAS;IACjC;EACF;AACF;AACA,SAASC,WAAWA,CAAC3G,IAAI,EAAEwE,MAAM,EAAE;EACjC,IAAIoC,WAAW,GAAG5G,IAAI;EAEtB,OAAO4G,WAAW,KAAK,IAAI,EAAE;IAC3B,IAAI/D,WAAW,CAAC+D,WAAW,CAAC,EAAE;MAC5B,OAAOA,WAAW,CAAC3F,MAAM,CAAC,CAAC;IAC7B,CAAC,MAAM,IAAIxB,OAAO,CAACuG,WAAW,CAACY,WAAW,CAAC,IAAIpC,MAAM,KAAKoC,WAAW,CAACV,kBAAkB,CAAC,CAAC,EAAE;MAC1F,MAAMW,WAAW,GAAGD,WAAW,CAACE,cAAc,CAAC,CAAC;MAEhD,IAAIjE,WAAW,CAACgE,WAAW,CAAC,EAAE;QAC5B,OAAOA,WAAW,CAAC5F,MAAM,CAAC,CAAC;MAC7B;IACF;IAEA2F,WAAW,GAAGA,WAAW,CAACH,SAAS,CAAC,CAAC;EACvC;EAEA,OAAO,IAAI;AACb;AAEAM,OAAO,CAACvG,eAAe,GAAGA,eAAe;AACzCuG,OAAO,CAACJ,WAAW,GAAGA,WAAW;AACjCI,OAAO,CAAClE,WAAW,GAAGA,WAAW;AACjCkE,OAAO,CAACnC,eAAe,GAAGA,eAAe;AACzCmC,OAAO,CAAC5B,wBAAwB,GAAGA,wBAAwB;AAC3D4B,OAAO,CAACnH,QAAQ,GAAGA,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}