{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/selection */\nconst cssToStyles = new Map();\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    clone.__children = Array.from(latest.__children);\n    clone.__format = latest.__format;\n    clone.__indent = latest.__indent;\n    clone.__dir = latest.__dir;\n  } else if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    clone.__format = latest.__format;\n    clone.__style = latest.__style;\n    clone.__mode = latest.__mode;\n    clone.__detail = latest.__detail;\n  }\n  return clone;\n}\nfunction $getIndexFromPossibleClone(node, parent, nodeMap) {\n  const parentClone = nodeMap.get(parent.getKey());\n  if (lexical.$isElementNode(parentClone)) {\n    return parentClone.__children.indexOf(node.getKey());\n  }\n  return node.getIndexWithinParent();\n}\nfunction $getParentAvoidingExcludedElements(node) {\n  let parent = node.getParent();\n  while (parent !== null && parent.excludeFromCopy('clone')) {\n    parent = parent.getParent();\n  }\n  return parent;\n}\nfunction $copyLeafNodeBranchToRoot(leaf, startingOffset, endingOffset, isLeftSide, range, nodeMap) {\n  let node = leaf;\n  let offset = startingOffset;\n  while (node !== null) {\n    const parent = $getParentAvoidingExcludedElements(node);\n    if (parent === null) {\n      break;\n    }\n    if (!lexical.$isElementNode(node) || !node.excludeFromCopy('clone')) {\n      const key = node.getKey();\n      let clone = nodeMap.get(key);\n      const needsClone = clone === undefined;\n      if (needsClone) {\n        clone = $cloneWithProperties(node);\n        nodeMap.set(key, clone);\n      }\n      if (lexical.$isTextNode(clone) && !clone.isSegmented() && !clone.isToken()) {\n        clone.__text = clone.__text.slice(isLeftSide ? offset : 0, isLeftSide ? endingOffset : offset);\n      } else if (lexical.$isElementNode(clone)) {\n        clone.__children = clone.__children.slice(isLeftSide ? offset : 0, isLeftSide ? undefined : (offset || 0) + 1);\n      }\n      if (lexical.$isRootNode(parent)) {\n        if (needsClone) {\n          // We only want to collect a range of top level nodes.\n          // So if the parent is the root, we know this is a top level.\n          range.push(key);\n        }\n        break;\n      }\n    }\n    offset = $getIndexFromPossibleClone(node, parent, nodeMap);\n    node = parent;\n  }\n}\nfunction errGetLatestOnClone() {\n  {\n    throw Error(`getLatest() on clone node`);\n  }\n}\nfunction $cloneContents(selection) {\n  const clone = $cloneContentsImpl(selection);\n  {\n    const nodeMap = clone.nodeMap;\n    for (let i = 0; i < nodeMap.length; i++) {\n      const node = nodeMap[i][1];\n      if (node.getLatest === errGetLatestOnClone) {\n        continue;\n      }\n      Object.setPrototypeOf(node, Object.create(Object.getPrototypeOf(node), {\n        getLatest: {\n          configurable: true,\n          enumerable: true,\n          value: errGetLatestOnClone,\n          writable: true\n        }\n      }));\n    }\n  }\n  return clone;\n}\nfunction $cloneContentsImpl(selection) {\n  if (lexical.$isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return {\n        nodeMap: [],\n        range: []\n      };\n    } // Check if we can use the parent of the nodes, if the\n    // parent can't be empty, then it's important that we\n    // also copy that element node along with its children.\n\n    let nodesLength = nodes.length;\n    const firstNode = nodes[0];\n    const firstNodeParent = firstNode.getParent();\n    if (firstNodeParent !== null && (!firstNodeParent.canBeEmpty() || lexical.$isRootNode(firstNodeParent))) {\n      const parentChildren = firstNodeParent.__children;\n      const parentChildrenLength = parentChildren.length;\n      if (parentChildrenLength === nodesLength) {\n        let areTheSame = true;\n        for (let i = 0; i < parentChildren.length; i++) {\n          if (parentChildren[i] !== nodes[i].__key) {\n            areTheSame = false;\n            break;\n          }\n        }\n        if (areTheSame) {\n          nodesLength++;\n          nodes.push(firstNodeParent);\n        }\n      }\n    }\n    const lastNode = nodes[nodesLength - 1];\n    const isBefore = anchor.isBefore(focus);\n    const nodeMap = new Map();\n    const range = [];\n    const isOnlyText = lexical.$isTextNode(firstNode) && nodesLength === 1; // Do first node to root\n\n    $copyLeafNodeBranchToRoot(firstNode, isBefore ? anchorOffset : focusOffset, isOnlyText ? isBefore ? focusOffset : anchorOffset : undefined, true, range, nodeMap); // Copy all nodes between\n\n    for (let i = 0; i < nodesLength; i++) {\n      const node = nodes[i];\n      const key = node.getKey();\n      if (!nodeMap.has(key) && (!lexical.$isElementNode(node) || !node.excludeFromCopy('clone'))) {\n        const clone = $cloneWithProperties(node);\n        if (lexical.$isRootNode(node.getParent())) {\n          range.push(node.getKey());\n        }\n        if (key !== 'root') {\n          nodeMap.set(key, clone);\n        }\n      }\n    } // Do last node to root\n\n    $copyLeafNodeBranchToRoot(lastNode, isOnlyText ? undefined : isBefore ? focusOffset : anchorOffset, undefined, false, range, nodeMap);\n    return {\n      nodeMap: Array.from(nodeMap.entries()),\n      range\n    };\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const nodeMap = selection.getNodes().map(node => {\n      const nodeKey = node.getKey();\n      const clone = $cloneWithProperties(node);\n      return [nodeKey, clone];\n    });\n    return {\n      nodeMap,\n      range: [selection.gridKey]\n    };\n  }\n  {\n    throw Error(`TODO`);\n  }\n}\nfunction getStyleObjectFromCSS(css) {\n  let value = cssToStyles.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    cssToStyles.set(css, value);\n  }\n  return value;\n}\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n  return styleObject;\n}\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  cssToStyles.set(CSSText, styles);\n}\nfunction $patchNodeStyle(node, patch) {\n  const prevStyles = getStyleObjectFromCSS(node.getStyle());\n  const newStyles = prevStyles ? {\n    ...prevStyles,\n    ...patch\n  } : patch;\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  node.setStyle(newCSSText);\n  cssToStyles.set(newCSSText, newStyles);\n}\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed()) {\n    return;\n  }\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  let startOffset;\n  let endOffset;\n  const isBefore = anchor.isBefore(focus);\n  startOffset = isBefore ? anchorOffset : focusOffset;\n  endOffset = isBefore ? focusOffset : anchorOffset; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (startOffset === firstNode.getTextContentSize()) {\n    const nextSibling = firstNode.getNextSibling();\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n  if (firstNode.is(lastNode)) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchNodeStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchNodeStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if (lexical.$isTextNode(firstNode)) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n      $patchNodeStyle(firstNode, patch);\n    }\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // if the entire last node isn't selected, split it\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0) {\n        $patchNodeStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchNodeStyle(selectedNode, patch);\n      }\n    }\n  }\n}\nfunction $getSelectionStyleValueForProperty(selection, styleProperty) {\n  let defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same font size.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.__children.length === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n/**\n * Attempts to wrap all nodes in the Selection in ElementNodes returned from createElement.\n * If wrappingElement is provided, all of the wrapped leaves are appended to the wrappingElement.\n * It attempts to append the resulting sub-tree to the nearest safe insertion target.\n *\n * @param selection\n * @param createElement\n * @param wrappingElement\n * @returns\n */\n\nfunction $wrapNodes(selection, createElement) {\n  let wrappingElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement) {\n  let wrappingElement = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedLeafNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && lexical.$isLeafNode(node) && !movedLeafNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedLeafNodes.add(child.getKey());\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  } // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n      }\n    }\n  }\n  const prevSelection = lexical.$getPreviousSelection();\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else {\n    selection.dirty = true;\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  return point.offset === point.getNode().getChildrenSize();\n}\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getDecoratorNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated();\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude a rect that is the exact same as the last rect. getClientRects() can return\n    // the same rect twice for some elements. A more sophisticated thing to do here is to\n    // merge all the rects together into a set of rects that don't overlap, so we don't\n    // generate backgrounds that are too dark.\n\n    const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isDuplicateRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const textNodeSize = text.length;\n    const offset = textNodeSize - remaining;\n    const slicedText = text.slice(0, offset);\n    if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0) {\n        parent.remove();\n      }\n      remaining -= textNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaniing number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = textNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneContents = $cloneContents;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.$wrapNodesImpl = $wrapNodesImpl;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;","map":{"version":3,"names":["lexical","require","cssToStyles","Map","$cloneWithProperties","node","latest","getLatest","constructor","clone","__parent","$isElementNode","__children","Array","from","__format","__indent","__dir","$isTextNode","__style","__mode","__detail","$getIndexFromPossibleClone","parent","nodeMap","parentClone","get","getKey","indexOf","getIndexWithinParent","$getParentAvoidingExcludedElements","getParent","excludeFromCopy","$copyLeafNodeBranchToRoot","leaf","startingOffset","endingOffset","isLeftSide","range","offset","key","needsClone","undefined","set","isSegmented","isToken","__text","slice","$isRootNode","push","errGetLatestOnClone","Error","$cloneContents","selection","$cloneContentsImpl","i","length","Object","setPrototypeOf","create","getPrototypeOf","configurable","enumerable","value","writable","$isRangeSelection","anchor","focus","anchorOffset","focusOffset","getCharacterOffsets","nodes","getNodes","nodesLength","firstNode","firstNodeParent","canBeEmpty","parentChildren","parentChildrenLength","areTheSame","__key","lastNode","isBefore","isOnlyText","has","entries","DEPRECATED_$isGridSelection","map","nodeKey","gridKey","getStyleObjectFromCSS","css","getStyleObjectFromRawCSS","styleObject","styles","split","style","trim","getCSSFromStyleObject","$addNodeStyle","CSSText","getStyle","$patchNodeStyle","patch","prevStyles","newStyles","newCSSText","setStyle","$patchStyleText","selectedNodes","selectedNodesLength","lastIndex","isCollapsed","firstNodeText","getTextContent","firstNodeTextLength","startOffset","endOffset","getTextContentSize","nextSibling","getNextSibling","is","select","splitNodes","splitText","replacement","lastNodeText","lastNodeTextLength","selectedNode","selectedNodeKey","$getSelectionStyleValueForProperty","styleProperty","defaultValue","arguments","styleValue","isBackward","endNode","getNode","nodeStyleValue","$getNodeStyleValueForProperty","$moveCaretSelection","isHoldingShift","granularity","modify","$isParentElementRTL","anchorNode","getParentOrThrow","getDirection","$moveCharacter","isRTL","$selectAll","topParent","getTopLevelElementOrThrow","root","getFirstDescendant","getLastDescendant","firstType","lastType","lastOffset","$removeParentEmptyElements","startingNode","$isRootOrShadowRoot","parentNode","remove","$wrapNodes","createElement","wrappingElement","type","getChildrenSize","target","children","getChildren","element","setFormat","getFormatType","setIndent","getIndent","forEach","child","append","replace","topLevelNode","descendants","$wrapNodesImpl","$hasAncestor","elementMapping","elements","isInline","targetIsPrevSibling","prevSibling","getPreviousSibling","emptyElements","Set","add","movedLeafNodes","$isLeafNode","parentKey","targetElement","insertAfter","firstChild","getFirstChild","insertBefore","prevSelection","$getPreviousSelection","isPointAttached","$setSelection","dirty","point","isAttached","$isAtNodeEnd","$shouldOverrideDefaultCharacterSelection","possibleNode","$getDecoratorNode","$isDecoratorNode","isIsolated","getDOMTextNode","nodeType","Node","TEXT_NODE","getDOMIndexWithinParent","childNodes","createDOMRange","editor","_anchorOffset","focusNode","_focusOffset","anchorKey","focusKey","document","createRange","anchorDOM","getElementByKey","focusDOM","nodeName","setStart","setEnd","e","collapsed","createRectsFromDOMRange","rootElement","getRootElement","rootRect","getBoundingClientRect","computedStyle","getComputedStyle","rootPadding","parseFloat","paddingLeft","paddingRight","selectionRects","getClientRects","selectionRectsLength","prevRect","selectionRect","isDuplicateRect","top","left","width","height","selectionSpansElement","splice","trimTextContentFromAnchor","delCount","currentNode","remaining","descendantNode","getDescendantByIndex","nextNode","additionalElementWhitespace","parentSibling","text","textNodeSize","slicedText","prevTextContent","getEditorState","read","prevNode","$getNodeByKey","isSimpleText","textNode","$createTextNode","setTextContent","prevOffset","isSelected","splitStart","splitEnd","excessNode","$sliceSelectedTextNodeContent","isAnchor","isFocus","isSame","isFirst","isLast","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/html/node_modules/@lexical/selection/LexicalSelection.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/** @module @lexical/selection */\nconst cssToStyles = new Map();\nfunction $cloneWithProperties(node) {\n  const latest = node.getLatest();\n  const constructor = latest.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(latest);\n  clone.__parent = latest.__parent;\n\n  if (lexical.$isElementNode(latest) && lexical.$isElementNode(clone)) {\n    clone.__children = Array.from(latest.__children);\n    clone.__format = latest.__format;\n    clone.__indent = latest.__indent;\n    clone.__dir = latest.__dir;\n  } else if (lexical.$isTextNode(latest) && lexical.$isTextNode(clone)) {\n    clone.__format = latest.__format;\n    clone.__style = latest.__style;\n    clone.__mode = latest.__mode;\n    clone.__detail = latest.__detail;\n  }\n\n  return clone;\n}\n\nfunction $getIndexFromPossibleClone(node, parent, nodeMap) {\n  const parentClone = nodeMap.get(parent.getKey());\n\n  if (lexical.$isElementNode(parentClone)) {\n    return parentClone.__children.indexOf(node.getKey());\n  }\n\n  return node.getIndexWithinParent();\n}\n\nfunction $getParentAvoidingExcludedElements(node) {\n  let parent = node.getParent();\n\n  while (parent !== null && parent.excludeFromCopy('clone')) {\n    parent = parent.getParent();\n  }\n\n  return parent;\n}\n\nfunction $copyLeafNodeBranchToRoot(leaf, startingOffset, endingOffset, isLeftSide, range, nodeMap) {\n  let node = leaf;\n  let offset = startingOffset;\n\n  while (node !== null) {\n    const parent = $getParentAvoidingExcludedElements(node);\n\n    if (parent === null) {\n      break;\n    }\n\n    if (!lexical.$isElementNode(node) || !node.excludeFromCopy('clone')) {\n      const key = node.getKey();\n      let clone = nodeMap.get(key);\n      const needsClone = clone === undefined;\n\n      if (needsClone) {\n        clone = $cloneWithProperties(node);\n        nodeMap.set(key, clone);\n      }\n\n      if (lexical.$isTextNode(clone) && !clone.isSegmented() && !clone.isToken()) {\n        clone.__text = clone.__text.slice(isLeftSide ? offset : 0, isLeftSide ? endingOffset : offset);\n      } else if (lexical.$isElementNode(clone)) {\n        clone.__children = clone.__children.slice(isLeftSide ? offset : 0, isLeftSide ? undefined : (offset || 0) + 1);\n      }\n\n      if (lexical.$isRootNode(parent)) {\n        if (needsClone) {\n          // We only want to collect a range of top level nodes.\n          // So if the parent is the root, we know this is a top level.\n          range.push(key);\n        }\n\n        break;\n      }\n    }\n\n    offset = $getIndexFromPossibleClone(node, parent, nodeMap);\n    node = parent;\n  }\n}\n\nfunction errGetLatestOnClone() {\n  {\n    throw Error(`getLatest() on clone node`);\n  }\n}\n\nfunction $cloneContents(selection) {\n  const clone = $cloneContentsImpl(selection);\n\n  {\n    const nodeMap = clone.nodeMap;\n\n    for (let i = 0; i < nodeMap.length; i++) {\n      const node = nodeMap[i][1];\n\n      if (node.getLatest === errGetLatestOnClone) {\n        continue;\n      }\n\n      Object.setPrototypeOf(node, Object.create(Object.getPrototypeOf(node), {\n        getLatest: {\n          configurable: true,\n          enumerable: true,\n          value: errGetLatestOnClone,\n          writable: true\n        }\n      }));\n    }\n  }\n\n  return clone;\n}\n\nfunction $cloneContentsImpl(selection) {\n  if (lexical.$isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n    const nodes = selection.getNodes();\n\n    if (nodes.length === 0) {\n      return {\n        nodeMap: [],\n        range: []\n      };\n    } // Check if we can use the parent of the nodes, if the\n    // parent can't be empty, then it's important that we\n    // also copy that element node along with its children.\n\n\n    let nodesLength = nodes.length;\n    const firstNode = nodes[0];\n    const firstNodeParent = firstNode.getParent();\n\n    if (firstNodeParent !== null && (!firstNodeParent.canBeEmpty() || lexical.$isRootNode(firstNodeParent))) {\n      const parentChildren = firstNodeParent.__children;\n      const parentChildrenLength = parentChildren.length;\n\n      if (parentChildrenLength === nodesLength) {\n        let areTheSame = true;\n\n        for (let i = 0; i < parentChildren.length; i++) {\n          if (parentChildren[i] !== nodes[i].__key) {\n            areTheSame = false;\n            break;\n          }\n        }\n\n        if (areTheSame) {\n          nodesLength++;\n          nodes.push(firstNodeParent);\n        }\n      }\n    }\n\n    const lastNode = nodes[nodesLength - 1];\n    const isBefore = anchor.isBefore(focus);\n    const nodeMap = new Map();\n    const range = [];\n    const isOnlyText = lexical.$isTextNode(firstNode) && nodesLength === 1; // Do first node to root\n\n    $copyLeafNodeBranchToRoot(firstNode, isBefore ? anchorOffset : focusOffset, isOnlyText ? isBefore ? focusOffset : anchorOffset : undefined, true, range, nodeMap); // Copy all nodes between\n\n    for (let i = 0; i < nodesLength; i++) {\n      const node = nodes[i];\n      const key = node.getKey();\n\n      if (!nodeMap.has(key) && (!lexical.$isElementNode(node) || !node.excludeFromCopy('clone'))) {\n        const clone = $cloneWithProperties(node);\n\n        if (lexical.$isRootNode(node.getParent())) {\n          range.push(node.getKey());\n        }\n\n        if (key !== 'root') {\n          nodeMap.set(key, clone);\n        }\n      }\n    } // Do last node to root\n\n\n    $copyLeafNodeBranchToRoot(lastNode, isOnlyText ? undefined : isBefore ? focusOffset : anchorOffset, undefined, false, range, nodeMap);\n    return {\n      nodeMap: Array.from(nodeMap.entries()),\n      range\n    };\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const nodeMap = selection.getNodes().map(node => {\n      const nodeKey = node.getKey();\n      const clone = $cloneWithProperties(node);\n      return [nodeKey, clone];\n    });\n    return {\n      nodeMap,\n      range: [selection.gridKey]\n    };\n  }\n\n  {\n    throw Error(`TODO`);\n  }\n}\n\nfunction getStyleObjectFromCSS(css) {\n  let value = cssToStyles.get(css);\n\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    cssToStyles.set(css, value);\n  }\n\n  return value;\n}\n\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n\n  return styleObject;\n}\n\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  cssToStyles.set(CSSText, styles);\n}\n\nfunction $patchNodeStyle(node, patch) {\n  const prevStyles = getStyleObjectFromCSS(node.getStyle());\n  const newStyles = prevStyles ? { ...prevStyles,\n    ...patch\n  } : patch;\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  node.setStyle(newCSSText);\n  cssToStyles.set(newCSSText, newStyles);\n}\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  let startOffset;\n  let endOffset;\n  const isBefore = anchor.isBefore(focus);\n  startOffset = isBefore ? anchorOffset : focusOffset;\n  endOffset = isBefore ? focusOffset : anchorOffset; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (startOffset === firstNode.getTextContentSize()) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (firstNode.is(lastNode)) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchNodeStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchNodeStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode)) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n\n      $patchNodeStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // if the entire last node isn't selected, split it\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchNodeStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchNodeStyle(selectedNode, patch);\n      }\n    }\n  }\n}\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same font size.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.__children.length === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n/**\n * Attempts to wrap all nodes in the Selection in ElementNodes returned from createElement.\n * If wrappingElement is provided, all of the wrapped leaves are appended to the wrappingElement.\n * It attempts to append the resulting sub-tree to the nearest safe insertion target.\n *\n * @param selection\n * @param createElement\n * @param wrappingElement\n * @returns\n */\n\n\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  let topLevelNode = null;\n  let descendants = [];\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  let targetIsPrevSibling = false;\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedLeafNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedLeafNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedLeafNodes.add(child.getKey());\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  } // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else {\n    selection.dirty = true;\n  }\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getDecoratorNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated();\n}\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n\n  const firstChild = anchorDOM.firstChild;\n\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n\n  return range;\n}\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    return [];\n  }\n\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  let prevRect;\n\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude a rect that is the exact same as the last rect. getClientRects() can return\n    // the same rect twice for some elements. A more sophisticated thing to do here is to\n    // merge all the rects together into a set of rects that don't overlap, so we don't\n    // generate backgrounds that are too dark.\n\n    const isDuplicateRect = prevRect && prevRect.top === selectionRect.top && prevRect.left === selectionRect.left && prevRect.width === selectionRect.width && prevRect.height === selectionRect.height; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n\n    if (isDuplicateRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n\n    prevRect = selectionRect;\n  }\n\n  return selectionRects;\n}\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n\n      while (parentSibling === null) {\n        parent = parent.getParent();\n\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n\n        parentSibling = parent.getPreviousSibling();\n      }\n\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n\n    const textNodeSize = text.length;\n    const offset = textNodeSize - remaining;\n    const slicedText = text.slice(0, offset);\n\n    if (!lexical.$isTextNode(currentNode) || remaining >= textNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n\n      if (parent != null && parent.getChildrenSize() === 0) {\n        parent.remove();\n      }\n\n      remaining -= textNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n\n        return null;\n      });\n\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaniing number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = textNodeSize;\n        }\n\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n\n      remaining = 0;\n    }\n  }\n}\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n\n  return textNode;\n}\n\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneContents = $cloneContents;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.$wrapNodesImpl = $wrapNodesImpl;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}