{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar link = require('@lexical/link');\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n    if (match) {\n      return match;\n    }\n  }\n  return null;\n}\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n  if (lexical.$isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n  return previousNode === null || lexical.$isLineBreakNode(previousNode) || lexical.$isTextNode(previousNode) && previousNode.getTextContent().endsWith(' ');\n}\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n  if (lexical.$isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n  return nextNode === null || lexical.$isLineBreakNode(nextNode) || lexical.$isTextNode(nextNode) && nextNode.getTextContent().startsWith(' ');\n}\nfunction handleLinkCreation(node, matchers, onChange) {\n  const nodeText = node.getTextContent();\n  const nodeTextLength = nodeText.length;\n  let text = nodeText;\n  let textOffset = 0;\n  let lastNode = node;\n  let match;\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchOffset = match.index;\n    const offset = textOffset + matchOffset;\n    const matchLength = match.length; // Previous node is valid if any of:\n    // 1. Space before same node\n    // 2. Space in previous simple text node\n    // 3. Previous node is LineBreakNode\n\n    let contentBeforeMatchIsValid;\n    if (offset > 0) {\n      contentBeforeMatchIsValid = nodeText[offset - 1] === ' ';\n    } else {\n      contentBeforeMatchIsValid = isPreviousNodeValid(node);\n    } // Next node is valid if any of:\n    // 1. Space after same node\n    // 2. Space in next simple text node\n    // 3. Next node is LineBreakNode\n\n    let contentAfterMatchIsValid;\n    if (offset + matchLength < nodeTextLength) {\n      contentAfterMatchIsValid = nodeText[offset + matchLength] === ' ';\n    } else {\n      contentAfterMatchIsValid = isNextNodeValid(node);\n    }\n    if (contentBeforeMatchIsValid && contentAfterMatchIsValid) {\n      let middleNode;\n      if (matchOffset === 0) {\n        [middleNode, lastNode] = lastNode.splitText(matchLength);\n      } else {\n        [, middleNode, lastNode] = lastNode.splitText(matchOffset, matchOffset + matchLength);\n      }\n      const nodeFormat = node.__format;\n      const linkNode = link.$createAutoLinkNode(match.url);\n      linkNode.append(lexical.$createTextNode(match.text).setFormat(nodeFormat));\n      middleNode.replace(linkNode);\n      onChange(match.url, null);\n    }\n    const iterationOffset = matchOffset + matchLength;\n    text = text.substring(iterationOffset);\n    textOffset += iterationOffset;\n  }\n}\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n    if (!lexical.$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  } // Check text content fully matches\n\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  } // Check neighbors\n\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n  const url = linkNode.getURL();\n  if (match !== null && url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n} // Bad neighbours are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\n\nfunction handleBadNeighbors(textNode, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n  if (link.$isAutoLinkNode(previousSibling) && !text.startsWith(' ')) {\n    replaceWithChildren(previousSibling);\n    onChange(null, previousSibling.getURL());\n  }\n  if (link.$isAutoLinkNode(nextSibling) && !text.endsWith(' ')) {\n    replaceWithChildren(nextSibling);\n    onChange(null, nextSibling.getURL());\n  }\n}\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n  node.remove();\n  return children.map(child => child.getLatest());\n}\nfunction useAutoLink(editor, matchers, onChange) {\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.AutoLinkNode])) {\n      {\n        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n    return utils.mergeRegister(editor.registerNodeTransform(lexical.TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n      if (link.$isAutoLinkNode(parent)) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!link.$isLinkNode(parent)) {\n        if (textNode.isSimpleText()) {\n          handleLinkCreation(textNode, matchers, onChangeWrapped);\n        }\n        handleBadNeighbors(textNode, onChangeWrapped);\n      }\n    }), editor.registerNodeTransform(link.AutoLinkNode, linkNode => {\n      handleLinkEdit(linkNode, matchers, onChangeWrapped);\n    }));\n  }, [editor, matchers, onChange]);\n}\nfunction AutoLinkPlugin(_ref) {\n  let {\n    matchers,\n    onChange\n  } = _ref;\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\nexports.AutoLinkPlugin = AutoLinkPlugin;","map":{"version":3,"names":["link","require","LexicalComposerContext","utils","lexical","react","findFirstMatch","text","matchers","i","length","match","isPreviousNodeValid","node","previousNode","getPreviousSibling","$isElementNode","getLastDescendant","$isLineBreakNode","$isTextNode","getTextContent","endsWith","isNextNodeValid","nextNode","getNextSibling","getFirstDescendant","startsWith","handleLinkCreation","onChange","nodeText","nodeTextLength","textOffset","lastNode","matchOffset","index","offset","matchLength","contentBeforeMatchIsValid","contentAfterMatchIsValid","middleNode","splitText","nodeFormat","__format","linkNode","$createAutoLinkNode","url","append","$createTextNode","setFormat","replace","iterationOffset","substring","handleLinkEdit","children","getChildren","childrenLength","child","isSimpleText","replaceWithChildren","getURL","setURL","handleBadNeighbors","textNode","previousSibling","nextSibling","$isAutoLinkNode","j","insertAfter","remove","map","getLatest","useAutoLink","editor","useEffect","hasNodes","AutoLinkNode","Error","onChangeWrapped","prevUrl","mergeRegister","registerNodeTransform","TextNode","parent","getParentOrThrow","$isLinkNode","AutoLinkPlugin","_ref","useLexicalComposerContext","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/react/LexicalAutoLinkPlugin.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar link = require('@lexical/link');\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n\n    if (match) {\n      return match;\n    }\n  }\n\n  return null;\n}\n\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n\n  if (lexical.$isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n\n  return previousNode === null || lexical.$isLineBreakNode(previousNode) || lexical.$isTextNode(previousNode) && previousNode.getTextContent().endsWith(' ');\n}\n\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n\n  if (lexical.$isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n\n  return nextNode === null || lexical.$isLineBreakNode(nextNode) || lexical.$isTextNode(nextNode) && nextNode.getTextContent().startsWith(' ');\n}\n\nfunction handleLinkCreation(node, matchers, onChange) {\n  const nodeText = node.getTextContent();\n  const nodeTextLength = nodeText.length;\n  let text = nodeText;\n  let textOffset = 0;\n  let lastNode = node;\n  let match;\n\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchOffset = match.index;\n    const offset = textOffset + matchOffset;\n    const matchLength = match.length; // Previous node is valid if any of:\n    // 1. Space before same node\n    // 2. Space in previous simple text node\n    // 3. Previous node is LineBreakNode\n\n    let contentBeforeMatchIsValid;\n\n    if (offset > 0) {\n      contentBeforeMatchIsValid = nodeText[offset - 1] === ' ';\n    } else {\n      contentBeforeMatchIsValid = isPreviousNodeValid(node);\n    } // Next node is valid if any of:\n    // 1. Space after same node\n    // 2. Space in next simple text node\n    // 3. Next node is LineBreakNode\n\n\n    let contentAfterMatchIsValid;\n\n    if (offset + matchLength < nodeTextLength) {\n      contentAfterMatchIsValid = nodeText[offset + matchLength] === ' ';\n    } else {\n      contentAfterMatchIsValid = isNextNodeValid(node);\n    }\n\n    if (contentBeforeMatchIsValid && contentAfterMatchIsValid) {\n      let middleNode;\n\n      if (matchOffset === 0) {\n        [middleNode, lastNode] = lastNode.splitText(matchLength);\n      } else {\n        [, middleNode, lastNode] = lastNode.splitText(matchOffset, matchOffset + matchLength);\n      }\n\n      const nodeFormat = node.__format;\n      const linkNode = link.$createAutoLinkNode(match.url);\n      linkNode.append(lexical.$createTextNode(match.text).setFormat(nodeFormat));\n      middleNode.replace(linkNode);\n      onChange(match.url, null);\n    }\n\n    const iterationOffset = matchOffset + matchLength;\n    text = text.substring(iterationOffset);\n    textOffset += iterationOffset;\n  }\n}\n\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n\n    if (!lexical.$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  } // Check text content fully matches\n\n\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  } // Check neighbors\n\n\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  const url = linkNode.getURL();\n\n  if (match !== null && url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n} // Bad neighbours are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\n\n\nfunction handleBadNeighbors(textNode, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n\n  if (link.$isAutoLinkNode(previousSibling) && !text.startsWith(' ')) {\n    replaceWithChildren(previousSibling);\n    onChange(null, previousSibling.getURL());\n  }\n\n  if (link.$isAutoLinkNode(nextSibling) && !text.endsWith(' ')) {\n    replaceWithChildren(nextSibling);\n    onChange(null, nextSibling.getURL());\n  }\n}\n\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n\n  node.remove();\n  return children.map(child => child.getLatest());\n}\n\nfunction useAutoLink(editor, matchers, onChange) {\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.AutoLinkNode])) {\n      {\n        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n\n    return utils.mergeRegister(editor.registerNodeTransform(lexical.TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n\n      if (link.$isAutoLinkNode(parent)) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!link.$isLinkNode(parent)) {\n        if (textNode.isSimpleText()) {\n          handleLinkCreation(textNode, matchers, onChangeWrapped);\n        }\n\n        handleBadNeighbors(textNode, onChangeWrapped);\n      }\n    }), editor.registerNodeTransform(link.AutoLinkNode, linkNode => {\n      handleLinkEdit(linkNode, matchers, onChangeWrapped);\n    }));\n  }, [editor, matchers, onChange]);\n}\n\nfunction AutoLinkPlugin({\n  matchers,\n  onChange\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\n\nexports.AutoLinkPlugin = AutoLinkPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}