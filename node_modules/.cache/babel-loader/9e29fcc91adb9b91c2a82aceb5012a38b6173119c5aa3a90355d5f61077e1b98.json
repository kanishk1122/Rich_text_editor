{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar useLexicalNodeSelection = require('@lexical/react/useLexicalNodeSelection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand();\nfunction HorizontalRuleComponent(_ref) {\n  let {\n    nodeKey\n  } = _ref;\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const hrRef = React.useRef(null);\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(payload => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      const event = payload;\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n      setSelected(false);\n    }\n    return false;\n  }, [isSelected, nodeKey, setSelected]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = hrRef.current;\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n        setSelected(!isSelected);\n        return true;\n      }\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, onDelete, setSelected]);\n  return /*#__PURE__*/React.createElement(\"hr\", {\n    ref: hrRef,\n    className: isSelected ? 'selected' : undefined\n  });\n}\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n  createDOM() {\n    const div = document.createElement('div');\n    div.style.display = 'contents';\n    return div;\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  isInline() {\n    return false;\n  }\n  updateDOM() {\n    return false;\n  }\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n}\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\nfunction $createHorizontalRuleNode() {\n  return new HorizontalRuleNode();\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;","map":{"version":3,"names":["LexicalComposerContext","require","useLexicalNodeSelection","utils","lexical","React","INSERT_HORIZONTAL_RULE_COMMAND","createCommand","HorizontalRuleComponent","_ref","nodeKey","editor","useLexicalComposerContext","hrRef","useRef","isSelected","setSelected","clearSelection","onDelete","useCallback","payload","$isNodeSelection","$getSelection","event","preventDefault","node","$getNodeByKey","$isHorizontalRuleNode","remove","useEffect","mergeRegister","registerCommand","CLICK_COMMAND","hrElem","current","target","shiftKey","COMMAND_PRIORITY_LOW","KEY_DELETE_COMMAND","KEY_BACKSPACE_COMMAND","createElement","ref","className","undefined","HorizontalRuleNode","DecoratorNode","getType","clone","__key","importJSON","serializedNode","$createHorizontalRuleNode","importDOM","hr","conversion","convertHorizontalRuleElement","priority","exportJSON","type","version","exportDOM","element","document","createDOM","div","style","display","getTextContent","isInline","updateDOM","decorate","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar useLexicalNodeSelection = require('@lexical/react/useLexicalNodeSelection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand();\n\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const hrRef = React.useRef(null);\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(payload => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      const event = payload;\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n\n      setSelected(false);\n    }\n\n    return false;\n  }, [isSelected, nodeKey, setSelected]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = hrRef.current;\n\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n\n        setSelected(!isSelected);\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, onDelete, setSelected]);\n  return /*#__PURE__*/React.createElement(\"hr\", {\n    ref: hrRef,\n    className: isSelected ? 'selected' : undefined\n  });\n}\n\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n\n  createDOM() {\n    const div = document.createElement('div');\n    div.style.display = 'contents';\n    return div;\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  isInline() {\n    return false;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n\n}\n\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\n\nfunction $createHorizontalRuleNode() {\n  return new HorizontalRuleNode();\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}