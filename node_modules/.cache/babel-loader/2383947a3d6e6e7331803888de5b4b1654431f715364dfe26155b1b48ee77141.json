{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $isElementNode, $isLeafNode, $createParagraphNode, $isParagraphNode, ElementNode, $applyNodeReplacement, $createTextNode, createCommand } from 'lexical';\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames() {\n  const rval = [];\n  for (var _len = arguments.length, classNames = new Array(_len), _key = 0; _key < _len; _key++) {\n    classNames[_key] = arguments[_key];\n  }\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const node = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      throw Error(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      throw Error(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append() {\n    for (let i = 0; i < arguments.length; i++) {\n      const currentNode = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          const textNode = $createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType) {\n  let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $isListItemNode, $isListNode, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, insertList, removeList };","map":{"version":3,"names":["$getSelection","$isRangeSelection","$isRootOrShadowRoot","$isElementNode","$isLeafNode","$createParagraphNode","$isParagraphNode","ElementNode","$applyNodeReplacement","$createTextNode","createCommand","$getNearestNodeOfType","removeClassNamesFromElement","addClassNamesToElement","isHTMLElement","$getListDepth","listNode","depth","parent","getParent","$isListItemNode","parentList","$isListNode","Error","$getTopListNode","listItem","list","$getAllListItems","node","listItemNodes","listChildren","getChildren","filter","i","length","listItemNode","firstChild","getFirstChild","concat","push","isNestedListNode","$removeHighestEmptyListParent","sublist","emptyListPtr","getNextSibling","getPreviousSibling","remove","$wrapInListItem","listItemWrapper","$createListItemNode","append","$isSelectingEmptyListItem","anchorNode","nodes","is","getChildrenSize","insertList","editor","listType","update","selection","getNodes","anchorAndFocus","getStartEndPoints","anchor","getNode","anchorNodeParent","$createListNode","replace","setFormat","getFormatType","setIndent","getIndent","getParentOrThrow","handled","Set","isEmpty","has","getKey","$createListOrMerge","parentKey","newListNode","add","nextParent","nodesToAppend","splice","previousSibling","nextSibling","getListType","getFirstChildOrThrow","insertBefore","mergeLists","list1","list2","listItem1","getLastChild","listItem2","toMerge","removeList","listNodes","ListItemNode","insertionPoint","listItems","paragraph","insertAfter","__key","key","set","focus","updateChildrenListItemValue","isNotChecklist","value","getStart","child","getValue","setValue","getLatest","__checked","setChecked","undefined","mergeNextSiblingListIfSameType","$handleIndent","removed","innerList","nextInnerList","children","newListItem","newList","$handleOutdent","grandparentListItem","greatGrandparentList","lastChild","previousSiblingsListItem","previousSiblingsList","getPreviousSiblings","forEach","sibling","nextSiblingsListItem","nextSiblingsList","getNextSiblings","$handleListInsertParagraph","isCollapsed","topListNode","grandparent","replacementNode","select","nextSiblings","normalizeClassNames","rval","_len","arguments","classNames","Array","_key","className","s","matchAll","getType","clone","__value","constructor","checked","createDOM","config","element","document","createElement","updateListItemChecked","$setListItemThemeClassNames","theme","updateDOM","prevNode","dom","transform","getChecked","importDOM","li","conversion","$convertListItemElement","priority","importJSON","serializedNode","format","setDirection","direction","exportDOM","_config","style","textAlign","exportJSON","type","version","canMergeWith","replaceWithNode","includeChildren","__first","__last","nodeToAppend","restoreSelection","siblings","preserveEmptyParent","prevSibling","insertNewAfter","_","newElement","collapseAtStart","listNodeParent","isIndented","offset","self","getWritable","Boolean","toggleChecked","__indent","indentLevel","indent","Math","floor","currentIndent","canInsertAfter","canReplaceWith","replacement","extractWithChild","focusNode","isParentOf","getTextContent","isParentRequired","createParentElementNode","canMergeWhenEmpty","editorThemeClasses","classesToAdd","classesToRemove","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","parentNode","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","some","prevListItemNode","removeAttribute","setAttribute","domNode","isGitHubCheckList","classList","contains","tagName","$convertCheckboxInput","ariaCheckedAttr","getAttribute","isCheckboxInput","hasAttribute","ListNode","__listType","TAG_TO_LIST_TYPE","__tag","__start","start","_listType","getTag","setListType","writable","_editor","tag","String","__lexicalListType","$setListThemeClassNames","ol","$convertListNode","ul","canBeEmpty","canIndent","currentNode","textNode","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","checklistClassName","checklist","$normalizeChildren","normalizedListItems","isDomChecklist","childNodes","nodeName","toLowerCase","after","INSERT_UNORDERED_LIST_COMMAND","INSERT_ORDERED_LIST_COMMAND","INSERT_CHECK_LIST_COMMAND","REMOVE_LIST_COMMAND"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/list/LexicalList.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $isElementNode, $isLeafNode, $createParagraphNode, $isParagraphNode, ElementNode, $applyNodeReplacement, $createTextNode, createCommand } from 'lexical';\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove();\n    // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    return list;\n  }\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      throw Error(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      throw Error(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isParagraphNode(node) || $isListItemNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType, start, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          const textNode = $createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType, start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $isListItemNode, $isListNode, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, insertList, removeList };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}