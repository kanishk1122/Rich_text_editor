{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes } from '@lexical/html';\nimport { $isLinkNode } from '@lexical/link';\nimport { $isMarkNode } from '@lexical/mark';\nimport { $isTableSelection } from '@lexical/table';\nimport { $getSelection, $getRoot, $isRangeSelection, $isNodeSelection, $isElementNode, $isTextNode, $isParagraphNode, COMMAND_PRIORITY_CRITICAL } from 'lexical';\nimport { forwardRef, useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { jsxs, jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '├',\n  isLastChild: '└',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst FORMAT_PREDICATES_PARAGRAPH = [node => node.hasTextFormat('bold') && 'Bold', node => node.hasTextFormat('code') && 'Code', node => node.hasTextFormat('italic') && 'Italic', node => node.hasTextFormat('strikethrough') && 'Strikethrough', node => node.hasTextFormat('subscript') && 'Subscript', node => node.hasTextFormat('superscript') && 'Superscript', node => node.hasTextFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\nfunction generateContent(editor, commandsLog, exportDOM, customPrintNode) {\n  let obfuscateText = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML($generateHtmlFromNodes(editor));\n    });\n    return htmlString;\n  }\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = $getSelection();\n    visitTree($getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${printNode(node, customPrintNode, obfuscateText)}\\n`;\n      res += $printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : $isRangeSelection(selection) ? printRangeSelection(selection) : $isTableSelection(selection) ? printTableSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n  if (commandsLog.length) {\n    for (const {\n      index,\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n  └ ${index}. { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n  └ None dispatched.';\n  }\n  const {\n    version\n  } = editor.constructor;\n  res += `\\n\\n editor${version ? ` (v${version})` : ''}:`;\n  res += `\\n  └ namespace ${editorConfig.namespace}`;\n  if (compositionKey !== null) {\n    res += `\\n  └ compositionKey ${compositionKey}`;\n  }\n  res += `\\n  └ editable ${String(editable)}`;\n  return res;\n}\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\nfunction printNodeSelection(selection) {\n  if (!$isNodeSelection(selection)) {\n    return '';\n  }\n  return `: node\\n  └ [${Array.from(selection._nodes).join(', ')}]`;\n}\nfunction printTableSelection(selection) {\n  return `: table\\n  └ { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\nfunction visitTree(currentNode, visitor) {\n  let indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n    if ($isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\nfunction normalize(text) {\n  let obfuscateText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, _ref) => {\n    let [key, value] = _ref;\n    return acc.replace(new RegExp(key, 'g'), String(value));\n  }, text);\n  if (obfuscateText) {\n    return textToPrint.replace(/[^\\s]/g, '*');\n  }\n  return textToPrint;\n}\nfunction printNode(node, customPrintNode) {\n  let obfuscateText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : undefined;\n  if (customPrint !== undefined && customPrint.length > 0) {\n    return customPrint;\n  }\n  if ($isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text, obfuscateText)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ($isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link, obfuscateText)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ($isMarkNode(node)) {\n    return `ids: [ ${node.getIDs().join(', ')} ]`;\n  } else if ($isParagraphNode(node)) {\n    const formatText = printTextFormatProperties(node);\n    let paragraphData = formatText !== '' ? `{ ${formatText} }` : '';\n    paragraphData += node.__style ? `(${node.__style})` : '';\n    return paragraphData;\n  } else {\n    return '';\n  }\n}\nfunction printTextFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES_PARAGRAPH.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(', ');\n}\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n  return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n  return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printTargetProperties(node) {\n  let str = node.getTarget();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n  return str;\n}\nfunction printRelProperties(node) {\n  let str = node.getRel();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n  return str;\n}\nfunction printTitleProperties(node) {\n  let str = node.getTitle();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n  return str;\n}\nfunction $printSelectedCharsLine(_ref2) {\n  let {\n    indent,\n    isSelected,\n    node,\n    nodeKeyDisplay,\n    selection,\n    typeDisplay\n  } = _ref2;\n  // No selection or node is not selected.\n  if (!$isTextNode(node) || !$isRangeSelection(selection) || !isSelected || $isElementNode(node)) {\n    return '';\n  }\n\n  // No selected characters.\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n  const [start, end] = $getSelectionStartEnd(node, selection);\n  if (start === end) {\n    return '';\n  }\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 2; // 1 for the space after + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n  return node;\n}\nfunction $getSelectionStartEnd(node, selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if ($isNodeSelection(selection) || anchorAndFocus === null) {\n    return [-1, -1];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1;\n\n  // Only one node is being selected.\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  }\n\n  // Account for non-single width characters.\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LARGE_EDITOR_STATE_SIZE = 1000;\nconst TreeView = /*#__PURE__*/forwardRef(function TreeViewWrapped(_ref3, ref) {\n  let {\n    treeTypeButtonClassName,\n    timeTravelButtonClassName,\n    timeTravelPanelSliderClassName,\n    timeTravelPanelButtonClassName,\n    viewClassName,\n    timeTravelPanelClassName,\n    editorState,\n    setEditorState,\n    setEditorReadOnly,\n    generateContent\n  } = _ref3;\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = useState([]);\n  const [content, setContent] = useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = useState(false);\n  const [showExportDOM, setShowExportDOM] = useState(false);\n  const playingIndexRef = useRef(0);\n  const inputRef = useRef(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isLimited, setIsLimited] = useState(false);\n  const [showLimited, setShowLimited] = useState(false);\n  const lastEditorStateRef = useRef();\n  const lastGenerationID = useRef(0);\n  const generateTree = useCallback(exportDOM => {\n    const myID = ++lastGenerationID.current;\n    generateContent(exportDOM).then(treeText => {\n      if (myID === lastGenerationID.current) {\n        setContent(treeText);\n      }\n    }).catch(err => {\n      if (myID === lastGenerationID.current) {\n        setContent(`Error rendering tree: ${err.message}\\n\\nStack:\\n${err.stack}`);\n      }\n    });\n  }, [generateContent]);\n  useEffect(() => {\n    if (!showLimited && editorState._nodeMap.size > LARGE_EDITOR_STATE_SIZE) {\n      setIsLimited(true);\n      if (!showLimited) {\n        return;\n      }\n    }\n\n    // Prevent re-rendering if the editor state hasn't changed\n    if (lastEditorStateRef.current !== editorState) {\n      lastEditorStateRef.current = editorState;\n      generateTree(showExportDOM);\n      if (!timeTravelEnabled) {\n        setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n      }\n    }\n  }, [editorState, generateTree, showExportDOM, showLimited, timeTravelEnabled]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, totalEditorStates, setEditorState]);\n  const handleExportModeToggleClick = () => {\n    generateTree(!showExportDOM);\n    setShowExportDOM(!showExportDOM);\n  };\n  return /*#__PURE__*/jsxs(\"div\", {\n    className: viewClassName,\n    children: [!showLimited && isLimited ? /*#__PURE__*/jsxs(\"div\", {\n      style: {\n        padding: 20\n      },\n      children: [/*#__PURE__*/jsx(\"span\", {\n        style: {\n          marginRight: 20\n        },\n        children: \"Detected large EditorState, this can impact debugging performance.\"\n      }), /*#__PURE__*/jsx(\"button\", {\n        onClick: () => {\n          setShowLimited(true);\n        },\n        style: {\n          background: 'transparent',\n          border: '1px solid white',\n          color: 'white',\n          cursor: 'pointer',\n          padding: 5\n        },\n        children: \"Show full tree\"\n      })]\n    }) : null, !showLimited ? /*#__PURE__*/jsx(\"button\", {\n      onClick: () => handleExportModeToggleClick(),\n      className: treeTypeButtonClassName,\n      type: \"button\",\n      children: showExportDOM ? 'Tree' : 'Export DOM'\n    }) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/jsx(\"button\", {\n      onClick: () => {\n        setEditorReadOnly(true);\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      },\n      className: timeTravelButtonClassName,\n      type: \"button\",\n      children: \"Time Travel\"\n    }), (showLimited || !isLimited) && /*#__PURE__*/jsx(\"pre\", {\n      ref: ref,\n      children: content\n    }), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/jsxs(\"div\", {\n      className: timeTravelPanelClassName,\n      children: [/*#__PURE__*/jsx(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          if (playingIndexRef.current === totalEditorStates - 1) {\n            playingIndexRef.current = 1;\n          }\n          setIsPlaying(!isPlaying);\n        },\n        type: \"button\",\n        children: isPlaying ? 'Pause' : 'Play'\n      }), /*#__PURE__*/jsx(\"input\", {\n        className: timeTravelPanelSliderClassName,\n        ref: inputRef,\n        onChange: event => {\n          const editorStateIndex = Number(event.target.value);\n          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n          if (timeStampedEditorState) {\n            playingIndexRef.current = editorStateIndex;\n            setEditorState(timeStampedEditorState[1]);\n          }\n        },\n        type: \"range\",\n        min: \"1\",\n        max: totalEditorStates - 1\n      }), /*#__PURE__*/jsx(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          setEditorReadOnly(false);\n          const index = timeStampedEditorStates.length - 1;\n          const timeStampedEditorState = timeStampedEditorStates[index];\n          setEditorState(timeStampedEditorState[1]);\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setTimeTravelEnabled(false);\n          setIsPlaying(false);\n        },\n        type: \"button\",\n        children: \"Exit\"\n      })]\n    })]\n  });\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerLexicalCommandLogger(editor, setLoggedCommands) {\n  const unregisterCommandListeners = new Set();\n  let i = 0;\n  for (const [command] of editor._commands) {\n    unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n      setLoggedCommands(state => {\n        i += 1;\n        const newState = [...state];\n        newState.push({\n          index: i,\n          payload,\n          type: command.type ? command.type : 'UNKNOWN'\n        });\n        if (newState.length > 10) {\n          newState.shift();\n        }\n        return newState;\n      });\n      return false;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  return () => unregisterCommandListeners.forEach(unregister => unregister());\n}\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = useState([]);\n  useEffect(() => {\n    return registerLexicalCommandLogger(editor, setLoggedCommands);\n  }, [editor]);\n  return useMemo(() => loggedCommands, [loggedCommands]);\n}\nexport { TreeView, generateContent, registerLexicalCommandLogger, useLexicalCommandsLog };","map":{"version":3,"names":["$generateHtmlFromNodes","$isLinkNode","$isMarkNode","$isTableSelection","$getSelection","$getRoot","$isRangeSelection","$isNodeSelection","$isElementNode","$isTextNode","$isParagraphNode","COMMAND_PRIORITY_CRITICAL","forwardRef","useState","useRef","useCallback","useEffect","useMemo","jsxs","jsx","NON_SINGLE_WIDTH_CHARS_REPLACEMENT","Object","freeze","NON_SINGLE_WIDTH_CHARS_REGEX","RegExp","keys","join","SYMBOLS","ancestorHasNextSibling","ancestorIsLastChild","hasNextSibling","isLastChild","selectedChar","selectedLine","FORMAT_PREDICATES","node","hasFormat","FORMAT_PREDICATES_PARAGRAPH","hasTextFormat","DETAIL_PREDICATES","isDirectionless","isUnmergeable","MODE_PREDICATES","isToken","isSegmented","generateContent","editor","commandsLog","exportDOM","customPrintNode","obfuscateText","arguments","length","undefined","editorState","getEditorState","editorConfig","_config","compositionKey","_compositionKey","editable","_editable","htmlString","read","printPrettyHTML","res","selectionString","selection","visitTree","indent","nodeKey","getKey","nodeKeyDisplay","typeDisplay","getType","isSelected","printNode","$printSelectedCharsLine","printRangeSelection","printTableSelection","printNodeSelection","index","type","payload","Event","constructor","name","version","namespace","String","formatText","printFormatProperties","style","anchor","focus","anchorOffset","offset","focusOffset","key","Array","from","_nodes","tableKey","currentNode","visitor","childNodes","getChildren","childNodesLength","forEach","childNode","i","concat","normalize","text","textToPrint","entries","reduce","acc","_ref","value","replace","customPrint","getTextContent","title","properties","printAllTextNodeProperties","filter","Boolean","trim","link","getURL","printAllLinkNodeProperties","getIDs","printTextFormatProperties","paragraphData","__style","nodeOrSelection","str","map","predicate","toLocaleLowerCase","printDetailProperties","printModeProperties","printTargetProperties","printRelProperties","printTitleProperties","getTarget","getRel","getTitle","_ref2","getNode","start","end","$getSelectionStartEnd","selectionLastIndent","indentionChars","slice","unselectedChars","fill","selectedChars","paddingLength","nodePrintSpaces","div","document","createElement","innerHTML","prettifyHTML","level","indentBefore","indentAfter","textNode","children","createTextNode","insertBefore","lastElementChild","appendChild","anchorAndFocus","getStartEndPoints","textContent","textLength","anchorNode","focusNode","isBefore","numNonSingleWidthCharBeforeSelection","match","numNonSingleWidthCharInSelection","LARGE_EDITOR_STATE_SIZE","TreeView","TreeViewWrapped","_ref3","ref","treeTypeButtonClassName","timeTravelButtonClassName","timeTravelPanelSliderClassName","timeTravelPanelButtonClassName","viewClassName","timeTravelPanelClassName","setEditorState","setEditorReadOnly","timeStampedEditorStates","setTimeStampedEditorStates","content","setContent","timeTravelEnabled","setTimeTravelEnabled","showExportDOM","setShowExportDOM","playingIndexRef","inputRef","isPlaying","setIsPlaying","isLimited","setIsLimited","showLimited","setShowLimited","lastEditorStateRef","lastGenerationID","generateTree","myID","current","then","treeText","catch","err","message","stack","_nodeMap","size","currentEditorStates","Date","now","totalEditorStates","timeoutId","play","currentIndex","currentTime","nextTime","timeDiff","setTimeout","input","clearTimeout","handleExportModeToggleClick","className","padding","marginRight","onClick","background","border","color","cursor","onChange","event","editorStateIndex","Number","target","timeStampedEditorState","min","max","registerLexicalCommandLogger","setLoggedCommands","unregisterCommandListeners","Set","command","_commands","add","registerCommand","state","newState","push","shift","unregister","useLexicalCommandsLog","loggedCommands"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes } from '@lexical/html';\nimport { $isLinkNode } from '@lexical/link';\nimport { $isMarkNode } from '@lexical/mark';\nimport { $isTableSelection } from '@lexical/table';\nimport { $getSelection, $getRoot, $isRangeSelection, $isNodeSelection, $isElementNode, $isTextNode, $isParagraphNode, COMMAND_PRIORITY_CRITICAL } from 'lexical';\nimport { forwardRef, useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { jsxs, jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '├',\n  isLastChild: '└',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst FORMAT_PREDICATES_PARAGRAPH = [node => node.hasTextFormat('bold') && 'Bold', node => node.hasTextFormat('code') && 'Code', node => node.hasTextFormat('italic') && 'Italic', node => node.hasTextFormat('strikethrough') && 'Strikethrough', node => node.hasTextFormat('subscript') && 'Subscript', node => node.hasTextFormat('superscript') && 'Superscript', node => node.hasTextFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\nfunction generateContent(editor, commandsLog, exportDOM, customPrintNode, obfuscateText = false) {\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML($generateHtmlFromNodes(editor));\n    });\n    return htmlString;\n  }\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = $getSelection();\n    visitTree($getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${printNode(node, customPrintNode, obfuscateText)}\\n`;\n      res += $printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : $isRangeSelection(selection) ? printRangeSelection(selection) : $isTableSelection(selection) ? printTableSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n  if (commandsLog.length) {\n    for (const {\n      index,\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n  └ ${index}. { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n  └ None dispatched.';\n  }\n  const {\n    version\n  } = editor.constructor;\n  res += `\\n\\n editor${version ? ` (v${version})` : ''}:`;\n  res += `\\n  └ namespace ${editorConfig.namespace}`;\n  if (compositionKey !== null) {\n    res += `\\n  └ compositionKey ${compositionKey}`;\n  }\n  res += `\\n  └ editable ${String(editable)}`;\n  return res;\n}\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\nfunction printNodeSelection(selection) {\n  if (!$isNodeSelection(selection)) {\n    return '';\n  }\n  return `: node\\n  └ [${Array.from(selection._nodes).join(', ')}]`;\n}\nfunction printTableSelection(selection) {\n  return `: table\\n  └ { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n    if ($isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\nfunction normalize(text, obfuscateText = false) {\n  const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n  if (obfuscateText) {\n    return textToPrint.replace(/[^\\s]/g, '*');\n  }\n  return textToPrint;\n}\nfunction printNode(node, customPrintNode, obfuscateText = false) {\n  const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : undefined;\n  if (customPrint !== undefined && customPrint.length > 0) {\n    return customPrint;\n  }\n  if ($isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text, obfuscateText)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ($isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link, obfuscateText)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ($isMarkNode(node)) {\n    return `ids: [ ${node.getIDs().join(', ')} ]`;\n  } else if ($isParagraphNode(node)) {\n    const formatText = printTextFormatProperties(node);\n    let paragraphData = formatText !== '' ? `{ ${formatText} }` : '';\n    paragraphData += node.__style ? `(${node.__style})` : '';\n    return paragraphData;\n  } else {\n    return '';\n  }\n}\nfunction printTextFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES_PARAGRAPH.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(', ');\n}\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n  return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n  return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printTargetProperties(node) {\n  let str = node.getTarget();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n  return str;\n}\nfunction printRelProperties(node) {\n  let str = node.getRel();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n  return str;\n}\nfunction printTitleProperties(node) {\n  let str = node.getTitle();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n  return str;\n}\nfunction $printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!$isTextNode(node) || !$isRangeSelection(selection) || !isSelected || $isElementNode(node)) {\n    return '';\n  }\n\n  // No selected characters.\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n  const [start, end] = $getSelectionStartEnd(node, selection);\n  if (start === end) {\n    return '';\n  }\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 2; // 1 for the space after + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n  return node;\n}\nfunction $getSelectionStartEnd(node, selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if ($isNodeSelection(selection) || anchorAndFocus === null) {\n    return [-1, -1];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1;\n\n  // Only one node is being selected.\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  }\n\n  // Account for non-single width characters.\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LARGE_EDITOR_STATE_SIZE = 1000;\nconst TreeView = /*#__PURE__*/forwardRef(function TreeViewWrapped({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editorState,\n  setEditorState,\n  setEditorReadOnly,\n  generateContent\n}, ref) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = useState([]);\n  const [content, setContent] = useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = useState(false);\n  const [showExportDOM, setShowExportDOM] = useState(false);\n  const playingIndexRef = useRef(0);\n  const inputRef = useRef(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isLimited, setIsLimited] = useState(false);\n  const [showLimited, setShowLimited] = useState(false);\n  const lastEditorStateRef = useRef();\n  const lastGenerationID = useRef(0);\n  const generateTree = useCallback(exportDOM => {\n    const myID = ++lastGenerationID.current;\n    generateContent(exportDOM).then(treeText => {\n      if (myID === lastGenerationID.current) {\n        setContent(treeText);\n      }\n    }).catch(err => {\n      if (myID === lastGenerationID.current) {\n        setContent(`Error rendering tree: ${err.message}\\n\\nStack:\\n${err.stack}`);\n      }\n    });\n  }, [generateContent]);\n  useEffect(() => {\n    if (!showLimited && editorState._nodeMap.size > LARGE_EDITOR_STATE_SIZE) {\n      setIsLimited(true);\n      if (!showLimited) {\n        return;\n      }\n    }\n\n    // Prevent re-rendering if the editor state hasn't changed\n    if (lastEditorStateRef.current !== editorState) {\n      lastEditorStateRef.current = editorState;\n      generateTree(showExportDOM);\n      if (!timeTravelEnabled) {\n        setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n      }\n    }\n  }, [editorState, generateTree, showExportDOM, showLimited, timeTravelEnabled]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, totalEditorStates, setEditorState]);\n  const handleExportModeToggleClick = () => {\n    generateTree(!showExportDOM);\n    setShowExportDOM(!showExportDOM);\n  };\n  return /*#__PURE__*/jsxs(\"div\", {\n    className: viewClassName,\n    children: [!showLimited && isLimited ? /*#__PURE__*/jsxs(\"div\", {\n      style: {\n        padding: 20\n      },\n      children: [/*#__PURE__*/jsx(\"span\", {\n        style: {\n          marginRight: 20\n        },\n        children: \"Detected large EditorState, this can impact debugging performance.\"\n      }), /*#__PURE__*/jsx(\"button\", {\n        onClick: () => {\n          setShowLimited(true);\n        },\n        style: {\n          background: 'transparent',\n          border: '1px solid white',\n          color: 'white',\n          cursor: 'pointer',\n          padding: 5\n        },\n        children: \"Show full tree\"\n      })]\n    }) : null, !showLimited ? /*#__PURE__*/jsx(\"button\", {\n      onClick: () => handleExportModeToggleClick(),\n      className: treeTypeButtonClassName,\n      type: \"button\",\n      children: showExportDOM ? 'Tree' : 'Export DOM'\n    }) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/jsx(\"button\", {\n      onClick: () => {\n        setEditorReadOnly(true);\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      },\n      className: timeTravelButtonClassName,\n      type: \"button\",\n      children: \"Time Travel\"\n    }), (showLimited || !isLimited) && /*#__PURE__*/jsx(\"pre\", {\n      ref: ref,\n      children: content\n    }), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/jsxs(\"div\", {\n      className: timeTravelPanelClassName,\n      children: [/*#__PURE__*/jsx(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          if (playingIndexRef.current === totalEditorStates - 1) {\n            playingIndexRef.current = 1;\n          }\n          setIsPlaying(!isPlaying);\n        },\n        type: \"button\",\n        children: isPlaying ? 'Pause' : 'Play'\n      }), /*#__PURE__*/jsx(\"input\", {\n        className: timeTravelPanelSliderClassName,\n        ref: inputRef,\n        onChange: event => {\n          const editorStateIndex = Number(event.target.value);\n          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n          if (timeStampedEditorState) {\n            playingIndexRef.current = editorStateIndex;\n            setEditorState(timeStampedEditorState[1]);\n          }\n        },\n        type: \"range\",\n        min: \"1\",\n        max: totalEditorStates - 1\n      }), /*#__PURE__*/jsx(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          setEditorReadOnly(false);\n          const index = timeStampedEditorStates.length - 1;\n          const timeStampedEditorState = timeStampedEditorStates[index];\n          setEditorState(timeStampedEditorState[1]);\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setTimeTravelEnabled(false);\n          setIsPlaying(false);\n        },\n        type: \"button\",\n        children: \"Exit\"\n      })]\n    })]\n  });\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerLexicalCommandLogger(editor, setLoggedCommands) {\n  const unregisterCommandListeners = new Set();\n  let i = 0;\n  for (const [command] of editor._commands) {\n    unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n      setLoggedCommands(state => {\n        i += 1;\n        const newState = [...state];\n        newState.push({\n          index: i,\n          payload,\n          type: command.type ? command.type : 'UNKNOWN'\n        });\n        if (newState.length > 10) {\n          newState.shift();\n        }\n        return newState;\n      });\n      return false;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  return () => unregisterCommandListeners.forEach(unregister => unregister());\n}\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = useState([]);\n  useEffect(() => {\n    return registerLexicalCommandLogger(editor, setLoggedCommands);\n  }, [editor]);\n  return useMemo(() => loggedCommands, [loggedCommands]);\n}\n\nexport { TreeView, generateContent, registerLexicalCommandLogger, useLexicalCommandsLog };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}