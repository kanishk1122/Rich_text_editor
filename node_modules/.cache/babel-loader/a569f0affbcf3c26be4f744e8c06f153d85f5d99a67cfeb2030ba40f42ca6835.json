{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? Array.from(dom.body.childNodes) : [];\n  const elementsLength = elements.length;\n  for (let i = 0; i < elementsLength; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (document == null || window == null) {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement) {\n  let selection$1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n  if (!element) {\n    return false;\n  }\n  const fragment = new DocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE']);\nfunction $createNodesFromDOM(node, editor) {\n  let forChildMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  let parentLexicalNode = arguments.length > 3 ? arguments[3] : undefined;\n  let preformatted = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;","map":{"version":3,"names":["selection","require","lexical","$generateNodesFromDOM","editor","dom","lexicalNodes","elements","body","Array","from","childNodes","elementsLength","length","i","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","$generateHtmlFromNodes","document","window","Error","container","createElement","root","$getRoot","topLevelChildren","getChildren","topLevelNode","$appendNodesToHTML","innerHTML","currentNode","parentElement","selection$1","arguments","undefined","shouldInclude","isSelected","shouldExclude","$isElementNode","excludeFromCopy","target","clone","$cloneWithProperties","$isTextNode","$sliceSelectedTextNodeContent","children","after","exportDOM","fragment","DocumentFragment","childNode","shouldIncludeChild","extractWithChild","append","newElement","call","replaceWith","getConversionFunction","domNode","cachedConversions","_htmlConversions","get","toLowerCase","currentConversion","cachedConversion","domConversion","priority","conversion","Set","node","forChildMap","Map","parentLexicalNode","preformatted","currentLexicalNode","transformFunction","transformOutput","postTransform","forChildFunction","push","forChild","set","childLexicalNodes","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/html/LexicalHtml.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  let lexicalNodes = [];\n  const elements = dom.body ? Array.from(dom.body.childNodes) : [];\n  const elementsLength = elements.length;\n\n  for (let i = 0; i < elementsLength; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (document == null || window == null) {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected() : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = new DocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    element.append(fragment);\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE']);\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode, preformatted = false) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node, undefined, preformatted) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    currentLexicalNode = transformOutput.node;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(currentLexicalNode);\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode, preformatted || (transformOutput && transformOutput.preformatted) === true));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAC7C,IAAIC,OAAO,GAAGD,OAAO,CAAC,SAAS,CAAC;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASE,qBAAqBA,CAACC,MAAM,EAAEC,GAAG,EAAE;EAC1C,IAAIC,YAAY,GAAG,EAAE;EACrB,MAAMC,QAAQ,GAAGF,GAAG,CAACG,IAAI,GAAGC,KAAK,CAACC,IAAI,CAACL,GAAG,CAACG,IAAI,CAACG,UAAU,CAAC,GAAG,EAAE;EAChE,MAAMC,cAAc,GAAGL,QAAQ,CAACM,MAAM;EAEtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,cAAc,EAAEE,CAAC,EAAE,EAAE;IACvC,MAAMC,OAAO,GAAGR,QAAQ,CAACO,CAAC,CAAC;IAE3B,IAAI,CAACE,WAAW,CAACC,GAAG,CAACF,OAAO,CAACG,QAAQ,CAAC,EAAE;MACtC,MAAMC,WAAW,GAAGC,mBAAmB,CAACL,OAAO,EAAEX,MAAM,CAAC;MAExD,IAAIe,WAAW,KAAK,IAAI,EAAE;QACxBb,YAAY,GAAGA,YAAY,CAACe,MAAM,CAACF,WAAW,CAAC;MACjD;IACF;EACF;EAEA,OAAOb,YAAY;AACrB;AACA,SAASgB,sBAAsBA,CAAClB,MAAM,EAAEJ,SAAS,EAAE;EACjD,IAAIuB,QAAQ,IAAI,IAAI,IAAIC,MAAM,IAAI,IAAI,EAAE;IACtC,MAAM,IAAIC,KAAK,CAAC,gJAAgJ,CAAC;EACnK;EAEA,MAAMC,SAAS,GAAGH,QAAQ,CAACI,aAAa,CAAC,KAAK,CAAC;EAC/C,MAAMC,IAAI,GAAG1B,OAAO,CAAC2B,QAAQ,CAAC,CAAC;EAC/B,MAAMC,gBAAgB,GAAGF,IAAI,CAACG,WAAW,CAAC,CAAC;EAE3C,KAAK,IAAIjB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,gBAAgB,CAACjB,MAAM,EAAEC,CAAC,EAAE,EAAE;IAChD,MAAMkB,YAAY,GAAGF,gBAAgB,CAAChB,CAAC,CAAC;IACxCmB,kBAAkB,CAAC7B,MAAM,EAAE4B,YAAY,EAAEN,SAAS,EAAE1B,SAAS,CAAC;EAChE;EAEA,OAAO0B,SAAS,CAACQ,SAAS;AAC5B;AAEA,SAASD,kBAAkBA,CAAC7B,MAAM,EAAE+B,WAAW,EAAEC,aAAa,EAAsB;EAAA,IAApBC,WAAW,GAAAC,SAAA,CAAAzB,MAAA,QAAAyB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAI;EAChF,IAAIE,aAAa,GAAGH,WAAW,IAAI,IAAI,GAAGF,WAAW,CAACM,UAAU,CAAC,CAAC,GAAG,IAAI;EACzE,MAAMC,aAAa,GAAGxC,OAAO,CAACyC,cAAc,CAACR,WAAW,CAAC,IAAIA,WAAW,CAACS,eAAe,CAAC,MAAM,CAAC;EAChG,IAAIC,MAAM,GAAGV,WAAW;EAExB,IAAIE,WAAW,KAAK,IAAI,EAAE;IACxB,IAAIS,KAAK,GAAG9C,SAAS,CAAC+C,oBAAoB,CAACZ,WAAW,CAAC;IACvDW,KAAK,GAAG5C,OAAO,CAAC8C,WAAW,CAACF,KAAK,CAAC,IAAIT,WAAW,IAAI,IAAI,GAAGrC,SAAS,CAACiD,6BAA6B,CAACZ,WAAW,EAAES,KAAK,CAAC,GAAGA,KAAK;IAC/HD,MAAM,GAAGC,KAAK;EAChB;EAEA,MAAMI,QAAQ,GAAGhD,OAAO,CAACyC,cAAc,CAACE,MAAM,CAAC,GAAGA,MAAM,CAACd,WAAW,CAAC,CAAC,GAAG,EAAE;EAC3E,MAAM;IACJhB,OAAO;IACPoC;EACF,CAAC,GAAGN,MAAM,CAACO,SAAS,CAAChD,MAAM,CAAC;EAE5B,IAAI,CAACW,OAAO,EAAE;IACZ,OAAO,KAAK;EACd;EAEA,MAAMsC,QAAQ,GAAG,IAAIC,gBAAgB,CAAC,CAAC;EAEvC,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,QAAQ,CAACrC,MAAM,EAAEC,CAAC,EAAE,EAAE;IACxC,MAAMyC,SAAS,GAAGL,QAAQ,CAACpC,CAAC,CAAC;IAC7B,MAAM0C,kBAAkB,GAAGvB,kBAAkB,CAAC7B,MAAM,EAAEmD,SAAS,EAAEF,QAAQ,EAAEhB,WAAW,CAAC;IAEvF,IAAI,CAACG,aAAa,IAAItC,OAAO,CAACyC,cAAc,CAACR,WAAW,CAAC,IAAIqB,kBAAkB,IAAIrB,WAAW,CAACsB,gBAAgB,CAACF,SAAS,EAAElB,WAAW,EAAE,MAAM,CAAC,EAAE;MAC/IG,aAAa,GAAG,IAAI;IACtB;EACF;EAEA,IAAIA,aAAa,IAAI,CAACE,aAAa,EAAE;IACnC3B,OAAO,CAAC2C,MAAM,CAACL,QAAQ,CAAC;IACxBjB,aAAa,CAACsB,MAAM,CAAC3C,OAAO,CAAC;IAE7B,IAAIoC,KAAK,EAAE;MACT,MAAMQ,UAAU,GAAGR,KAAK,CAACS,IAAI,CAACf,MAAM,EAAE9B,OAAO,CAAC;MAC9C,IAAI4C,UAAU,EAAE5C,OAAO,CAAC8C,WAAW,CAACF,UAAU,CAAC;IACjD;EACF,CAAC,MAAM;IACLvB,aAAa,CAACsB,MAAM,CAACL,QAAQ,CAAC;EAChC;EAEA,OAAOb,aAAa;AACtB;AAEA,SAASsB,qBAAqBA,CAACC,OAAO,EAAE3D,MAAM,EAAE;EAC9C,MAAM;IACJc;EACF,CAAC,GAAG6C,OAAO;EAEX,MAAMC,iBAAiB,GAAG5D,MAAM,CAAC6D,gBAAgB,CAACC,GAAG,CAAChD,QAAQ,CAACiD,WAAW,CAAC,CAAC,CAAC;EAE7E,IAAIC,iBAAiB,GAAG,IAAI;EAE5B,IAAIJ,iBAAiB,KAAKzB,SAAS,EAAE;IACnC,KAAK,MAAM8B,gBAAgB,IAAIL,iBAAiB,EAAE;MAChD,MAAMM,aAAa,GAAGD,gBAAgB,CAACN,OAAO,CAAC;MAE/C,IAAIO,aAAa,KAAK,IAAI,KAAKF,iBAAiB,KAAK,IAAI,IAAIA,iBAAiB,CAACG,QAAQ,GAAGD,aAAa,CAACC,QAAQ,CAAC,EAAE;QACjHH,iBAAiB,GAAGE,aAAa;MACnC;IACF;EACF;EAEA,OAAOF,iBAAiB,KAAK,IAAI,GAAGA,iBAAiB,CAACI,UAAU,GAAG,IAAI;AACzE;AAEA,MAAMxD,WAAW,GAAG,IAAIyD,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC;AAEtC,SAASrD,mBAAmBA,CAACsD,IAAI,EAAEtE,MAAM,EAAoE;EAAA,IAAlEuE,WAAW,GAAArC,SAAA,CAAAzB,MAAA,QAAAyB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,IAAIsC,GAAG,CAAC,CAAC;EAAA,IAAEC,iBAAiB,GAAAvC,SAAA,CAAAzB,MAAA,OAAAyB,SAAA,MAAAC,SAAA;EAAA,IAAEuC,YAAY,GAAAxC,SAAA,CAAAzB,MAAA,QAAAyB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;EACzG,IAAIhC,YAAY,GAAG,EAAE;EAErB,IAAIU,WAAW,CAACC,GAAG,CAACyD,IAAI,CAACxD,QAAQ,CAAC,EAAE;IAClC,OAAOZ,YAAY;EACrB;EAEA,IAAIyE,kBAAkB,GAAG,IAAI;EAC7B,MAAMC,iBAAiB,GAAGlB,qBAAqB,CAACY,IAAI,EAAEtE,MAAM,CAAC;EAC7D,MAAM6E,eAAe,GAAGD,iBAAiB,GAAGA,iBAAiB,CAACN,IAAI,EAAEnC,SAAS,EAAEuC,YAAY,CAAC,GAAG,IAAI;EACnG,IAAII,aAAa,GAAG,IAAI;EAExB,IAAID,eAAe,KAAK,IAAI,EAAE;IAC5BC,aAAa,GAAGD,eAAe,CAAC9B,KAAK;IACrC4B,kBAAkB,GAAGE,eAAe,CAACP,IAAI;IAEzC,IAAIK,kBAAkB,KAAK,IAAI,EAAE;MAC/B,KAAK,MAAM,GAAGI,gBAAgB,CAAC,IAAIR,WAAW,EAAE;QAC9CI,kBAAkB,GAAGI,gBAAgB,CAACJ,kBAAkB,EAAEF,iBAAiB,CAAC;QAE5E,IAAI,CAACE,kBAAkB,EAAE;UACvB;QACF;MACF;MAEA,IAAIA,kBAAkB,EAAE;QACtBzE,YAAY,CAAC8E,IAAI,CAACL,kBAAkB,CAAC;MACvC;IACF;IAEA,IAAIE,eAAe,CAACI,QAAQ,IAAI,IAAI,EAAE;MACpCV,WAAW,CAACW,GAAG,CAACZ,IAAI,CAACxD,QAAQ,EAAE+D,eAAe,CAACI,QAAQ,CAAC;IAC1D;EACF,CAAC,CAAC;EACF;;EAGA,MAAMnC,QAAQ,GAAGwB,IAAI,CAAC/D,UAAU;EAChC,IAAI4E,iBAAiB,GAAG,EAAE;EAE1B,KAAK,IAAIzE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoC,QAAQ,CAACrC,MAAM,EAAEC,CAAC,EAAE,EAAE;IACxCyE,iBAAiB,CAACH,IAAI,CAAC,GAAGhE,mBAAmB,CAAC8B,QAAQ,CAACpC,CAAC,CAAC,EAAEV,MAAM,EAAE,IAAIwE,GAAG,CAACD,WAAW,CAAC,EAAEI,kBAAkB,EAAED,YAAY,IAAI,CAACG,eAAe,IAAIA,eAAe,CAACH,YAAY,MAAM,IAAI,CAAC,CAAC;EAC3L;EAEA,IAAII,aAAa,IAAI,IAAI,EAAE;IACzBK,iBAAiB,GAAGL,aAAa,CAACK,iBAAiB,CAAC;EACtD;EAEA,IAAIR,kBAAkB,IAAI,IAAI,EAAE;IAC9B;IACA;IACAzE,YAAY,GAAGA,YAAY,CAACe,MAAM,CAACkE,iBAAiB,CAAC;EACvD,CAAC,MAAM;IACL,IAAIrF,OAAO,CAACyC,cAAc,CAACoC,kBAAkB,CAAC,EAAE;MAC9C;MACA;MACAA,kBAAkB,CAACrB,MAAM,CAAC,GAAG6B,iBAAiB,CAAC;IACjD;EACF;EAEA,OAAOjF,YAAY;AACrB;AAEAkF,OAAO,CAAClE,sBAAsB,GAAGA,sBAAsB;AACvDkE,OAAO,CAACrF,qBAAqB,GAAGA,qBAAqB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}