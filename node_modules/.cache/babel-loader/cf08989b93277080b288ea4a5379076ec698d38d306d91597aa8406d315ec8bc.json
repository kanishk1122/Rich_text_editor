{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url) {\n    let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let key = arguments.length > 2 ? arguments[2] : undefined;\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    if (anchor instanceof HTMLAnchorElement) {\n      const url = this.__url;\n      const target = this.__target;\n      const rel = this.__rel;\n      const title = this.__title;\n      if (url !== prevNode.__url) {\n        anchor.href = url;\n      }\n      if (target !== prevNode.__target) {\n        if (target) {\n          anchor.target = target;\n        } else {\n          anchor.removeAttribute('target');\n        }\n      }\n      if (rel !== prevNode.__rel) {\n        if (rel) {\n          anchor.rel = rel;\n        } else {\n          anchor.removeAttribute('rel');\n        }\n      }\n      if (title !== prevNode.__title) {\n        if (title) {\n          anchor.title = title;\n        } else {\n          anchor.removeAttribute('title');\n        }\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n  insertNewAfter(_) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url, attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url) {\n    let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let key = arguments.length > 2 ? arguments[2] : undefined;\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      isUnlinked: serializedNode.isUnlinked,\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked,\n      type: 'autolink',\n      version: 1\n    };\n  }\n  insertNewAfter(selection) {\n    let restoreSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url, attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url) {\n  let attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (!$isAutoLinkNode(parent) && $isLinkNode(parent)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0];\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode = $getAncestor(firstNode, $isLinkNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n    }\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (parent === linkNode || parent === null || $isElementNode(node) && !node.isInline()) {\n        return;\n      }\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target,\n          title\n        });\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n        node.remove();\n        return;\n      }\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, toggleLink };","map":{"version":3,"names":["addClassNamesToElement","isHTMLAnchorElement","createCommand","ElementNode","$isRangeSelection","$applyNodeReplacement","$isElementNode","$getSelection","SUPPORTED_URL_PROTOCOLS","Set","LinkNode","getType","clone","node","__url","rel","__rel","target","__target","title","__title","__key","constructor","url","attributes","arguments","length","undefined","key","createDOM","config","element","document","createElement","href","sanitizeUrl","theme","link","updateDOM","prevNode","anchor","HTMLAnchorElement","removeAttribute","importDOM","a","conversion","$convertAnchorElement","priority","importJSON","serializedNode","$createLinkNode","setFormat","format","setIndent","indent","setDirection","direction","parsedUrl","URL","has","protocol","_unused","exportJSON","getRel","getTarget","getTitle","type","getURL","version","getLatest","setURL","writable","getWritable","setTarget","setRel","setTitle","insertNewAfter","_","restoreSelection","linkNode","insertAfter","canInsertTextBefore","canInsertTextAfter","canBeEmpty","isInline","extractWithChild","child","selection","destination","anchorNode","getNode","focusNode","focus","isParentOf","getTextContent","isEmailURI","startsWith","isWebSiteURI","domNode","content","textContent","children","getAttribute","$isLinkNode","AutoLinkNode","__isUnlinked","isUnlinked","getIsUnlinked","setIsUnlinked","value","self","$createAutoLinkNode","getParentOrThrow","append","$isAutoLinkNode","TOGGLE_LINK_COMMAND","$toggleLink","nodes","extract","forEach","parent","getParent","getChildren","i","insertBefore","remove","firstNode","$getAncestor","prevParent","is","getPreviousSibling","toggleLink","predicate"],"sources":["/media/ks/My thing/test/textditor_Using_lixical/node_modules/@lexical/link/LexicalLink.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url, attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    if (anchor instanceof HTMLAnchorElement) {\n      const url = this.__url;\n      const target = this.__target;\n      const rel = this.__rel;\n      const title = this.__title;\n      if (url !== prevNode.__url) {\n        anchor.href = url;\n      }\n      if (target !== prevNode.__target) {\n        if (target) {\n          anchor.target = target;\n        } else {\n          anchor.removeAttribute('target');\n        }\n      }\n      if (rel !== prevNode.__rel) {\n        if (rel) {\n          anchor.rel = rel;\n        } else {\n          anchor.removeAttribute('rel');\n        }\n      }\n      if (title !== prevNode.__title) {\n        if (title) {\n          anchor.title = title;\n        } else {\n          anchor.removeAttribute('title');\n        }\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createLinkNode(serializedNode.url, {\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      type: 'link',\n      url: this.getURL(),\n      version: 1\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url, attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url, attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    const node = $createAutoLinkNode(serializedNode.url, {\n      isUnlinked: serializedNode.isUnlinked,\n      rel: serializedNode.rel,\n      target: serializedNode.target,\n      title: serializedNode.title\n    });\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked,\n      type: 'autolink',\n      version: 1\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url, attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (!$isAutoLinkNode(parent) && $isLinkNode(parent)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parent.insertBefore(children[i]);\n        }\n        parent.remove();\n      }\n    });\n  } else {\n    // Add or merge LinkNodes\n    if (nodes.length === 1) {\n      const firstNode = nodes[0];\n      // if the first node is a LinkNode or if its\n      // parent is a LinkNode, we update the URL, target and rel.\n      const linkNode = $getAncestor(firstNode, $isLinkNode);\n      if (linkNode !== null) {\n        linkNode.setURL(url);\n        if (target !== undefined) {\n          linkNode.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n    }\n    let prevParent = null;\n    let linkNode = null;\n    nodes.forEach(node => {\n      const parent = node.getParent();\n      if (parent === linkNode || parent === null || $isElementNode(node) && !node.isInline()) {\n        return;\n      }\n      if ($isLinkNode(parent)) {\n        linkNode = parent;\n        parent.setURL(url);\n        if (target !== undefined) {\n          parent.setTarget(target);\n        }\n        if (rel !== null) {\n          linkNode.setRel(rel);\n        }\n        if (title !== undefined) {\n          linkNode.setTitle(title);\n        }\n        return;\n      }\n      if (!parent.is(prevParent)) {\n        prevParent = parent;\n        linkNode = $createLinkNode(url, {\n          rel,\n          target,\n          title\n        });\n        if ($isLinkNode(parent)) {\n          if (node.getPreviousSibling() === null) {\n            parent.insertBefore(linkNode);\n          } else {\n            parent.insertAfter(linkNode);\n          }\n        } else {\n          node.insertBefore(linkNode);\n        }\n      }\n      if ($isLinkNode(node)) {\n        if (node.is(linkNode)) {\n          return;\n        }\n        if (linkNode !== null) {\n          const children = node.getChildren();\n          for (let i = 0; i < children.length; i++) {\n            linkNode.append(children[i]);\n          }\n        }\n        node.remove();\n        return;\n      }\n      if (linkNode !== null) {\n        linkNode.append(node);\n      }\n    });\n  }\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, toggleLink };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}