{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar link = require('@lexical/link');\nvar mark = require('@lexical/mark');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '├',\n  isLastChild: '└',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nfunction TreeView(_ref) {\n  let {\n    timeTravelButtonClassName,\n    timeTravelPanelSliderClassName,\n    timeTravelPanelButtonClassName,\n    viewClassName,\n    timeTravelPanelClassName,\n    editor\n  } = _ref;\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = React.useState([]);\n  const [content, setContent] = React.useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = React.useState(false);\n  const playingIndexRef = React.useRef(0);\n  const treeElementRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  const [isPlaying, setIsPlaying] = React.useState(false);\n  React.useEffect(() => {\n    setContent(generateContent(editor.getEditorState()));\n    return editor.registerUpdateListener(_ref2 => {\n      let {\n        editorState\n      } = _ref2;\n      const compositionKey = editor._compositionKey;\n      const treeText = generateContent(editor.getEditorState());\n      const compositionText = compositionKey !== null && `Composition key: ${compositionKey}`;\n      setContent([treeText, compositionText].filter(Boolean).join('\\n\\n'));\n      if (!timeTravelEnabled) {\n        setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n      }\n    });\n  }, [timeTravelEnabled, editor]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  React.useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          editor.setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, editor, totalEditorStates]);\n  React.useEffect(() => {\n    const element = treeElementRef.current;\n    if (element !== null) {\n      // @ts-ignore Internal field\n      element.__lexicalEditor = editor;\n      return () => {\n        // @ts-ignore Internal field\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: viewClassName\n  }, !timeTravelEnabled && totalEditorStates > 2 && /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'false';\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      }\n    },\n    className: timeTravelButtonClassName,\n    type: \"button\"\n  }, \"Time Travel\"), /*#__PURE__*/React.createElement(\"pre\", {\n    ref: treeElementRef\n  }, content), timeTravelEnabled && /*#__PURE__*/React.createElement(\"div\", {\n    className: timeTravelPanelClassName\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      setIsPlaying(!isPlaying);\n    },\n    type: \"button\"\n  }, isPlaying ? 'Pause' : 'Play'), /*#__PURE__*/React.createElement(\"input\", {\n    className: timeTravelPanelSliderClassName,\n    ref: inputRef,\n    onChange: event => {\n      const editorStateIndex = Number(event.target.value);\n      const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n      if (timeStampedEditorState) {\n        playingIndexRef.current = editorStateIndex;\n        editor.setEditorState(timeStampedEditorState[1]);\n      }\n    },\n    type: \"range\",\n    min: \"1\",\n    max: totalEditorStates - 1\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'true';\n        const index = timeStampedEditorStates.length - 1;\n        const timeStampedEditorState = timeStampedEditorStates[index];\n        editor.setEditorState(timeStampedEditorState[1]);\n        const input = inputRef.current;\n        if (input !== null) {\n          input.value = String(index);\n        }\n        setTimeTravelEnabled(false);\n        setIsPlaying(false);\n      }\n    },\n    type: \"button\"\n  }, \"Exit\")));\n}\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\nfunction printObjectSelection(selection) {\n  return `: node\\n  └ [${Array.from(selection._nodes).join(', ')}]`;\n}\nfunction printGridSelection(selection) {\n  return `: grid\\n  └ { grid: ${selection.gridKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\nfunction generateContent(editorState) {\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = lexical.$getSelection();\n    visitTree(lexical.$getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      const idsDisplay = mark.$isMarkNode(node) ? ` id: [ ${node.getIDs().join(', ')} ] ` : '';\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}\\n`;\n      res += printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : lexical.$isRangeSelection(selection) ? printRangeSelection(selection) : lexical.DEPRECATED_$isGridSelection(selection) ? printGridSelection(selection) : printObjectSelection(selection);\n  });\n  return res + '\\n selection' + selectionString;\n}\nfunction visitTree(currentNode, visitor) {\n  let indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n    if (lexical.$isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\nfunction normalize(text) {\n  return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, _ref3) => {\n    let [key, value] = _ref3;\n    return acc.replace(new RegExp(key, 'g'), String(value));\n  }, text);\n} // TODO Pass via props to allow customizability\n\nfunction printNode(node) {\n  if (lexical.$isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if (link.$isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else {\n    return '';\n  }\n}\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node)].filter(Boolean).join(', ');\n}\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n  return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n  return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printTargetProperties(node) {\n  let str = node.getTarget(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n  return str;\n}\nfunction printRelProperties(node) {\n  let str = node.getRel(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n  return str;\n}\nfunction printSelectedCharsLine(_ref4) {\n  let {\n    indent,\n    isSelected,\n    node,\n    nodeKeyDisplay,\n    selection,\n    typeDisplay\n  } = _ref4;\n  // No selection or node is not selected.\n  if (!lexical.$isTextNode(node) || !lexical.$isRangeSelection(selection) || !isSelected || lexical.$isElementNode(node)) {\n    return '';\n  } // No selected characters.\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n  const [start, end] = $getSelectionStartEnd(node, selection);\n  if (start === end) {\n    return '';\n  }\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 3; // 2 for the spaces around + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\nfunction $getSelectionStartEnd(node, selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1; // Only one node is being selected.\n\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  } // Account for non-single width characters.\n\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\nexports.TreeView = TreeView;","map":{"version":3,"names":["link","require","mark","lexical","React","NON_SINGLE_WIDTH_CHARS_REPLACEMENT","Object","freeze","NON_SINGLE_WIDTH_CHARS_REGEX","RegExp","keys","join","SYMBOLS","ancestorHasNextSibling","ancestorIsLastChild","hasNextSibling","isLastChild","selectedChar","selectedLine","TreeView","_ref","timeTravelButtonClassName","timeTravelPanelSliderClassName","timeTravelPanelButtonClassName","viewClassName","timeTravelPanelClassName","editor","timeStampedEditorStates","setTimeStampedEditorStates","useState","content","setContent","timeTravelEnabled","setTimeTravelEnabled","playingIndexRef","useRef","treeElementRef","inputRef","isPlaying","setIsPlaying","useEffect","generateContent","getEditorState","registerUpdateListener","_ref2","editorState","compositionKey","_compositionKey","treeText","compositionText","filter","Boolean","currentEditorStates","Date","now","totalEditorStates","length","timeoutId","play","currentIndex","current","currentTime","nextTime","timeDiff","setTimeout","index","input","value","String","setEditorState","clearTimeout","element","__lexicalEditor","createElement","className","onClick","rootElement","getRootElement","contentEditable","type","ref","onChange","event","editorStateIndex","Number","target","timeStampedEditorState","min","max","printRangeSelection","selection","res","formatText","printFormatProperties","anchor","focus","anchorOffset","offset","focusOffset","key","printObjectSelection","Array","from","_nodes","printGridSelection","gridKey","selectionString","read","$getSelection","visitTree","$getRoot","node","indent","nodeKey","getKey","nodeKeyDisplay","typeDisplay","getType","isSelected","idsDisplay","$isMarkNode","getIDs","printNode","printSelectedCharsLine","$isRangeSelection","DEPRECATED_$isGridSelection","currentNode","visitor","arguments","undefined","childNodes","getChildren","childNodesLength","forEach","childNode","i","concat","$isElementNode","normalize","text","entries","reduce","acc","_ref3","replace","$isTextNode","getTextContent","title","properties","printAllTextNodeProperties","trim","$isLinkNode","getURL","printAllLinkNodeProperties","FORMAT_PREDICATES","hasFormat","DETAIL_PREDICATES","isDirectionless","isUnmergeable","MODE_PREDICATES","isToken","isSegmented","printDetailProperties","printModeProperties","printTargetProperties","printRelProperties","nodeOrSelection","str","map","predicate","toLocaleLowerCase","getTarget","getRel","_ref4","getNode","start","end","$getSelectionStartEnd","selectionLastIndent","indentionChars","slice","unselectedChars","fill","selectedChars","paddingLength","nodePrintSpaces","textContent","textLength","anchorNode","focusNode","isBefore","numNonSingleWidthCharBeforeSelection","match","numNonSingleWidthCharInSelection","exports"],"sources":["/media/ks/My thing/test/textditor/node_modules/@lexical/react/LexicalTreeView.dev.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar link = require('@lexical/link');\nvar mark = require('@lexical/mark');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '├',\n  isLastChild: '└',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nfunction TreeView({\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editor\n}) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = React.useState([]);\n  const [content, setContent] = React.useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = React.useState(false);\n  const playingIndexRef = React.useRef(0);\n  const treeElementRef = React.useRef(null);\n  const inputRef = React.useRef(null);\n  const [isPlaying, setIsPlaying] = React.useState(false);\n  React.useEffect(() => {\n    setContent(generateContent(editor.getEditorState()));\n    return editor.registerUpdateListener(({\n      editorState\n    }) => {\n      const compositionKey = editor._compositionKey;\n      const treeText = generateContent(editor.getEditorState());\n      const compositionText = compositionKey !== null && `Composition key: ${compositionKey}`;\n      setContent([treeText, compositionText].filter(Boolean).join('\\n\\n'));\n\n      if (!timeTravelEnabled) {\n        setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n      }\n    });\n  }, [timeTravelEnabled, editor]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  React.useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n\n          if (input !== null) {\n            input.value = String(index);\n          }\n\n          editor.setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, editor, totalEditorStates]);\n  React.useEffect(() => {\n    const element = treeElementRef.current;\n\n    if (element !== null) {\n      // @ts-ignore Internal field\n      element.__lexicalEditor = editor;\n      return () => {\n        // @ts-ignore Internal field\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: viewClassName\n  }, !timeTravelEnabled && totalEditorStates > 2 && /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'false';\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      }\n    },\n    className: timeTravelButtonClassName,\n    type: \"button\"\n  }, \"Time Travel\"), /*#__PURE__*/React.createElement(\"pre\", {\n    ref: treeElementRef\n  }, content), timeTravelEnabled && /*#__PURE__*/React.createElement(\"div\", {\n    className: timeTravelPanelClassName\n  }, /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      setIsPlaying(!isPlaying);\n    },\n    type: \"button\"\n  }, isPlaying ? 'Pause' : 'Play'), /*#__PURE__*/React.createElement(\"input\", {\n    className: timeTravelPanelSliderClassName,\n    ref: inputRef,\n    onChange: event => {\n      const editorStateIndex = Number(event.target.value);\n      const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n\n      if (timeStampedEditorState) {\n        playingIndexRef.current = editorStateIndex;\n        editor.setEditorState(timeStampedEditorState[1]);\n      }\n    },\n    type: \"range\",\n    min: \"1\",\n    max: totalEditorStates - 1\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    className: timeTravelPanelButtonClassName,\n    onClick: () => {\n      const rootElement = editor.getRootElement();\n\n      if (rootElement !== null) {\n        rootElement.contentEditable = 'true';\n        const index = timeStampedEditorStates.length - 1;\n        const timeStampedEditorState = timeStampedEditorStates[index];\n        editor.setEditorState(timeStampedEditorState[1]);\n        const input = inputRef.current;\n\n        if (input !== null) {\n          input.value = String(index);\n        }\n\n        setTimeTravelEnabled(false);\n        setIsPlaying(false);\n      }\n    },\n    type: \"button\"\n  }, \"Exit\")));\n}\n\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\n\nfunction printObjectSelection(selection) {\n  return `: node\\n  └ [${Array.from(selection._nodes).join(', ')}]`;\n}\n\nfunction printGridSelection(selection) {\n  return `: grid\\n  └ { grid: ${selection.gridKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\n\nfunction generateContent(editorState) {\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = lexical.$getSelection();\n    visitTree(lexical.$getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      const idsDisplay = mark.$isMarkNode(node) ? ` id: [ ${node.getIDs().join(', ')} ] ` : '';\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${idsDisplay} ${printNode(node)}\\n`;\n      res += printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : lexical.$isRangeSelection(selection) ? printRangeSelection(selection) : lexical.DEPRECATED_$isGridSelection(selection) ? printGridSelection(selection) : printObjectSelection(selection);\n  });\n  return res + '\\n selection' + selectionString;\n}\n\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n\n    if (lexical.$isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\n\nfunction normalize(text) {\n  return Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n} // TODO Pass via props to allow customizability\n\n\nfunction printNode(node) {\n  if (lexical.$isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if (link.$isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else {\n    return '';\n  }\n}\n\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\n\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\n\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node)].filter(Boolean).join(', ');\n}\n\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n\n  return str;\n}\n\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n\n  return str;\n}\n\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n\n  return str;\n}\n\nfunction printTargetProperties(node) {\n  let str = node.getTarget(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n\n  return str;\n}\n\nfunction printRelProperties(node) {\n  let str = node.getRel(); // TODO Fix nullish on LinkNode\n\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n\n  return str;\n}\n\nfunction printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!lexical.$isTextNode(node) || !lexical.$isRangeSelection(selection) || !isSelected || lexical.$isElementNode(node)) {\n    return '';\n  } // No selected characters.\n\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n\n  const [start, end] = $getSelectionStartEnd(node, selection);\n\n  if (start === end) {\n    return '';\n  }\n\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 3; // 2 for the spaces around + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\n\nfunction $getSelectionStartEnd(node, selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1; // Only one node is being selected.\n\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  } // Account for non-single width characters.\n\n\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\nexports.TreeView = TreeView;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}